<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"csumoke.com","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.17.1","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"bookmark":{"enable":true,"color":"#0080ff","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":true,"nav":null,"activeClass":"disqus"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>



<link rel="canonical" href="https://csumoke.com/2023/12/07/notes/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://csumoke.com/2023/12/07/notes/","path":"2023/12/07/notes/","title":"前端实习面试问题准备"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>前端实习面试问题准备 | Voilà</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-GC00V96X32"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-GC00V96X32","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Voilà</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">moke's blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8%E8%BF%9B%E5%BA%A6%E6%9D%A1"><span class="nav-number">1.</span> <span class="nav-text">视频播放器进度条</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Node-js-%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E4%B8%8D%E4%B8%AD%E6%96%AD%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">Node.js 单线程如何保证线程不中断？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#websocket-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">websocket 建立连接的过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#websocket%E5%92%8C%E9%95%BF%E8%BD%AE%E8%AF%A2%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.</span> <span class="nav-text">websocket和长轮询的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#WebSocket"><span class="nav-number">4.1.</span> <span class="nav-text">WebSocket</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%95%BF%E8%BD%AE%E8%AF%A2"><span class="nav-number">4.2.</span> <span class="nav-text">长轮询</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="nav-number">5.</span> <span class="nav-text">tcp 如何保证可靠性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E7%AE%97%E6%B3%95"><span class="nav-number">6.</span> <span class="nav-text">拥塞算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">7.</span> <span class="nav-text">三次握手</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9ASYN"><span class="nav-number">7.1.</span> <span class="nav-text">第一次握手：SYN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9ASYN-ACK"><span class="nav-number">7.2.</span> <span class="nav-text">第二次握手：SYN-ACK</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9AACK"><span class="nav-number">7.3.</span> <span class="nav-text">第三次握手：ACK</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F"><span class="nav-number">7.4.</span> <span class="nav-text">为什么需要三次握手？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http-%E5%92%8C-tcp-%E7%9A%84-keep-alive-%E5%8C%BA%E5%88%AB"><span class="nav-number">8.</span> <span class="nav-text">http 和 tcp 的 keep-alive 区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-Keep-Alive"><span class="nav-number">8.1.</span> <span class="nav-text">HTTP Keep-Alive</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-Keep-Alive"><span class="nav-number">8.2.</span> <span class="nav-text">TCP Keep-Alive</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93"><span class="nav-number">8.3.</span> <span class="nav-text">区别总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#js-%E9%97%AD%E5%8C%85%E3%80%81%E5%8E%9F%E5%9E%8B%E3%80%81%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="nav-number">9.</span> <span class="nav-text">js 闭包、原型、事件循环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AD%E5%8C%85%EF%BC%88Closure%EF%BC%89"><span class="nav-number">9.1.</span> <span class="nav-text">闭包（Closure）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%EF%BC%88Prototype%EF%BC%89"><span class="nav-number">9.2.</span> <span class="nav-text">原型（Prototype）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88Event-Loop%EF%BC%89"><span class="nav-number">9.3.</span> <span class="nav-text">事件循环（Event Loop）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#webpack-%E4%B8%8E-vite"><span class="nav-number">10.</span> <span class="nav-text">webpack 与 vite</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Webpack"><span class="nav-number">10.1.</span> <span class="nav-text">Webpack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vite"><span class="nav-number">10.2.</span> <span class="nav-text">Vite</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB"><span class="nav-number">10.3.</span> <span class="nav-text">主要区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue2-%E5%92%8C-vue3"><span class="nav-number">11.</span> <span class="nav-text">vue2 和 vue3</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E6%94%B9%E8%BF%9B"><span class="nav-number">11.1.</span> <span class="nav-text">性能改进</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E5%BC%8F-API"><span class="nav-number">11.2.</span> <span class="nav-text">组合式 API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E5%A5%BD%E7%9A%84-TypeScript-%E6%94%AF%E6%8C%81"><span class="nav-number">11.3.</span> <span class="nav-text">更好的 TypeScript 支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%96%B0%E7%89%B9%E6%80%A7%E5%92%8C%E6%94%B9%E8%BF%9B"><span class="nav-number">11.4.</span> <span class="nav-text">其他新特性和改进</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%BC%E5%AE%B9%E6%80%A7%E5%92%8C%E8%BF%81%E7%A7%BB"><span class="nav-number">11.5.</span> <span class="nav-text">兼容性和迁移</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nextTick"><span class="nav-number">12.</span> <span class="nav-text">nextTick</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">12.1.</span> <span class="nav-text">基本原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="nav-number">12.2.</span> <span class="nav-text">工作机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">12.3.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">12.4.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">12.5.</span> <span class="nav-text">注意事项</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="moke"
      src="/images/avatar_kazuha_with_cats.jpg">
  <p class="site-author-name" itemprop="name">moke</p>
  <div class="site-description" itemprop="description">C'est pour cela que je suis née</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2plcnJ5NzY1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jerry765"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOjIwNjE2MTA1NzlAcXEuY29t" title="E-Mail → mailto:2061610579@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/big/by_nc_sa.svg" alt="Creative Commons"></span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <span class="exturl" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMzkxNDM5MDY5" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;391439069">Bilibili</span>
            </li>
        </ul>
      </div>
    </div>
        <div class="pjax">
        <div class="sidebar-inner sidebar-post-related">
          <div class="animated">
              <div class="links-of-blogroll-title"><i class="fa fa-signs-post fa-fw"></i>
    相关文章
  </div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <a class="popular-posts-link" href="/2023/08/22/use-websocket-in-vue/" rel="bookmark">
        <time class="popular-posts-time">2023-08-22</time>
        <br>
      websocket 在 vue 中的使用
      </a>
    </li>
    <li class="popular-posts-item">
      <a class="popular-posts-link" href="/2023/08/26/note-nodeJs/" rel="bookmark">
        <time class="popular-posts-time">2023-08-26</time>
        <br>
      Node.js 笔记
      </a>
    </li>
  </ul>

          </div>
        </div>
        </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://csumoke.com/2023/12/07/notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar_kazuha_with_cats.jpg">
      <meta itemprop="name" content="moke">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Voilà">
      <meta itemprop="description" content="C'est pour cela que je suis née">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="前端实习面试问题准备 | Voilà">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          前端实习面试问题准备
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-12-07 16:29:16 / 修改时间：16:39:37" itemprop="dateCreated datePublished" datetime="2023-12-07T16:29:16+08:00">2023-12-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/work/" itemprop="url" rel="index"><span itemprop="name">work</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2023/12/07/notes/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2023/12/07/notes/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>26 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="视频播放器进度条"><a href="#视频播放器进度条" class="headerlink" title="视频播放器进度条"></a>视频播放器进度条</h2><p>视频播放器的进度条是一种用户界面组件，它显示了视频播放的当前位置和总时长，并允许用户通过拖动或点击进度条来跳转到视频的不同位置。实现这一功能通常涉及以下几个关键步骤：</p>
<ol>
<li><p><strong>HTML结构</strong>: 使用HTML创建进度条的基本结构。通常包括一个容器（如<code>div</code>元素），内部可能有用于显示进度的子元素。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;progress-bar-container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;progress-bar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>CSS样式</strong>: 通过CSS对进度条进行样式设计，如宽度、高度、颜色等。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#progress-bar-container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: grey;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#progress-bar</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0%</span>; <span class="comment">/* 初始宽度 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>JavaScript交互</strong>:</p>
<ul>
<li><p><strong>播放进度更新</strong>: 使用JavaScript监听视频播放器的<code>timeupdate</code>事件。当事件触发时，根据视频的<code>currentTime</code>和<code>duration</code>属性计算进度，并更新进度条的宽度。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> video = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;my-video&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> progressBar = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;progress-bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line">video.<span class="title function_">addEventListener</span>(<span class="string">&#x27;timeupdate&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> progress = (video.<span class="property">currentTime</span> / video.<span class="property">duration</span>) * <span class="number">100</span>;</span><br><span class="line">    progressBar.<span class="property">style</span>.<span class="property">width</span> = progress + <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>用户交互处理</strong>: 允许用户通过点击或拖动进度条来跳转视频。这通常涉及监听进度条的点击事件，计算点击位置相对于进度条的百分比，然后将视频的<code>currentTime</code>设置为<code>duration</code>乘以这个百分比。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> progressBarContainer = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;progress-bar-container&#x27;</span>);</span><br><span class="line"></span><br><span class="line">progressBarContainer.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> percent = e.<span class="property">offsetX</span> / progressBarContainer.<span class="property">offsetWidth</span>;</span><br><span class="line">    video.<span class="property">currentTime</span> = percent * video.<span class="property">duration</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>这些步骤展示了一个基本的视频播放器进度条的实现方式。当然，实际应用中可能需要更复杂的处理，比如考虑缓冲状态的显示、拖动操作的优化等。</p>
<span id="more"></span>

<h2 id="Node-js-单线程如何保证线程不中断？"><a href="#Node-js-单线程如何保证线程不中断？" class="headerlink" title="Node.js 单线程如何保证线程不中断？"></a>Node.js 单线程如何保证线程不中断？</h2><p>Node.js 被广泛认为是单线程的，但这个说法需要更准确的解释。Node.js 的主执行线程是单线程的，它运行在 V8 JavaScript 引擎上。然而，Node.js 使用多线程来处理 I&#x2F;O 密集型任务，这是通过其底层的 libuv 库实现的。以下是 Node.js 保证其单线程不中断的几个关键方面：</p>
<ol>
<li><p><strong>异步非阻塞 I&#x2F;O</strong>:</p>
<ul>
<li>Node.js 主要依靠事件循环和回调函数来处理 I&#x2F;O 操作（如文件读写、网络请求等），这些操作是异步和非阻塞的。</li>
<li>当一个 I&#x2F;O 操作开始时，它会被发送到事件循环，并继续执行后续的代码，而不是等待 I&#x2F;O 操作完成。当 I&#x2F;O 操作完成时，相应的回调函数会被放入事件队列中，等待主线程空闲时执行。</li>
</ul>
</li>
<li><p><strong>事件驱动架构</strong>:</p>
<ul>
<li>Node.js 使用事件驱动模型来处理各种异步操作。每当有事件发生时（如数据到达、超时、处理完成），相应的回调函数会被触发。</li>
<li>这种模型使得 Node.js 能够在不被阻塞的情况下高效地处理大量的并发请求。</li>
</ul>
</li>
<li><p><strong>libuv 库</strong>:</p>
<ul>
<li>尽管 JavaScript 代码在单个主线程上运行，Node.js 使用 libuv 库在背后管理一个线程池。</li>
<li>对于一些复杂的操作（如文件系统操作、某些加密操作），libuv 会在后台的多个线程上执行这些任务，而主线程继续执行 JavaScript 代码。</li>
</ul>
</li>
<li><p><strong>错误处理机制</strong>:</p>
<ul>
<li>Node.js 提供了异常处理机制，比如 <code>try-catch</code> 块和全局的 <code>uncaughtException</code> 事件，来处理同步和异步代码中的错误。</li>
<li>正确的错误处理能够防止异常导致主线程崩溃。</li>
</ul>
</li>
<li><p><strong>进程管理</strong>:</p>
<ul>
<li>对于 CPU 密集型任务，可以使用 Node.js 的 <code>child_process</code> 模块来创建子进程，分担主线程的负载。</li>
<li>还可以使用集群（Cluster）模块来创建多个进程，每个进程都有自己的事件循环和 V8 实例，可以更好地利用多核 CPU。</li>
</ul>
</li>
</ol>
<p>通过这些机制，Node.js 能够确保即使是在单个主线程上运行，也能高效地处理大量的并发 I&#x2F;O 操作，同时避免线程中断和阻塞。</p>
<h2 id="websocket-建立连接的过程"><a href="#websocket-建立连接的过程" class="headerlink" title="websocket 建立连接的过程"></a>websocket 建立连接的过程</h2><p>WebSocket 建立连接的过程是一个升级自 HTTP 协议的握手过程。WebSocket 允许在用户的浏览器和服务器之间建立一个持久的连接，使得数据可以双向传输。下面是 WebSocket 建立连接的详细步骤：</p>
<ol>
<li><p><strong>客户端发送握手请求</strong>:</p>
<ul>
<li>首先，客户端（通常是一个网页的 JavaScript）通过发送一个 HTTP 请求来初始化 WebSocket 连接。这个请求被称为”握手请求”。</li>
<li>这个请求使用普通的 HTTP GET 方法，但在请求头中包含特定的头部字段，指示这是一个 WebSocket 连接请求。主要的头部字段包括：<ul>
<li><code>Upgrade: websocket</code>：告诉服务器，客户端希望将 HTTP 连接升级到 WebSocket。</li>
<li><code>Connection: Upgrade</code>：同样表示这是一个升级请求。</li>
<li><code>Sec-WebSocket-Key</code>：一个 Base64 编码的随机值，服务器将用它来构建一个响应密钥，验证连接。</li>
<li><code>Sec-WebSocket-Version</code>：标示客户端支持的 WebSocket 版本。</li>
<li><code>Origin</code>（可选）：指示请求来自哪个源，用于服务器的跨源策略。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>服务器响应握手</strong>:</p>
<ul>
<li>服务器解析这个握手请求，如果接受升级请求，则会发送一个 HTTP 101 Switching Protocols 响应。</li>
<li>服务器的响应也包含几个特定的头部字段：<ul>
<li><code>Upgrade: websocket</code> 和 <code>Connection: Upgrade</code>：确认升级到 WebSocket。</li>
<li><code>Sec-WebSocket-Accept</code>：这是对客户端 <code>Sec-WebSocket-Key</code> 的响应，由服务器生成，客户端会验证这个值以确认连接的有效性。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>连接建立</strong>:</p>
<ul>
<li>客户端收到服务器的 101 响应后，WebSocket 连接被视为已经建立，客户端和服务器就可以开始通过这个连接双向传输数据了。</li>
<li>此时，连接从 HTTP 协议升级为 WebSocket 协议。</li>
</ul>
</li>
<li><p><strong>数据传输</strong>:</p>
<ul>
<li>一旦连接建立，客户端和服务器就可以开始发送和接收消息。</li>
<li>WebSocket 协议支持文本和二进制数据的传输。</li>
</ul>
</li>
<li><p><strong>保持连接</strong>:</p>
<ul>
<li>WebSocket 连接会保持活跃状态，直到客户端或服务器决定关闭连接。</li>
<li>连接保持活跃使得双方可以随时发送数据，无需重新建立连接。</li>
</ul>
</li>
</ol>
<p>这个握手过程的设计允许 WebSocket 连接轻松地穿过大多数防火墙，因为它们在初始阶段模仿标准的 HTTP 连接。这种方法还使得在不支持 WebSocket 的环境中回退到其他协议（如长轮询）变得更加容易。</p>
<h2 id="websocket和长轮询的区别"><a href="#websocket和长轮询的区别" class="headerlink" title="websocket和长轮询的区别"></a>websocket和长轮询的区别</h2><p>WebSocket 和长轮询（Long Polling）是两种在客户端和服务器之间实现实时数据通信的技术，但它们在工作原理和效率方面有显著区别。下面是 WebSocket 和长轮询之间的主要区别：</p>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><ol>
<li><p><strong>持久连接</strong>:</p>
<ul>
<li>WebSocket 协议建立的是一个持久的、全双工的连接。一旦连接建立，客户端和服务器可以随时互相发送数据，直到任一方主动关闭连接。</li>
</ul>
</li>
<li><p><strong>协议升级</strong>:</p>
<ul>
<li>WebSocket 通过一次 HTTP 握手升级到 WebSocket 协议。握手完成后，协议从 HTTP 切换到 WebSocket，这个连接将保持打开状态，不再是 HTTP 协议。</li>
</ul>
</li>
<li><p><strong>高效率</strong>:</p>
<ul>
<li>因为连接是持久的，所以不存在为了每次数据交换而建立和终止连接的额外开销。这使得 WebSocket 在数据实时性和网络效率方面优于长轮询。</li>
</ul>
</li>
<li><p><strong>双向通信</strong>:</p>
<ul>
<li>WebSocket 支持全双工通信，即客户端和服务器可以同时发送和接收数据。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>:</p>
<ul>
<li>适合需要高频率、实时性强的应用场景，例如在线游戏、实时聊天、实时数据更新等。</li>
</ul>
</li>
</ol>
<h3 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h3><ol>
<li><p><strong>基于 HTTP 请求</strong>:</p>
<ul>
<li>长轮询是在标准的 HTTP 协议上工作的。客户端发送一个 HTTP 请求到服务器，服务器保持这个请求开放直到有数据可发送。</li>
</ul>
</li>
<li><p><strong>非持久连接</strong>:</p>
<ul>
<li>每次服务器向客户端发送响应后，连接被关闭。对于新的数据，客户端需要发起新的 HTTP 请求。</li>
</ul>
</li>
<li><p><strong>效率较低</strong>:</p>
<ul>
<li>长轮询需要频繁地建立和关闭 HTTP 连接，这在某些场景下可能导致较高的网络开销和延迟。</li>
</ul>
</li>
<li><p><strong>单向请求模式</strong>:</p>
<ul>
<li>尽管长轮询可以较快地将服务器的更新推送到客户端，但它本质上仍然是一种单向请求模式，即服务器不能主动向客户端发送消息，除非客户端首先发送请求。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>:</p>
<ul>
<li>适合对实时性要求不是特别高的应用，或是在不支持 WebSocket 的环境中作为替代方案使用。</li>
</ul>
</li>
</ol>
<p>总结来说，WebSocket 提供了更高效、更适合实时通信的双向连接，而长轮询是一种更简单、在旧浏览器上更容易实现的替代方案。WebSocket 是实现实时应用的首选技术，但在某些场景下，长轮询可能因其简单性和兼容性而被选择。</p>
<h2 id="tcp-如何保证可靠性"><a href="#tcp-如何保证可靠性" class="headerlink" title="tcp 如何保证可靠性"></a>tcp 如何保证可靠性</h2><p>TCP（传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。它通过一系列机制来保证数据传输的可靠性，包括：</p>
<ol>
<li><p><strong>三次握手建立连接</strong>:</p>
<ul>
<li>在传输数据之前，TCP 使用一种被称为“三次握手”的过程来建立连接。这确保了双方都准备好接收和发送数据，并防止了初始化连接时的一些常见的问题。</li>
</ul>
</li>
<li><p><strong>序列号和确认应答</strong>:</p>
<ul>
<li>TCP 给发送的每个数据包分配一个序列号，并要求接收方对每个接收到的数据包发送确认（ACK）。</li>
<li>如果发送方在预定的超时时间内没有收到对特定数据包的确认，它会重新发送该数据包。</li>
</ul>
</li>
<li><p><strong>数据校验和</strong>:</p>
<ul>
<li>每个 TCP 数据包包含一个校验和，以确保数据在传输过程中没有被破坏或更改。</li>
<li>如果接收方检测到数据包损坏（校验和不匹配），它将丢弃该数据包并不发送确认，导致发送方重新发送数据。</li>
</ul>
</li>
<li><p><strong>流量控制</strong>:</p>
<ul>
<li>TCP 使用窗口大小控制来进行流量控制，以避免发送方过快发送数据，导致接收方来不及处理。</li>
<li>接收方通过在确认应答中指定一个“窗口大小”来告诉发送方它还能接收多少数据，从而控制发送方的数据发送速率。</li>
</ul>
</li>
<li><p><strong>拥塞控制</strong>:</p>
<ul>
<li>TCP 还实现了拥塞控制机制，以避免网络中过多的数据包导致网络拥塞。</li>
<li>当网络拥塞时，TCP 会减少其数据传输速率，并在网络状况改善时逐渐增加速率。</li>
</ul>
</li>
<li><p><strong>乱序数据重新排序</strong>:</p>
<ul>
<li>由于网络原因，TCP 数据包可能会乱序到达。TCP 在接收端会根据序列号重新对数据包进行排序，以确保数据的正确顺序。</li>
</ul>
</li>
<li><p><strong>保持活动检测</strong>:</p>
<ul>
<li>TCP 定期发送保持活动包，以检测连接是否仍然有效，防止“死”连接占用资源。</li>
</ul>
</li>
</ol>
<p>通过这些机制，TCP 能够在不可靠的互联网环境中提供可靠的数据传输服务。这些特性使得 TCP 成为了许多需要高可靠性数据传输的应用（如Web页面加载、文件传输、电子邮件等）的理想选择。</p>
<h2 id="拥塞算法"><a href="#拥塞算法" class="headerlink" title="拥塞算法"></a>拥塞算法</h2><p>TCP拥塞控制算法是为了解决和避免网络拥塞问题而设计的一组算法。当多个网络设备尝试同时发送过多数据时，网络拥塞可能发生，导致网络性能下降和数据包丢失。TCP拥塞控制算法的目的是确保每个网络连接获得公平的带宽使用，并减少数据包丢失。下面是一些主要的TCP拥塞控制算法：</p>
<ol>
<li><p><strong>慢启动（Slow Start）</strong>:</p>
<ul>
<li>在TCP连接开始时，慢启动算法被用来探测网络的载荷能力。</li>
<li>慢启动通过逐渐增加拥塞窗口（Congestion Window, cwnd）的大小来增加网络中的数据量，开始时cwnd从一个或几个数据包开始，每收到一个确认响应，cwnd就增加一倍，呈指数增长。</li>
<li>当cwnd达到一个阈值（ssthresh）时，切换到拥塞避免算法。</li>
</ul>
</li>
<li><p><strong>拥塞避免（Congestion Avoidance）</strong>:</p>
<ul>
<li>在拥塞避免阶段，每经过一个往返时间（Round-Trip Time, RTT），cwnd线性增加一个数据包，而不是指数增长。</li>
<li>这个阶段旨在维持网络载荷在一个相对稳定的水平。</li>
</ul>
</li>
<li><p><strong>快重传（Fast Retransmit）</strong>:</p>
<ul>
<li>快重传是指在接收方连续收到三个相同的确认（Triple Duplicate ACKs）时，立即重传丢失的数据包，而不是等待重传计时器到期。</li>
<li>这种机制可以更快地纠正丢包的情况。</li>
</ul>
</li>
<li><p><strong>快恢复（Fast Recovery）</strong>:</p>
<ul>
<li>快恢复算法与快重传一起工作，当检测到丢包（通过三个重复的ACK）时，它会减少cwnd的大小而不是像慢启动时那样将其减至1，通常将cwnd设置为ssthresh的一半。</li>
<li>在快恢复阶段，对于每个接收到的重复ACK，cwnd逐渐增加，直到收到新的数据确认。</li>
</ul>
</li>
<li><p><strong>TCP Tahoe 和 Reno</strong>:</p>
<ul>
<li>TCP Tahoe 和 Reno 是两种实现了上述拥塞控制算法的TCP变体。</li>
<li>Tahoe 使用慢启动、拥塞避免和快重传，但在检测到丢包时，它会将cwnd重置为1。</li>
<li>Reno 则引入了快恢复算法，它在丢包时减少cwnd而不是重置。</li>
</ul>
</li>
<li><p><strong>其他算法</strong>:</p>
<ul>
<li>随着网络技术的发展，出现了更多的拥塞控制算法，如TCP Vegas, TCP BBR（Bottleneck Bandwidth and RTT）等，它们在不同的网络环境和场景中提供了改进的性能。</li>
</ul>
</li>
</ol>
<p>TCP拥塞控制算法的设计旨在使TCP连接能够自适应网络状况的变化，优化网络资源的使用，同时保证网络的稳定性和公平性。随着网络条件的不断变化，这些算法也在不断地进化和优化。</p>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>TCP（传输控制协议）的三次握手（Three-Way Handshake）过程是用于在两个网络实体之间建立一个可靠的连接的关键机制。这个过程不仅用于协商和初始化连接参数，还用于确保双方准备好进行数据传输。下面是三次握手的详细介绍：</p>
<h3 id="第一次握手：SYN"><a href="#第一次握手：SYN" class="headerlink" title="第一次握手：SYN"></a>第一次握手：SYN</h3><ol>
<li><p><strong>发起方发送SYN包</strong>:</p>
<ul>
<li>连接的发起方（客户端）开始握手过程，发送一个包含 SYN（同步序列编号）标志的数据包到接收方（服务器）。</li>
<li>在这个数据包中，发起方选择一个随机的序列号（Seq &#x3D; X），这个序列号在后续数据传输中用于保证数据的有序和完整性。</li>
</ul>
</li>
<li><p><strong>目的</strong>:</p>
<ul>
<li>主要是向接收方表明发起方希望建立连接。</li>
</ul>
</li>
</ol>
<h3 id="第二次握手：SYN-ACK"><a href="#第二次握手：SYN-ACK" class="headerlink" title="第二次握手：SYN-ACK"></a>第二次握手：SYN-ACK</h3><ol>
<li><p><strong>接收方响应SYN-ACK包</strong>:</p>
<ul>
<li>接收方收到 SYN 包后，需要确认这个请求。它发送一个包含 SYN 和 ACK（确认响应）标志的数据包。</li>
<li>这个数据包中的确认号（Ack &#x3D; X + 1）是对发起方 SYN 包中序列号的确认，同时接收方也选择自己的一个随机序列号（Seq &#x3D; Y）。</li>
</ul>
</li>
<li><p><strong>目的</strong>:</p>
<ul>
<li>确认发起方的 SYN，并且通知发起方接收方也准备好建立连接。</li>
</ul>
</li>
</ol>
<h3 id="第三次握手：ACK"><a href="#第三次握手：ACK" class="headerlink" title="第三次握手：ACK"></a>第三次握手：ACK</h3><ol>
<li><p><strong>发起方发送ACK包</strong>:</p>
<ul>
<li>发起方收到 SYN-ACK 包后，发送一个包含 ACK 标志的数据包，这个包的确认号被设置为接收方的序列号加一（Ack &#x3D; Y + 1）。</li>
<li>这一步完成了对接收方初始序列号的确认。</li>
</ul>
</li>
<li><p><strong>连接建立</strong>:</p>
<ul>
<li>一旦接收方收到这个 ACK 包，连接就被认为是建立了。现在，双方都已确认彼此的初始序列号，并且都准备好进行数据传输。</li>
</ul>
</li>
</ol>
<h3 id="为什么需要三次握手？"><a href="#为什么需要三次握手？" class="headerlink" title="为什么需要三次握手？"></a>为什么需要三次握手？</h3><p>三次握手的设计是为了确保双方都能确认对方的接收和发送能力。它主要解决了以下几个问题：</p>
<ul>
<li>确保双方都知道对方准备好发送和接收数据。</li>
<li>避免旧的延迟连接初始化请求突然建立连接。</li>
<li>确保在连接开始时双方的序列号被正确初始化和同步。</li>
</ul>
<p>这个过程是建立一个可靠的 TCP 连接的基础，确保了数据传输的可靠性和顺序性。</p>
<h2 id="http-和-tcp-的-keep-alive-区别"><a href="#http-和-tcp-的-keep-alive-区别" class="headerlink" title="http 和 tcp 的 keep-alive 区别"></a>http 和 tcp 的 keep-alive 区别</h2><p>HTTP Keep-Alive 和 TCP Keep-Alive 是两种不同层次上的保持连接活跃的机制，它们的目的和实现方式有所不同：</p>
<h3 id="HTTP-Keep-Alive"><a href="#HTTP-Keep-Alive" class="headerlink" title="HTTP Keep-Alive"></a>HTTP Keep-Alive</h3><ol>
<li><p><strong>层次</strong>:</p>
<ul>
<li>HTTP Keep-Alive 工作在应用层，是 HTTP 协议的一部分。</li>
</ul>
</li>
<li><p><strong>目的</strong>:</p>
<ul>
<li>HTTP Keep-Alive 的主要目的是减少建立和关闭连接的频繁操作，提高 HTTP 传输效率。</li>
<li>它允许在一个 TCP 连接上发送和接收多个 HTTP 请求&#x2F;响应，而不需要为每个请求&#x2F;响应对重新建立新的 TCP 连接。</li>
</ul>
</li>
<li><p><strong>实现</strong>:</p>
<ul>
<li>在 HTTP 1.1 中，默认开启 Keep-Alive。</li>
<li>客户端和服务器在 HTTP 头部信息中通过 <code>Connection: keep-alive</code> 来通告对方它们希望保持连接打开。</li>
<li>连接会保持活跃直到客户端或服务器决定关闭，或者超过预定的超时时间。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>:</p>
<ul>
<li>HTTP Keep-Alive 特别适用于需要多个连续的 HTTP 请求&#x2F;响应的场景，如网页加载中包含多个资源（CSS、JavaScript、图片等）的情况。</li>
</ul>
</li>
</ol>
<h3 id="TCP-Keep-Alive"><a href="#TCP-Keep-Alive" class="headerlink" title="TCP Keep-Alive"></a>TCP Keep-Alive</h3><ol>
<li><p><strong>层次</strong>:</p>
<ul>
<li>TCP Keep-Alive 工作在传输层，是 TCP 协议的一部分。</li>
</ul>
</li>
<li><p><strong>目的</strong>:</p>
<ul>
<li>TCP Keep-Alive 的目的是检测死亡连接（即长时间无数据交换的连接），确保连接的双方仍然可达。</li>
<li>它用于维护和监控 TCP 连接的状态。</li>
</ul>
</li>
<li><p><strong>实现</strong>:</p>
<ul>
<li>TCP Keep-Alive 通过定期发送探测数据包来实现。如果在一定次数的探测后仍然没有收到响应，则认为连接已经断开，并关闭连接。</li>
<li>这个机制在某些操作系统中默认关闭，并且探测间隔和次数可以配置。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>:</p>
<ul>
<li>TCP Keep-Alive 适用于任何基于 TCP 的网络服务，特别是那些可能长时间空闲但需要保持连接的场景，如数据库连接。</li>
</ul>
</li>
</ol>
<h3 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h3><ul>
<li><strong>层次不同</strong>：HTTP Keep-Alive 是应用层协议，TCP Keep-Alive 是传输层协议。</li>
<li><strong>目的不同</strong>：HTTP Keep-Alive 用于提高 HTTP 效率，减少连接重建的开销；而 TCP Keep-Alive 用于检测和维护连接的活跃状态。</li>
<li><strong>适用范围</strong>：HTTP Keep-Alive 仅用于 HTTP 协议，而 TCP Keep-Alive 适用于所有基于 TCP 的通信。</li>
<li><strong>工作方式</strong>：HTTP Keep-Alive 通过重用连接进行多个请求&#x2F;响应交换，TCP Keep-Alive 通过发送探测数据包来检测连接状态。</li>
</ul>
<h2 id="js-闭包、原型、事件循环"><a href="#js-闭包、原型、事件循环" class="headerlink" title="js 闭包、原型、事件循环"></a>js 闭包、原型、事件循环</h2><h3 id="闭包（Closure）"><a href="#闭包（Closure）" class="headerlink" title="闭包（Closure）"></a>闭包（Closure）</h3><p>闭包是 JavaScript 中一个非常重要的特性，它允许一个函数访问并操作该函数外部的变量。</p>
<ol>
<li><p><strong>定义</strong>: 在 JavaScript 中，当一个函数嵌套在另一个函数内，并引用外层函数的变量时，就形成了闭包。</p>
</li>
<li><p><strong>作用</strong>:</p>
<ul>
<li><strong>访问外部函数的变量</strong>: 内部函数可以访问定义在外部函数中的变量，即使外部函数已经执行完毕。</li>
<li><strong>数据封装和私有性</strong>: 闭包可以用来创建私有变量，提供类似于面向对象编程中的封装和隐藏数据的功能。</li>
</ul>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> secret = <span class="string">&quot;I&#x27;m a secret!&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">innerFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(secret);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getSecret = <span class="title function_">outerFunction</span>();</span><br><span class="line"><span class="title function_">getSecret</span>(); <span class="comment">// 输出 &quot;I&#x27;m a secret!&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="原型（Prototype）"><a href="#原型（Prototype）" class="headerlink" title="原型（Prototype）"></a>原型（Prototype）</h3><p>原型是 JavaScript 中实现继承和共享属性或方法的一种机制。</p>
<ol>
<li><p><strong>原型对象</strong>: 每个 JavaScript 对象都有一个原型对象（<code>prototype</code>），对象从其原型继承属性和方法。</p>
</li>
<li><p><strong>原型链</strong>: 当访问一个对象的属性或方法时，如果该对象自身不包含这个属性或方法，JavaScript 会沿着原型链向上查找，直到找到或到达原型链的顶端（<code>Object.prototype</code>）。</p>
</li>
<li><p><strong>使用</strong>:</p>
<ul>
<li>常用于创建具有相似属性和方法的多个对象，提高代码复用性。</li>
<li>原型链是 JavaScript 中实现继承的基础。</li>
</ul>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">person1.<span class="title function_">sayHello</span>(); <span class="comment">// 输出 &quot;Hello, my name is Alice&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="事件循环（Event-Loop）"><a href="#事件循环（Event-Loop）" class="headerlink" title="事件循环（Event Loop）"></a>事件循环（Event Loop）</h3><p>事件循环是 JavaScript 中处理异步操作和保持单线程运行的机制。</p>
<ol>
<li><p><strong>单线程和异步</strong>: JavaScript 是单线程语言，但支持异步编程（例如，通过回调函数、Promises、async&#x2F;await）。</p>
</li>
<li><p><strong>任务类型</strong>:</p>
<ul>
<li><strong>宏任务（Macro Task）</strong>: 如 <code>setTimeout</code>, <code>setInterval</code>, I&#x2F;O 操作。</li>
<li><strong>微任务（Micro Task）</strong>: 如 Promise 回调、<code>process.nextTick</code>（在 Node.js 中）。</li>
</ul>
</li>
<li><p><strong>工作机制</strong>:</p>
<ul>
<li>事件循环不断检查是否有待执行的任务。</li>
<li>如果执行栈为空，事件循环会查看任务队列。如果队列中有宏任务，从队列中取出一个执行。</li>
<li>在每个宏任务执行之后，事件循环会处理所有的微任务队列，之后再执行下一个宏任务。</li>
<li>这个循环持续进行，直到所有任务完成。</li>
</ul>
</li>
<li><p><strong>示例</strong>:</p>
<ul>
<li>异步操作（如通过 <code>setTimeout</code> 设置的定时器）不会立即执行，而是被加入队列，在当前和其他微任务执行完毕后再执行。</li>
</ul>
</li>
</ol>
<h2 id="webpack-与-vite"><a href="#webpack-与-vite" class="headerlink" title="webpack 与 vite"></a>webpack 与 vite</h2><p>Webpack 和 Vite 是两种流行的前端构建工具，它们用于优化开发和生产环境下的前端项目。虽然两者的目标相似，但它们在实现方式和性能上有明显的区别：</p>
<h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><ol>
<li><p><strong>概念</strong>:</p>
<ul>
<li>Webpack 是一个模块打包器（bundler），主要用于 JavaScript 和相关资源文件（如 CSS、图片）的模块化构建和打包。</li>
</ul>
</li>
<li><p><strong>工作原理</strong>:</p>
<ul>
<li>Webpack 通过一个入口点开始，分析项目中的模块和资源依赖，将这些资源转换和打包成少数几个文件，通常用于生产环境。</li>
</ul>
</li>
<li><p><strong>特点</strong>:</p>
<ul>
<li><strong>灵活性和配置性</strong>：Webpack 提供了广泛的插件系统和配置选项，适用于复杂的项目需求。</li>
<li><strong>热模块替换（HMR）</strong>：在开发环境中，Webpack 支持热模块替换，允许应用在运行时更新模块而无需完全刷新。</li>
<li><strong>慢启动</strong>：由于需要分析整个项目的依赖和资源，Webpack 的启动和热更新可能比较慢。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>:</p>
<ul>
<li>适用于需要复杂配置和高度定制化构建流程的大型项目。</li>
</ul>
</li>
</ol>
<h3 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h3><ol>
<li><p><strong>概念</strong>:</p>
<ul>
<li>Vite 是一个更现代的前端构建工具，利用了最新的前端技术，如原生 ES 模块加载。</li>
</ul>
</li>
<li><p><strong>工作原理</strong>:</p>
<ul>
<li>在开发环境中，Vite 作为一个服务器运行，它利用浏览器原生的 ES 模块导入功能来服务模块请求。</li>
<li>在生产环境中，Vite 使用 Rollup 进行高效的打包。</li>
</ul>
</li>
<li><p><strong>特点</strong>:</p>
<ul>
<li><strong>快速启动</strong>：由于使用了原生 ES 模块，Vite 在开发环境中可以快速启动，无需等待打包过程。</li>
<li><strong>按需编译</strong>：Vite 只编译当前请求的模块，而不是整个应用，这使得热更新非常快。</li>
<li><strong>简化配置</strong>：Vite 设计理念倾向于减少配置，提供更简洁的开发体验。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>:</p>
<ul>
<li>适用于新项目，尤其是在追求快速开发和简化构建配置的场景下。</li>
</ul>
</li>
</ol>
<h3 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h3><ul>
<li><strong>启动速度</strong>：Vite 在开发环境中的启动速度通常比 Webpack 快，因为它不需要预先打包整个应用。</li>
<li><strong>热更新速度</strong>：Vite 的热更新通常比 Webpack 快，因为它只编译变更的模块。</li>
<li><strong>构建原理</strong>：Webpack 是一个传统的模块打包器，而 Vite 利用了现代浏览器的原生 ES 模块特性。</li>
<li><strong>兼容性</strong>：Webpack 支持更广泛的模块格式和浏览器兼容性，而 Vite 主要针对现代浏览器。</li>
<li><strong>配置复杂性</strong>：Webpack 的配置通常更复杂，而 Vite 旨在提供更简洁的配置。</li>
</ul>
<h2 id="vue2-和-vue3"><a href="#vue2-和-vue3" class="headerlink" title="vue2 和 vue3"></a>vue2 和 vue3</h2><p>Vue.js 是一个流行的 JavaScript 框架，用于构建用户界面和单页应用程序。Vue 3 是 Vue.js 的最新主要版本，相比于 Vue 2，它引入了许多新特性和改进。以下是 Vue 2 和 Vue 3 之间的主要区别：</p>
<h3 id="性能改进"><a href="#性能改进" class="headerlink" title="性能改进"></a>性能改进</h3><ol>
<li><p><strong>更快的虚拟 DOM</strong>:</p>
<ul>
<li>Vue 3 引入了一个全新的虚拟 DOM 实现，优化了渲染速度和内存消耗。</li>
</ul>
</li>
<li><p><strong>编译优化</strong>:</p>
<ul>
<li>Vue 3 的编译器进行了重写，提供了更好的编译优化，减少了运行时的开销。</li>
</ul>
</li>
<li><p><strong>树摇动（Tree-shaking）</strong>:</p>
<ul>
<li>Vue 3 支持树摇动，意味着在最终打包时可以去除未使用的代码，减小应用体积。</li>
</ul>
</li>
</ol>
<h3 id="组合式-API"><a href="#组合式-API" class="headerlink" title="组合式 API"></a>组合式 API</h3><p>Vue 3 引入了 Composition API（组合式 API），这是 Vue 3 最显著的新特性之一。</p>
<ol>
<li><p><strong>更好的逻辑复用和组织</strong>:</p>
<ul>
<li>Composition API 允许开发者更灵活地组织组件逻辑，特别是在处理复杂组件时。</li>
<li>使用 <code>setup</code> 函数和一系列新的 API（如 <code>ref</code>, <code>reactive</code>, <code>computed</code>, <code>watch</code> 等），可以更好地封装和重用逻辑。</li>
</ul>
</li>
<li><p><strong>与 Options API 的共存</strong>:</p>
<ul>
<li>Vue 3 依然支持 Vue 2 中的 Options API，两种风格可以共存。</li>
</ul>
</li>
</ol>
<h3 id="更好的-TypeScript-支持"><a href="#更好的-TypeScript-支持" class="headerlink" title="更好的 TypeScript 支持"></a>更好的 TypeScript 支持</h3><ul>
<li>Vue 3 从一开始就考虑到了 TypeScript 的支持，其代码基于 TypeScript 编写，提供了更好的类型推断和集成。</li>
</ul>
<h3 id="其他新特性和改进"><a href="#其他新特性和改进" class="headerlink" title="其他新特性和改进"></a>其他新特性和改进</h3><ol>
<li><p><strong>组合式 API</strong>:</p>
<ul>
<li>引入了更灵活的组合式 API，为组件逻辑提供了更强的组织能力。</li>
</ul>
</li>
<li><p><strong>更小的体积</strong>:</p>
<ul>
<li>Vue 3 的体积比 Vue 2 更小，主要得益于树摇动。</li>
</ul>
</li>
<li><p><strong>多根节点组件</strong>:</p>
<ul>
<li>Vue 3 允许组件有多个根节点，而 Vue 2 中每个组件只能有一个根节点。</li>
</ul>
</li>
<li><p><strong>响应式系统的重写</strong>:</p>
<ul>
<li>Vue 3 的响应式系统基于 Proxy API 重写，提供了更好的性能和兼容性。</li>
</ul>
</li>
<li><p><strong>全新的生命周期钩子</strong>:</p>
<ul>
<li>引入了新的生命周期钩子，如 <code>onMounted</code>, <code>onUpdated</code> 等。</li>
</ul>
</li>
<li><p><strong>Fragment, Teleport, Suspense</strong>:</p>
<ul>
<li>引入了新的内置组件，如 Fragment（允许多个根节点），Teleport（允许将子节点传送到 DOM 树的其他位置），Suspense（用于异步组件的数据获取和渲染）。</li>
</ul>
</li>
</ol>
<h3 id="兼容性和迁移"><a href="#兼容性和迁移" class="headerlink" title="兼容性和迁移"></a>兼容性和迁移</h3><ul>
<li>Vue 3 考虑到了向后兼容性，提供了从 Vue 2 迁移到 Vue 3 的工具和指南。</li>
</ul>
<h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><ol>
<li><p><strong>事件循环</strong>:</p>
<ul>
<li>Node.js 运行时基于事件循环。事件循环负责处理异步回调，如 I&#x2F;O 操作、计时器、网络请求等。</li>
</ul>
</li>
<li><p><strong>微任务队列</strong>:</p>
<ul>
<li><code>process.nextTick</code> 将回调函数放入微任务队列。这个队列在事件循环的每个阶段之间执行，甚至在事件循环的当前阶段完成之前。</li>
</ul>
</li>
<li><p><strong>优先级</strong>:</p>
<ul>
<li>通过 <code>process.nextTick</code> 调度的任务比通过 <code>setImmediate</code> 或 <code>setTimeout</code>、<code>setInterval</code> 调度的任务优先级更高。这意味着 <code>nextTick</code> 回调在任何 I&#x2F;O 事件（包括定时器）之前执行。</li>
</ul>
</li>
</ol>
<h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><ul>
<li>当调用 <code>process.nextTick</code> 时，传入的回调函数不会立即执行。而是在当前操作完成后、事件循环继续进行之前执行。</li>
<li>这意味着即使在 I&#x2F;O 操作或定时器触发之前，所有通过 <code>nextTick</code> 排队的回调都会首先执行。</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><p><strong>错误处理</strong>:</p>
<ul>
<li><code>process.nextTick</code> 经常用于异步 API 中的错误处理。这是因为它允许在堆栈被解构之前抛出异常，从而可以捕获和处理错误。</li>
</ul>
</li>
<li><p><strong>确保异步性</strong>:</p>
<ul>
<li>有时候，你可能需要确保代码总是以异步方式运行，即使是在同步代码块中。<code>process.nextTick</code> 可以用于确保回调总是异步调用，从而避免了同步操作和异步操作之间的潜在问题。</li>
</ul>
</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始&#x27;</span>);</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextTick 回调&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;计划的 nextTick&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，输出将会是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开始</span><br><span class="line">计划的 nextTick</span><br><span class="line">nextTick 回调</span><br></pre></td></tr></table></figure>

<p>即使 <code>process.nextTick</code> 的回调是在最后一行调用的，它仍然在当前事件循环的末尾执行，即在任何其他的 I&#x2F;O 事件或计时器之前执行。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>使用 <code>process.nextTick</code> 可能导致 I&#x2F;O 饿死，因为如果不断地添加 <code>nextTick</code> 回调，那么 I&#x2F;O 事件可能永远无法被处理。因此，适当地使用 <code>nextTick</code> 是非常重要的。</li>
<li>对于绝大多数场景，<code>setImmediate</code> 是处理异步操作的更好选择，因为它更加公平地对待事件循环中的所有类型的事件。</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/wechat.png" alt="moke 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202309041556302.jpg" alt="moke 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>moke
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://csumoke.com/2023/12/07/notes/" title="前端实习面试问题准备">https://csumoke.com/2023/12/07/notes/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
            </div>
            <div class="post-nav-item">
                <a href="/2023/10/26/vscode-PR/" rel="next" title="VSCode 下的 PR 流程">
                  VSCode 下的 PR 流程 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">moke</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">22k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">1:21</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9taXN0Lw==">NexT.Mist</span> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL2plcnJ5NzY1" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.0/jquery.min.js" integrity="sha256-2Pmvv0kuTBOenSvLm6bvfBSSHrUJ+3A7x6P5Ebd07/g=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>



  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":false,"archive":false,"delay":true,"timeout":3000,"priority":true,"url":"https://csumoke.com/2023/12/07/notes/"}</script>
  <script src="/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"csumoke","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

<script>(function (w, d, s, id) {
            if (typeof (w.webpushr) !== 'undefined') return; w.webpushr = w.webpushr || function () { (w.webpushr.q = w.webpushr.q || []).push(arguments) }; var js, fjs = d.getElementsByTagName(s)[0]; js = d.createElement(s); js.id = id; js.async = 1; js.src = "https://cdn.webpushr.com/app.min.js";fjs.parentNode.appendChild(js);}(window, document, 'script', 'webpushr-jssdk'));webpushr('setup', { 'key': 'BAs1f6Lvs7ZICIjDSN6zmGgXIS0HES-FCnkp3hYWJ0mxRWyJ0KbPvK_ggwuXiBcOu2JyKyfTjf5XuSIMCHShK_w' });</script></body>
</html>
