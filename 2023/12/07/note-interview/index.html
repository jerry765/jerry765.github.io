<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"csumoke.com","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.17.1","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"bookmark":{"enable":true,"color":"#0080ff","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":true,"nav":null,"activeClass":"disqus"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>



<link rel="canonical" href="https://csumoke.com/2023/12/07/note-interview/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://csumoke.com/2023/12/07/note-interview/","path":"2023/12/07/note-interview/","title":"前端实习面试问题准备"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>前端实习面试问题准备 | Voilà</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-GC00V96X32"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-GC00V96X32","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Voilà</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">moke's blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Node-js-%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E4%B8%8D%E4%B8%AD%E6%96%AD%EF%BC%9F"><span class="nav-number">1.1.</span> <span class="nav-text">Node.js 单线程如何保证线程不中断？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">1.2.</span> <span class="nav-text">TCP 三次握手与四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%88%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E8%BF%87%E7%A8%8B%EF%BC%89"><span class="nav-number">1.2.1.</span> <span class="nav-text">TCP三次握手（连接建立过程）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%88%E8%BF%9E%E6%8E%A5%E9%87%8A%E6%94%BE%E8%BF%87%E7%A8%8B%EF%BC%89"><span class="nav-number">1.2.2.</span> <span class="nav-text">TCP四次挥手（连接释放过程）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E5%8F%AF%E9%9D%A0%E7%9A%84-UDP-%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.3.</span> <span class="nav-text">建立可靠的 UDP 连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#websocket-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">1.4.</span> <span class="nav-text">websocket 建立连接的过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#websocket%E5%92%8C%E9%95%BF%E8%BD%AE%E8%AF%A2%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.5.</span> <span class="nav-text">websocket和长轮询的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#WebSocket"><span class="nav-number">1.5.1.</span> <span class="nav-text">WebSocket</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%95%BF%E8%BD%AE%E8%AF%A2"><span class="nav-number">1.5.2.</span> <span class="nav-text">长轮询</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="nav-number">1.6.</span> <span class="nav-text">tcp 如何保证可靠性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E7%AE%97%E6%B3%95"><span class="nav-number">1.7.</span> <span class="nav-text">拥塞算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">1.8.</span> <span class="nav-text">三次握手</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9ASYN"><span class="nav-number">1.8.1.</span> <span class="nav-text">第一次握手：SYN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9ASYN-ACK"><span class="nav-number">1.8.2.</span> <span class="nav-text">第二次握手：SYN-ACK</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9AACK"><span class="nav-number">1.8.3.</span> <span class="nav-text">第三次握手：ACK</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F"><span class="nav-number">1.8.4.</span> <span class="nav-text">为什么需要三次握手？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http-%E5%92%8C-tcp-%E7%9A%84-keep-alive-%E5%8C%BA%E5%88%AB"><span class="nav-number">1.9.</span> <span class="nav-text">http 和 tcp 的 keep-alive 区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-Keep-Alive"><span class="nav-number">1.9.1.</span> <span class="nav-text">HTTP Keep-Alive</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-Keep-Alive"><span class="nav-number">1.9.2.</span> <span class="nav-text">TCP Keep-Alive</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93"><span class="nav-number">1.9.3.</span> <span class="nav-text">区别总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#js-%E9%97%AD%E5%8C%85%E3%80%81%E5%8E%9F%E5%9E%8B%E3%80%81%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.10.</span> <span class="nav-text">js 闭包、原型、事件循环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AD%E5%8C%85%EF%BC%88Closure%EF%BC%89"><span class="nav-number">1.10.1.</span> <span class="nav-text">闭包（Closure）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%EF%BC%88Prototype%EF%BC%89"><span class="nav-number">1.10.2.</span> <span class="nav-text">原型（Prototype）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88Event-Loop%EF%BC%89"><span class="nav-number">1.10.3.</span> <span class="nav-text">事件循环（Event Loop）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#webpack-%E4%B8%8E-vite"><span class="nav-number">1.11.</span> <span class="nav-text">webpack 与 vite</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Webpack"><span class="nav-number">1.11.1.</span> <span class="nav-text">Webpack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vite"><span class="nav-number">1.11.2.</span> <span class="nav-text">Vite</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB"><span class="nav-number">1.11.3.</span> <span class="nav-text">主要区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue2-%E5%92%8C-vue3"><span class="nav-number">1.12.</span> <span class="nav-text">vue2 和 vue3</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E6%94%B9%E8%BF%9B"><span class="nav-number">1.12.1.</span> <span class="nav-text">性能改进</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E5%BC%8F-API"><span class="nav-number">1.12.2.</span> <span class="nav-text">组合式 API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E5%A5%BD%E7%9A%84-TypeScript-%E6%94%AF%E6%8C%81"><span class="nav-number">1.12.3.</span> <span class="nav-text">更好的 TypeScript 支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%96%B0%E7%89%B9%E6%80%A7%E5%92%8C%E6%94%B9%E8%BF%9B"><span class="nav-number">1.12.4.</span> <span class="nav-text">其他新特性和改进</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%BC%E5%AE%B9%E6%80%A7%E5%92%8C%E8%BF%81%E7%A7%BB"><span class="nav-number">1.12.5.</span> <span class="nav-text">兼容性和迁移</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nextTick"><span class="nav-number">1.13.</span> <span class="nav-text">nextTick</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">1.13.1.</span> <span class="nav-text">基本原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="nav-number">1.13.2.</span> <span class="nav-text">工作机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.13.3.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.13.4.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.13.5.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#javascript-%E5%92%8C-typescript"><span class="nav-number">1.14.</span> <span class="nav-text">javascript 和 typescript</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript"><span class="nav-number">1.14.1.</span> <span class="nav-text">JavaScript</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TypeScript"><span class="nav-number">1.14.2.</span> <span class="nav-text">TypeScript</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB-1"><span class="nav-number">1.14.3.</span> <span class="nav-text">主要区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A"><span class="nav-number">1.15.</span> <span class="nav-text">Vue 双向绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.15.1.</span> <span class="nav-text">响应式系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#v-model-%E6%8C%87%E4%BB%A4"><span class="nav-number">1.15.2.</span> <span class="nav-text">v-model 指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">1.15.3.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F"><span class="nav-number">1.15.4.</span> <span class="nav-text">注意</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cookie-Session-localStorage"><span class="nav-number">1.16.</span> <span class="nav-text">Cookie Session localStorage</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Cookie"><span class="nav-number">1.16.1.</span> <span class="nav-text">Cookie</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Session"><span class="nav-number">1.16.2.</span> <span class="nav-text">Session</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#localStorage"><span class="nav-number">1.16.3.</span> <span class="nav-text">localStorage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%94%E8%BE%83"><span class="nav-number">1.16.4.</span> <span class="nav-text">比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="nav-number">1.17.</span> <span class="nav-text">跨域问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%EF%BC%9F"><span class="nav-number">1.17.1.</span> <span class="nav-text">什么是跨域？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">1.17.2.</span> <span class="nav-text">常见的解决方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.17.3.</span> <span class="nav-text">选择合适的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#XSS-%E6%94%BB%E5%87%BB"><span class="nav-number">1.18.</span> <span class="nav-text">XSS 攻击</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#XSS-%E6%94%BB%E5%87%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.18.1.</span> <span class="nav-text">XSS 攻击是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83-XSS-%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="nav-number">1.18.2.</span> <span class="nav-text">如何防范 XSS 攻击？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#git-flow"><span class="nav-number">1.19.</span> <span class="nav-text">git flow</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E5%88%86%E6%94%AF"><span class="nav-number">1.19.1.</span> <span class="nav-text">主要分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%85%E5%8A%A9%E5%88%86%E6%94%AF"><span class="nav-number">1.19.2.</span> <span class="nav-text">辅助分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.19.3.</span> <span class="nav-text">工作流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9%E4%B8%8E%E7%BC%BA%E7%82%B9"><span class="nav-number">1.19.4.</span> <span class="nav-text">优点与缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB"><span class="nav-number">1.20.</span> <span class="nav-text">中间人攻击</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB"><span class="nav-number">1.20.1.</span> <span class="nav-text">如何进行中间人攻击</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.20.2.</span> <span class="nav-text">常见的中间人攻击类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB"><span class="nav-number">1.20.3.</span> <span class="nav-text">如何防范中间人攻击</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95-SSO"><span class="nav-number">1.21.</span> <span class="nav-text">单点登录 SSO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%EF%BC%88SSO%EF%BC%89%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.21.1.</span> <span class="nav-text">单点登录（SSO）的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SSO-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.21.2.</span> <span class="nav-text">SSO 的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SSO-%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-number">1.21.3.</span> <span class="nav-text">SSO 的流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SSO-%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E6%8C%91%E6%88%98"><span class="nav-number">1.21.4.</span> <span class="nav-text">SSO 的优势和挑战</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TypeScript-interface-type"><span class="nav-number">1.22.</span> <span class="nav-text">TypeScript interface type</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E5%92%8C%E5%8A%9F%E8%83%BD"><span class="nav-number">1.22.1.</span> <span class="nav-text">语法和功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-number">1.22.2.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E8%80%83%E8%99%91"><span class="nav-number">1.22.3.</span> <span class="nav-text">性能考虑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%BC%E5%AE%B9%E6%80%A7%E5%92%8C%E6%89%A9%E5%B1%95%E6%80%A7"><span class="nav-number">1.22.4.</span> <span class="nav-text">兼容性和扩展性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%82%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84"><span class="nav-number">1.23.</span> <span class="nav-text">函数入参实现类型映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B"><span class="nav-number">1.23.1.</span> <span class="nav-text">1. 使用泛型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.23.2.</span> <span class="nav-text">2. 条件类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.23.3.</span> <span class="nav-text">3. 映射类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA"><span class="nav-number">1.23.4.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTPS-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.24.</span> <span class="nav-text">HTTPS 工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%8A%A0%E5%AF%86"><span class="nav-number">1.24.1.</span> <span class="nav-text">1. 加密</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-SSL-x2F-TLS-%E6%8F%A1%E6%89%8B"><span class="nav-number">1.24.2.</span> <span class="nav-text">2. SSL&#x2F;TLS 握手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%AE%89%E5%85%A8%E9%80%9A%E4%BF%A1"><span class="nav-number">1.24.3.</span> <span class="nav-text">3. 安全通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E4%BC%9A%E8%AF%9D%E7%BB%93%E6%9D%9F"><span class="nav-number">1.24.4.</span> <span class="nav-text">4. 会话结束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.24.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AB%AF%E5%8F%A3"><span class="nav-number">1.25.</span> <span class="nav-text">端口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AB%AF%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.25.1.</span> <span class="nav-text">端口的作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ESLint-Prettier-Husky-Lint-Staged"><span class="nav-number">1.26.</span> <span class="nav-text">ESLint Prettier Husky Lint-Staged</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-ESLint"><span class="nav-number">1.26.1.</span> <span class="nav-text">1. ESLint</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Prettier"><span class="nav-number">1.26.2.</span> <span class="nav-text">2. Prettier</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Husky"><span class="nav-number">1.26.3.</span> <span class="nav-text">3. Husky</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Lint-Staged"><span class="nav-number">1.26.4.</span> <span class="nav-text">4. Lint-Staged</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8"><span class="nav-number">1.26.5.</span> <span class="nav-text">组合使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81"><span class="nav-number">2.</span> <span class="nav-text">代码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">2.1.</span> <span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%B2%E6%8A%96%EF%BC%88Debouncing%EF%BC%89"><span class="nav-number">2.2.</span> <span class="nav-text">防抖（Debouncing）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#js%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%92%8C%E5%88%A9%E7%94%A8%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%AE%9E%E7%8E%B0%E9%9B%86%E6%88%90"><span class="nav-number">2.3.</span> <span class="nav-text">js原型链和利用原型链实现集成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript%E7%9A%84%E5%8E%9F%E5%9E%8B"><span class="nav-number">2.3.1.</span> <span class="nav-text">JavaScript的原型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="nav-number">2.3.2.</span> <span class="nav-text">原型链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF"><span class="nav-number">2.3.3.</span> <span class="nav-text">实现继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-amp-amp-TCP"><span class="nav-number">2.4.</span> <span class="nav-text">HTTP &amp;&amp; TCP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%EF%BC%88%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE%EF%BC%89"><span class="nav-number">2.4.1.</span> <span class="nav-text">TCP（传输控制协议）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%EF%BC%88%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%EF%BC%89"><span class="nav-number">2.4.2.</span> <span class="nav-text">HTTP（超文本传输协议）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="nav-number">2.4.3.</span> <span class="nav-text">关系和区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTPS"><span class="nav-number">2.5.</span> <span class="nav-text">HTTPS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AE%89%E5%85%A8"><span class="nav-number">2.5.1.</span> <span class="nav-text">HTTPS如何实现安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">2.5.2.</span> <span class="nav-text">HTTPS的工作流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF"><span class="nav-number">2.6.</span> <span class="nav-text">前端缓存技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E7%BC%93%E5%AD%98"><span class="nav-number">2.6.1.</span> <span class="nav-text">HTTP缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8"><span class="nav-number">2.6.2.</span> <span class="nav-text">浏览器存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5"><span class="nav-number">2.6.3.</span> <span class="nav-text">缓存策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F-dom"><span class="nav-number">2.7.</span> <span class="nav-text">虚拟 dom</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">2.7.1.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8A%BF"><span class="nav-number">2.7.2.</span> <span class="nav-text">优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.7.3.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MVC-MVVM"><span class="nav-number">2.8.</span> <span class="nav-text">MVC MVVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#React%E4%B8%8EMVC%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.8.1.</span> <span class="nav-text">React与MVC模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue%E4%B8%8EMVVM%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.8.2.</span> <span class="nav-text">Vue与MVVM模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%94%E8%BE%83-1"><span class="nav-number">2.8.3.</span> <span class="nav-text">比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%92%8C%E8%B7%A8%E5%9F%9F"><span class="nav-number">2.9.</span> <span class="nav-text">同源策略和跨域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="nav-number">2.9.1.</span> <span class="nav-text">为什么要有同源策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%A8%E5%9F%9F"><span class="nav-number">2.9.2.</span> <span class="nav-text">跨域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">2.9.3.</span> <span class="nav-text">跨域解决方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue3-computed-%E5%92%8C-watch"><span class="nav-number">2.10.</span> <span class="nav-text">vue3 computed 和 watch</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#computed"><span class="nav-number">2.10.1.</span> <span class="nav-text">computed</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#watch"><span class="nav-number">2.10.2.</span> <span class="nav-text">watch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB-2"><span class="nav-number">2.10.3.</span> <span class="nav-text">主要区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">2.11.</span> <span class="nav-text">Vue3 生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%82%E8%BD%BD%E9%98%B6%E6%AE%B5"><span class="nav-number">2.11.1.</span> <span class="nav-text">挂载阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E9%98%B6%E6%AE%B5"><span class="nav-number">2.11.2.</span> <span class="nav-text">更新阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%B8%E8%BD%BD%E9%98%B6%E6%AE%B5"><span class="nav-number">2.11.3.</span> <span class="nav-text">卸载阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">2.11.4.</span> <span class="nav-text">其他</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Composition-API%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90"><span class="nav-number">2.11.5.</span> <span class="nav-text">Composition API生命周期钩子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-Diff-%E7%AE%97%E6%B3%95"><span class="nav-number">2.12.</span> <span class="nav-text">Vue Diff 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.12.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#React%E4%B8%AD%E7%9A%84Diff%E7%AE%97%E6%B3%95"><span class="nav-number">2.12.2.</span> <span class="nav-text">React中的Diff算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue%E4%B8%AD%E7%9A%84Diff%E7%AE%97%E6%B3%95"><span class="nav-number">2.12.3.</span> <span class="nav-text">Vue中的Diff算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="nav-number">2.12.4.</span> <span class="nav-text">实现细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-%E7%89%88%E6%9C%AC"><span class="nav-number">2.13.</span> <span class="nav-text">HTTP 版本</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-x2F-0-9"><span class="nav-number">2.13.1.</span> <span class="nav-text">HTTP&#x2F;0.9</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-x2F-1-0"><span class="nav-number">2.13.2.</span> <span class="nav-text">HTTP&#x2F;1.0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-x2F-1-1"><span class="nav-number">2.13.3.</span> <span class="nav-text">HTTP&#x2F;1.1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-x2F-2"><span class="nav-number">2.13.4.</span> <span class="nav-text">HTTP&#x2F;2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-x2F-3"><span class="nav-number">2.13.5.</span> <span class="nav-text">HTTP&#x2F;3</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93"><span class="nav-number">2.14.</span> <span class="nav-text">视频传输</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%86%85%E5%AE%B9%E9%80%82%E9%85%8D%E4%B8%8E%E8%87%AA%E9%80%82%E5%BA%94%E6%B5%81"><span class="nav-number">2.14.1.</span> <span class="nav-text">1. 内容适配与自适应流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">2.14.2.</span> <span class="nav-text">2. 网络性能优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-number">2.14.3.</span> <span class="nav-text">3. 安全性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%85%BC%E5%AE%B9%E6%80%A7%E4%B8%8E%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%94%AF%E6%8C%81"><span class="nav-number">2.14.4.</span> <span class="nav-text">4. 兼容性与跨平台支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C"><span class="nav-number">2.14.5.</span> <span class="nav-text">5. 用户体验</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="nav-number">2.14.6.</span> <span class="nav-text">6. 分析与优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-Loader"><span class="nav-number">2.15.</span> <span class="nav-text">Vue Loader</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7"><span class="nav-number">2.15.1.</span> <span class="nav-text">主要特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-1"><span class="nav-number">2.15.2.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.15.3.</span> <span class="nav-text">配置示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">2.15.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sass"><span class="nav-number">2.16.</span> <span class="nav-text">Sass</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7-1"><span class="nav-number">2.16.1.</span> <span class="nav-text">主要特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Sass"><span class="nav-number">2.16.2.</span> <span class="nav-text">使用Sass</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-number">2.16.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F-x2F-Web-%E9%89%B4%E6%9D%83"><span class="nav-number">2.17.</span> <span class="nav-text">小程序&#x2F; Web 鉴权</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#OpenID"><span class="nav-number">2.17.1.</span> <span class="nav-text">OpenID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JWT%EF%BC%88JSON-Web-Tokens%EF%BC%89"><span class="nav-number">2.17.2.</span> <span class="nav-text">JWT（JSON Web Tokens）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%89%B4%E6%9D%83%E6%B5%81%E7%A8%8B"><span class="nav-number">2.17.3.</span> <span class="nav-text">鉴权流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">2.17.4.</span> <span class="nav-text">安全性注意事项</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="moke"
      src="/images/avatar_kazuha_with_cats.jpg">
  <p class="site-author-name" itemprop="name">moke</p>
  <div class="site-description" itemprop="description">C'est pour cela que je suis née</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2plcnJ5NzY1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jerry765"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOjIwNjE2MTA1NzlAcXEuY29t" title="E-Mail → mailto:2061610579@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/big/by_nc_sa.svg" alt="Creative Commons"></span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <span class="exturl" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMzkxNDM5MDY5" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;391439069">Bilibili</span>
            </li>
        </ul>
      </div>
    </div>
        <div class="pjax">
        </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://csumoke.com/2023/12/07/note-interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar_kazuha_with_cats.jpg">
      <meta itemprop="name" content="moke">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Voilà">
      <meta itemprop="description" content="C'est pour cela que je suis née">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="前端实习面试问题准备 | Voilà">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          前端实习面试问题准备
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-12-07 16:29:16" itemprop="dateCreated datePublished" datetime="2023-12-07T16:29:16+08:00">2023-12-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-15 18:52:54" itemprop="dateModified" datetime="2024-03-15T18:52:54+08:00">2024-03-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/note/" itemprop="url" rel="index"><span itemprop="name">note</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2023/12/07/note-interview/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2023/12/07/note-interview/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>26k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:35</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="Node-js-单线程如何保证线程不中断？"><a href="#Node-js-单线程如何保证线程不中断？" class="headerlink" title="Node.js 单线程如何保证线程不中断？"></a>Node.js 单线程如何保证线程不中断？</h2><p>Node.js 被广泛认为是单线程的，但这个说法需要更准确的解释。Node.js 的主执行线程是单线程的，它运行在 V8 JavaScript 引擎上。然而，Node.js 使用多线程来处理 I&#x2F;O 密集型任务，这是通过其底层的 libuv 库实现的。以下是 Node.js 保证其单线程不中断的几个关键方面：</p>
<ol>
<li><p><strong>异步非阻塞 I&#x2F;O</strong>:</p>
<ul>
<li>Node.js 主要依靠事件循环和回调函数来处理 I&#x2F;O 操作（如文件读写、网络请求等），这些操作是异步和非阻塞的。</li>
<li>当一个 I&#x2F;O 操作开始时，它会被发送到事件循环，并继续执行后续的代码，而不是等待 I&#x2F;O 操作完成。当 I&#x2F;O 操作完成时，相应的回调函数会被放入事件队列中，等待主线程空闲时执行。</li>
</ul>
</li>
<li><p><strong>事件驱动架构</strong>:</p>
<ul>
<li>Node.js 使用事件驱动模型来处理各种异步操作。每当有事件发生时（如数据到达、超时、处理完成），相应的回调函数会被触发。</li>
<li>这种模型使得 Node.js 能够在不被阻塞的情况下高效地处理大量的并发请求。</li>
</ul>
</li>
<li><p><strong>libuv 库</strong>:</p>
<ul>
<li>尽管 JavaScript 代码在单个主线程上运行，Node.js 使用 libuv 库在背后管理一个线程池。</li>
<li>对于一些复杂的操作（如文件系统操作、某些加密操作），libuv 会在后台的多个线程上执行这些任务，而主线程继续执行 JavaScript 代码。</li>
</ul>
</li>
<li><p><strong>错误处理机制</strong>:</p>
<ul>
<li>Node.js 提供了异常处理机制，比如 <code>try-catch</code> 块和全局的 <code>uncaughtException</code> 事件，来处理同步和异步代码中的错误。</li>
<li>正确的错误处理能够防止异常导致主线程崩溃。</li>
</ul>
</li>
<li><p><strong>进程管理</strong>:</p>
<ul>
<li>对于 CPU 密集型任务，可以使用 Node.js 的 <code>child_process</code> 模块来创建子进程，分担主线程的负载。</li>
<li>还可以使用集群（Cluster）模块来创建多个进程，每个进程都有自己的事件循环和 V8 实例，可以更好地利用多核 CPU。</li>
</ul>
</li>
</ol>
<p>通过这些机制，Node.js 能够确保即使是在单个主线程上运行，也能高效地处理大量的并发 I&#x2F;O 操作，同时避免线程中断和阻塞。</p>
<span id="more"></span>

<h2 id="TCP-三次握手与四次挥手"><a href="#TCP-三次握手与四次挥手" class="headerlink" title="TCP 三次握手与四次挥手"></a>TCP 三次握手与四次挥手</h2><p>TCP（传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。在TCP&#x2F;IP协议族中，TCP的任务是在两个主机之间建立一个可靠的连接，并保证数据包的顺序传输和完整性。这一过程通过“三次握手”来建立连接，通过“四次挥手”来终止连接。</p>
<h3 id="TCP三次握手（连接建立过程）"><a href="#TCP三次握手（连接建立过程）" class="headerlink" title="TCP三次握手（连接建立过程）"></a>TCP三次握手（连接建立过程）</h3><p>三次握手的主要目的是双方确认自身的发送与接收是正常的。过程如下：</p>
<ol>
<li><p><strong>SYN</strong>：客户端发送一个SYN（同步序列编号）报文到服务器。在这个阶段，客户端尝试建立连接，告诉服务器它想要开始一个新的连接，并且包含了客户端的初始序列号（ISN），用于同步。</p>
</li>
<li><p><strong>SYN-ACK</strong>：服务器收到SYN报文后，会发送一个SYN-ACK（同步应答）报文作为响应。这个报文中既确认（ACK）了客户端的SYN（ACK编号设为客户端的ISN+1），也包含了服务器自己的初始序列号，准备同步。</p>
</li>
<li><p><strong>ACK</strong>：客户端收到SYN-ACK后，发送一个ACK（确认）报文作为回应。这个ACK报文的序列号设置为服务器的ISN+1，确认号则是服务器的SYN-ACK中的序列号+1。至此，连接建立完成。</p>
</li>
</ol>
<h3 id="TCP四次挥手（连接释放过程）"><a href="#TCP四次挥手（连接释放过程）" class="headerlink" title="TCP四次挥手（连接释放过程）"></a>TCP四次挥手（连接释放过程）</h3><p>四次挥手的主要目的是允许双方各自独立地关闭连接。过程如下：</p>
<ol>
<li><p><strong>FIN</strong>：当通信的一方完成数据传输后，会发送一个FIN（结束）报文，表示它已经没有数据发送了，请求释放连接。</p>
</li>
<li><p><strong>ACK</strong>：接收方收到FIN报文后，会发送一个ACK报文作为响应，确认号为接收到的序列号+1。这表明接收方已经知道发送方没有数据发送了，但它还可能有数据发送给对方。</p>
</li>
<li><p><strong>FIN</strong>：如果接收方也发送了所有数据，它将发送自己的FIN报文，请求释放连接。</p>
</li>
<li><p><strong>ACK</strong>：发送方收到这个FIN之后，发送一个ACK报文作为回应，确认号为接收到的序列号+1。在等待一段时间之后（称为TIME_WAIT状态），以确保对方收到了最后的ACK报文，连接被彻底关闭。</p>
</li>
</ol>
<p>这个过程确保了TCP连接的可靠性，使得每一方都能独立地关闭自己的半连接，从而完全关闭整个TCP连接。</p>
<h2 id="建立可靠的-UDP-连接"><a href="#建立可靠的-UDP-连接" class="headerlink" title="建立可靠的 UDP 连接"></a>建立可靠的 UDP 连接</h2><ol>
<li><p><strong>确认和重传机制</strong>：发送端对每个UDP数据包分配序列号，并在发送后等待接收端的确认响应。如果在预定时间内未收到确认，发送端会重传该数据包。</p>
</li>
<li><p><strong>序列号和排序</strong>：接收端利用序列号检查接收到的数据包顺序，并重新排序乱序到达的数据包。</p>
</li>
<li><p><strong>错误检测</strong>：通过在数据包中加入校验和（Checksum），接收端可以检测到数据包在传输过程中的任何错误。</p>
</li>
<li><p><strong>流量控制和拥塞控制</strong>：可以通过动态调整发送数据的速率和频率来避免网络拥塞和数据丢失。</p>
</li>
<li><p><strong>连接管理</strong>：虽然UDP本身是无连接的，但应用可以设计握手协议来初始化通信参数，如协商数据包大小、传输速率等，以及通过心跳机制检测对方是否可达，从而实现类似于TCP的连接管理功能。</p>
</li>
</ol>
<h2 id="websocket-建立连接的过程"><a href="#websocket-建立连接的过程" class="headerlink" title="websocket 建立连接的过程"></a>websocket 建立连接的过程</h2><p>WebSocket 建立连接的过程是一个升级自 HTTP 协议的握手过程。WebSocket 允许在用户的浏览器和服务器之间建立一个持久的连接，使得数据可以双向传输。下面是 WebSocket 建立连接的详细步骤：</p>
<ol>
<li><p><strong>客户端发送握手请求</strong>:</p>
<ul>
<li>首先，客户端（通常是一个网页的 JavaScript）通过发送一个 HTTP 请求来初始化 WebSocket 连接。这个请求被称为”握手请求”。</li>
<li>这个请求使用普通的 HTTP GET 方法，但在请求头中包含特定的头部字段，指示这是一个 WebSocket 连接请求。主要的头部字段包括：<ul>
<li><code>Upgrade: websocket</code>：告诉服务器，客户端希望将 HTTP 连接升级到 WebSocket。</li>
<li><code>Connection: Upgrade</code>：同样表示这是一个升级请求。</li>
<li><code>Sec-WebSocket-Key</code>：一个 Base64 编码的随机值，服务器将用它来构建一个响应密钥，验证连接。</li>
<li><code>Sec-WebSocket-Version</code>：标示客户端支持的 WebSocket 版本。</li>
<li><code>Origin</code>（可选）：指示请求来自哪个源，用于服务器的跨源策略。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>服务器响应握手</strong>:</p>
<ul>
<li>服务器解析这个握手请求，如果接受升级请求，则会发送一个 HTTP 101 Switching Protocols 响应。</li>
<li>服务器的响应也包含几个特定的头部字段：<ul>
<li><code>Upgrade: websocket</code> 和 <code>Connection: Upgrade</code>：确认升级到 WebSocket。</li>
<li><code>Sec-WebSocket-Accept</code>：这是对客户端 <code>Sec-WebSocket-Key</code> 的响应，由服务器生成，客户端会验证这个值以确认连接的有效性。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>连接建立</strong>:</p>
<ul>
<li>客户端收到服务器的 101 响应后，WebSocket 连接被视为已经建立，客户端和服务器就可以开始通过这个连接双向传输数据了。</li>
<li>此时，连接从 HTTP 协议升级为 WebSocket 协议。</li>
</ul>
</li>
<li><p><strong>数据传输</strong>:</p>
<ul>
<li>一旦连接建立，客户端和服务器就可以开始发送和接收消息。</li>
<li>WebSocket 协议支持文本和二进制数据的传输。</li>
</ul>
</li>
<li><p><strong>保持连接</strong>:</p>
<ul>
<li>WebSocket 连接会保持活跃状态，直到客户端或服务器决定关闭连接。</li>
<li>连接保持活跃使得双方可以随时发送数据，无需重新建立连接。</li>
</ul>
</li>
</ol>
<p>这个握手过程的设计允许 WebSocket 连接轻松地穿过大多数防火墙，因为它们在初始阶段模仿标准的 HTTP 连接。这种方法还使得在不支持 WebSocket 的环境中回退到其他协议（如长轮询）变得更加容易。</p>
<h2 id="websocket和长轮询的区别"><a href="#websocket和长轮询的区别" class="headerlink" title="websocket和长轮询的区别"></a>websocket和长轮询的区别</h2><p>WebSocket 和长轮询（Long Polling）是两种在客户端和服务器之间实现实时数据通信的技术，但它们在工作原理和效率方面有显著区别。下面是 WebSocket 和长轮询之间的主要区别：</p>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><ol>
<li><p><strong>持久连接</strong>:</p>
<ul>
<li>WebSocket 协议建立的是一个持久的、全双工的连接。一旦连接建立，客户端和服务器可以随时互相发送数据，直到任一方主动关闭连接。</li>
</ul>
</li>
<li><p><strong>协议升级</strong>:</p>
<ul>
<li>WebSocket 通过一次 HTTP 握手升级到 WebSocket 协议。握手完成后，协议从 HTTP 切换到 WebSocket，这个连接将保持打开状态，不再是 HTTP 协议。</li>
</ul>
</li>
<li><p><strong>高效率</strong>:</p>
<ul>
<li>因为连接是持久的，所以不存在为了每次数据交换而建立和终止连接的额外开销。这使得 WebSocket 在数据实时性和网络效率方面优于长轮询。</li>
</ul>
</li>
<li><p><strong>双向通信</strong>:</p>
<ul>
<li>WebSocket 支持全双工通信，即客户端和服务器可以同时发送和接收数据。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>:</p>
<ul>
<li>适合需要高频率、实时性强的应用场景，例如在线游戏、实时聊天、实时数据更新等。</li>
</ul>
</li>
</ol>
<h3 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h3><ol>
<li><p><strong>基于 HTTP 请求</strong>:</p>
<ul>
<li>长轮询是在标准的 HTTP 协议上工作的。客户端发送一个 HTTP 请求到服务器，服务器保持这个请求开放直到有数据可发送。</li>
</ul>
</li>
<li><p><strong>非持久连接</strong>:</p>
<ul>
<li>每次服务器向客户端发送响应后，连接被关闭。对于新的数据，客户端需要发起新的 HTTP 请求。</li>
</ul>
</li>
<li><p><strong>效率较低</strong>:</p>
<ul>
<li>长轮询需要频繁地建立和关闭 HTTP 连接，这在某些场景下可能导致较高的网络开销和延迟。</li>
</ul>
</li>
<li><p><strong>单向请求模式</strong>:</p>
<ul>
<li>尽管长轮询可以较快地将服务器的更新推送到客户端，但它本质上仍然是一种单向请求模式，即服务器不能主动向客户端发送消息，除非客户端首先发送请求。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>:</p>
<ul>
<li>适合对实时性要求不是特别高的应用，或是在不支持 WebSocket 的环境中作为替代方案使用。</li>
</ul>
</li>
</ol>
<p>总结来说，WebSocket 提供了更高效、更适合实时通信的双向连接，而长轮询是一种更简单、在旧浏览器上更容易实现的替代方案。WebSocket 是实现实时应用的首选技术，但在某些场景下，长轮询可能因其简单性和兼容性而被选择。</p>
<h2 id="tcp-如何保证可靠性"><a href="#tcp-如何保证可靠性" class="headerlink" title="tcp 如何保证可靠性"></a>tcp 如何保证可靠性</h2><p>TCP（传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。它通过一系列机制来保证数据传输的可靠性，包括：</p>
<ol>
<li><p><strong>三次握手建立连接</strong>:</p>
<ul>
<li>在传输数据之前，TCP 使用一种被称为“三次握手”的过程来建立连接。这确保了双方都准备好接收和发送数据，并防止了初始化连接时的一些常见的问题。</li>
</ul>
</li>
<li><p><strong>序列号和确认应答</strong>:</p>
<ul>
<li>TCP 给发送的每个数据包分配一个序列号，并要求接收方对每个接收到的数据包发送确认（ACK）。</li>
<li>如果发送方在预定的超时时间内没有收到对特定数据包的确认，它会重新发送该数据包。</li>
</ul>
</li>
<li><p><strong>数据校验和</strong>:</p>
<ul>
<li>每个 TCP 数据包包含一个校验和，以确保数据在传输过程中没有被破坏或更改。</li>
<li>如果接收方检测到数据包损坏（校验和不匹配），它将丢弃该数据包并不发送确认，导致发送方重新发送数据。</li>
</ul>
</li>
<li><p><strong>流量控制</strong>:</p>
<ul>
<li>TCP 使用窗口大小控制来进行流量控制，以避免发送方过快发送数据，导致接收方来不及处理。</li>
<li>接收方通过在确认应答中指定一个“窗口大小”来告诉发送方它还能接收多少数据，从而控制发送方的数据发送速率。</li>
</ul>
</li>
<li><p><strong>拥塞控制</strong>:</p>
<ul>
<li>TCP 还实现了拥塞控制机制，以避免网络中过多的数据包导致网络拥塞。</li>
<li>当网络拥塞时，TCP 会减少其数据传输速率，并在网络状况改善时逐渐增加速率。</li>
</ul>
</li>
<li><p><strong>乱序数据重新排序</strong>:</p>
<ul>
<li>由于网络原因，TCP 数据包可能会乱序到达。TCP 在接收端会根据序列号重新对数据包进行排序，以确保数据的正确顺序。</li>
</ul>
</li>
<li><p><strong>保持活动检测</strong>:</p>
<ul>
<li>TCP 定期发送保持活动包，以检测连接是否仍然有效，防止“死”连接占用资源。</li>
</ul>
</li>
</ol>
<p>通过这些机制，TCP 能够在不可靠的互联网环境中提供可靠的数据传输服务。这些特性使得 TCP 成为了许多需要高可靠性数据传输的应用（如Web页面加载、文件传输、电子邮件等）的理想选择。</p>
<h2 id="拥塞算法"><a href="#拥塞算法" class="headerlink" title="拥塞算法"></a>拥塞算法</h2><p>TCP拥塞控制算法是为了解决和避免网络拥塞问题而设计的一组算法。当多个网络设备尝试同时发送过多数据时，网络拥塞可能发生，导致网络性能下降和数据包丢失。TCP拥塞控制算法的目的是确保每个网络连接获得公平的带宽使用，并减少数据包丢失。下面是一些主要的TCP拥塞控制算法：</p>
<ol>
<li><p><strong>慢启动（Slow Start）</strong>:</p>
<ul>
<li>在TCP连接开始时，慢启动算法被用来探测网络的载荷能力。</li>
<li>慢启动通过逐渐增加拥塞窗口（Congestion Window, cwnd）的大小来增加网络中的数据量，开始时cwnd从一个或几个数据包开始，每收到一个确认响应，cwnd就增加一倍，呈指数增长。</li>
<li>当cwnd达到一个阈值（ssthresh）时，切换到拥塞避免算法。</li>
</ul>
</li>
<li><p><strong>拥塞避免（Congestion Avoidance）</strong>:</p>
<ul>
<li>在拥塞避免阶段，每经过一个往返时间（Round-Trip Time, RTT），cwnd线性增加一个数据包，而不是指数增长。</li>
<li>这个阶段旨在维持网络载荷在一个相对稳定的水平。</li>
</ul>
</li>
<li><p><strong>快重传（Fast Retransmit）</strong>:</p>
<ul>
<li>快重传是指在接收方连续收到三个相同的确认（Triple Duplicate ACKs）时，立即重传丢失的数据包，而不是等待重传计时器到期。</li>
<li>这种机制可以更快地纠正丢包的情况。</li>
</ul>
</li>
<li><p><strong>快恢复（Fast Recovery）</strong>:</p>
<ul>
<li>快恢复算法与快重传一起工作，当检测到丢包（通过三个重复的 ACK ）时，它会减少 cwnd 的大小而不是像慢启动时那样将其减至1，通常将 cwnd 设置为 ssthresh 的一半。</li>
<li>在快恢复阶段，对于每个接收到的重复 ACK ， cwnd 逐渐增加，直到收到新的数据确认。</li>
</ul>
</li>
<li><p><strong>TCP Tahoe 和 Reno</strong>:</p>
<ul>
<li>TCP Tahoe 和 Reno 是两种实现了上述拥塞控制算法的TCP变体。</li>
<li>Tahoe 使用慢启动、拥塞避免和快重传，但在检测到丢包时，它会将cwnd重置为1。</li>
<li>Reno 则引入了快恢复算法，它在丢包时减少cwnd而不是重置。</li>
</ul>
</li>
<li><p><strong>其他算法</strong>:</p>
<ul>
<li>随着网络技术的发展，出现了更多的拥塞控制算法，如TCP Vegas, TCP BBR（Bottleneck Bandwidth and RTT）等，它们在不同的网络环境和场景中提供了改进的性能。</li>
</ul>
</li>
</ol>
<p>TCP拥塞控制算法的设计旨在使TCP连接能够自适应网络状况的变化，优化网络资源的使用，同时保证网络的稳定性和公平性。随着网络条件的不断变化，这些算法也在不断地进化和优化。</p>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>TCP（传输控制协议）的三次握手（Three-Way Handshake）过程是用于在两个网络实体之间建立一个可靠的连接的关键机制。这个过程不仅用于协商和初始化连接参数，还用于确保双方准备好进行数据传输。下面是三次握手的详细介绍：</p>
<h3 id="第一次握手：SYN"><a href="#第一次握手：SYN" class="headerlink" title="第一次握手：SYN"></a>第一次握手：SYN</h3><ol>
<li><p><strong>发起方发送SYN包</strong>:</p>
<ul>
<li>连接的发起方（客户端）开始握手过程，发送一个包含 SYN（同步序列编号）标志的数据包到接收方（服务器）。</li>
<li>在这个数据包中，发起方选择一个随机的序列号（Seq &#x3D; X），这个序列号在后续数据传输中用于保证数据的有序和完整性。</li>
</ul>
</li>
<li><p><strong>目的</strong>:</p>
<ul>
<li>主要是向接收方表明发起方希望建立连接。</li>
</ul>
</li>
</ol>
<h3 id="第二次握手：SYN-ACK"><a href="#第二次握手：SYN-ACK" class="headerlink" title="第二次握手：SYN-ACK"></a>第二次握手：SYN-ACK</h3><ol>
<li><p><strong>接收方响应SYN-ACK包</strong>:</p>
<ul>
<li>接收方收到 SYN 包后，需要确认这个请求。它发送一个包含 SYN 和 ACK（确认响应）标志的数据包。</li>
<li>这个数据包中的确认号（Ack &#x3D; X + 1）是对发起方 SYN 包中序列号的确认，同时接收方也选择自己的一个随机序列号（Seq &#x3D; Y）。</li>
</ul>
</li>
<li><p><strong>目的</strong>:</p>
<ul>
<li>确认发起方的 SYN，并且通知发起方接收方也准备好建立连接。</li>
</ul>
</li>
</ol>
<h3 id="第三次握手：ACK"><a href="#第三次握手：ACK" class="headerlink" title="第三次握手：ACK"></a>第三次握手：ACK</h3><ol>
<li><p><strong>发起方发送ACK包</strong>:</p>
<ul>
<li>发起方收到 SYN-ACK 包后，发送一个包含 ACK 标志的数据包，这个包的确认号被设置为接收方的序列号加一（Ack &#x3D; Y + 1）。</li>
<li>这一步完成了对接收方初始序列号的确认。</li>
</ul>
</li>
<li><p><strong>连接建立</strong>:</p>
<ul>
<li>一旦接收方收到这个 ACK 包，连接就被认为是建立了。现在，双方都已确认彼此的初始序列号，并且都准备好进行数据传输。</li>
</ul>
</li>
</ol>
<h3 id="为什么需要三次握手？"><a href="#为什么需要三次握手？" class="headerlink" title="为什么需要三次握手？"></a>为什么需要三次握手？</h3><p>三次握手的设计是为了确保双方都能确认对方的接收和发送能力。它主要解决了以下几个问题：</p>
<ul>
<li>确保双方都知道对方准备好发送和接收数据。</li>
<li>避免旧的延迟连接初始化请求突然建立连接。</li>
<li>确保在连接开始时双方的序列号被正确初始化和同步。</li>
</ul>
<p>这个过程是建立一个可靠的 TCP 连接的基础，确保了数据传输的可靠性和顺序性。</p>
<h2 id="http-和-tcp-的-keep-alive-区别"><a href="#http-和-tcp-的-keep-alive-区别" class="headerlink" title="http 和 tcp 的 keep-alive 区别"></a>http 和 tcp 的 keep-alive 区别</h2><p>HTTP Keep-Alive 和 TCP Keep-Alive 是两种不同层次上的保持连接活跃的机制，它们的目的和实现方式有所不同：</p>
<h3 id="HTTP-Keep-Alive"><a href="#HTTP-Keep-Alive" class="headerlink" title="HTTP Keep-Alive"></a>HTTP Keep-Alive</h3><ol>
<li><p><strong>层次</strong>:</p>
<ul>
<li>HTTP Keep-Alive 工作在应用层，是 HTTP 协议的一部分。</li>
</ul>
</li>
<li><p><strong>目的</strong>:</p>
<ul>
<li>HTTP Keep-Alive 的主要目的是减少建立和关闭连接的频繁操作，提高 HTTP 传输效率。</li>
<li>它允许在一个 TCP 连接上发送和接收多个 HTTP 请求&#x2F;响应，而不需要为每个请求&#x2F;响应对重新建立新的 TCP 连接。</li>
</ul>
</li>
<li><p><strong>实现</strong>:</p>
<ul>
<li>在 HTTP 1.1 中，默认开启 Keep-Alive。</li>
<li>客户端和服务器在 HTTP 头部信息中通过 <code>Connection: keep-alive</code> 来通告对方它们希望保持连接打开。</li>
<li>连接会保持活跃直到客户端或服务器决定关闭，或者超过预定的超时时间。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>:</p>
<ul>
<li>HTTP Keep-Alive 特别适用于需要多个连续的 HTTP 请求&#x2F;响应的场景，如网页加载中包含多个资源（CSS、JavaScript、图片等）的情况。</li>
</ul>
</li>
</ol>
<h3 id="TCP-Keep-Alive"><a href="#TCP-Keep-Alive" class="headerlink" title="TCP Keep-Alive"></a>TCP Keep-Alive</h3><ol>
<li><p><strong>层次</strong>:</p>
<ul>
<li>TCP Keep-Alive 工作在传输层，是 TCP 协议的一部分。</li>
</ul>
</li>
<li><p><strong>目的</strong>:</p>
<ul>
<li>TCP Keep-Alive 的目的是检测死亡连接（即长时间无数据交换的连接），确保连接的双方仍然可达。</li>
<li>它用于维护和监控 TCP 连接的状态。</li>
</ul>
</li>
<li><p><strong>实现</strong>:</p>
<ul>
<li>TCP Keep-Alive 通过定期发送探测数据包来实现。如果在一定次数的探测后仍然没有收到响应，则认为连接已经断开，并关闭连接。</li>
<li>这个机制在某些操作系统中默认关闭，并且探测间隔和次数可以配置。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>:</p>
<ul>
<li>TCP Keep-Alive 适用于任何基于 TCP 的网络服务，特别是那些可能长时间空闲但需要保持连接的场景，如数据库连接。</li>
</ul>
</li>
</ol>
<h3 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h3><ul>
<li><strong>层次不同</strong>：HTTP Keep-Alive 是应用层协议，TCP Keep-Alive 是传输层协议。</li>
<li><strong>目的不同</strong>：HTTP Keep-Alive 用于提高 HTTP 效率，减少连接重建的开销；而 TCP Keep-Alive 用于检测和维护连接的活跃状态。</li>
<li><strong>适用范围</strong>：HTTP Keep-Alive 仅用于 HTTP 协议，而 TCP Keep-Alive 适用于所有基于 TCP 的通信。</li>
<li><strong>工作方式</strong>：HTTP Keep-Alive 通过重用连接进行多个请求&#x2F;响应交换，TCP Keep-Alive 通过发送探测数据包来检测连接状态。</li>
</ul>
<h2 id="js-闭包、原型、事件循环"><a href="#js-闭包、原型、事件循环" class="headerlink" title="js 闭包、原型、事件循环"></a>js 闭包、原型、事件循环</h2><h3 id="闭包（Closure）"><a href="#闭包（Closure）" class="headerlink" title="闭包（Closure）"></a>闭包（Closure）</h3><p>闭包是 JavaScript 中一个非常重要的特性，它允许一个函数访问并操作该函数外部的变量。</p>
<ol>
<li><p><strong>定义</strong>: 在 JavaScript 中，当一个函数嵌套在另一个函数内，并引用外层函数的变量时，就形成了闭包。</p>
</li>
<li><p><strong>作用</strong>:</p>
<ul>
<li><strong>访问外部函数的变量</strong>: 内部函数可以访问定义在外部函数中的变量，即使外部函数已经执行完毕。</li>
<li><strong>数据封装和私有性</strong>: 闭包可以用来创建私有变量，提供类似于面向对象编程中的封装和隐藏数据的功能。</li>
</ul>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> secret = <span class="string">&quot;I&#x27;m a secret!&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">innerFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(secret);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getSecret = <span class="title function_">outerFunction</span>();</span><br><span class="line"><span class="title function_">getSecret</span>(); <span class="comment">// 输出 &quot;I&#x27;m a secret!&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="原型（Prototype）"><a href="#原型（Prototype）" class="headerlink" title="原型（Prototype）"></a>原型（Prototype）</h3><p>原型是 JavaScript 中实现继承和共享属性或方法的一种机制。</p>
<ol>
<li><p><strong>原型对象</strong>: 每个 JavaScript 对象都有一个原型对象（<code>prototype</code>），对象从其原型继承属性和方法。</p>
</li>
<li><p><strong>原型链</strong>: 当访问一个对象的属性或方法时，如果该对象自身不包含这个属性或方法，JavaScript 会沿着原型链向上查找，直到找到或到达原型链的顶端（<code>Object.prototype</code>）。</p>
</li>
<li><p><strong>使用</strong>:</p>
<ul>
<li>常用于创建具有相似属性和方法的多个对象，提高代码复用性。</li>
<li>原型链是 JavaScript 中实现继承的基础。</li>
</ul>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">person1.<span class="title function_">sayHello</span>(); <span class="comment">// 输出 &quot;Hello, my name is Alice&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="事件循环（Event-Loop）"><a href="#事件循环（Event-Loop）" class="headerlink" title="事件循环（Event Loop）"></a>事件循环（Event Loop）</h3><p>事件循环是 JavaScript 中处理异步操作和保持单线程运行的机制。</p>
<ol>
<li><p><strong>单线程和异步</strong>: JavaScript 是单线程语言，但支持异步编程（例如，通过回调函数、Promises、async&#x2F;await）。</p>
</li>
<li><p><strong>任务类型</strong>:</p>
<ul>
<li><strong>宏任务（Macro Task）</strong>: 如 <code>setTimeout</code>, <code>setInterval</code>, I&#x2F;O 操作。</li>
<li><strong>微任务（Micro Task）</strong>: 如 Promise 回调、<code>process.nextTick</code>（在 Node.js 中）。</li>
</ul>
</li>
<li><p><strong>工作机制</strong>:</p>
<ul>
<li>事件循环不断检查是否有待执行的任务。</li>
<li>如果执行栈为空，事件循环会查看任务队列。如果队列中有宏任务，从队列中取出一个执行。</li>
<li>在每个宏任务执行之后，事件循环会处理所有的微任务队列，之后再执行下一个宏任务。</li>
<li>这个循环持续进行，直到所有任务完成。</li>
</ul>
</li>
<li><p><strong>示例</strong>:</p>
<ul>
<li>异步操作（如通过 <code>setTimeout</code> 设置的定时器）不会立即执行，而是被加入队列，在当前和其他微任务执行完毕后再执行。</li>
</ul>
</li>
</ol>
<h2 id="webpack-与-vite"><a href="#webpack-与-vite" class="headerlink" title="webpack 与 vite"></a>webpack 与 vite</h2><p>Webpack 和 Vite 是两种流行的前端构建工具，它们用于优化开发和生产环境下的前端项目。虽然两者的目标相似，但它们在实现方式和性能上有明显的区别：</p>
<h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><ol>
<li><p><strong>概念</strong>:</p>
<ul>
<li>Webpack 是一个模块打包器（bundler），主要用于 JavaScript 和相关资源文件（如 CSS、图片）的模块化构建和打包。</li>
</ul>
</li>
<li><p><strong>工作原理</strong>:</p>
<ul>
<li>Webpack 通过一个入口点开始，分析项目中的模块和资源依赖，将这些资源转换和打包成少数几个文件，通常用于生产环境。</li>
</ul>
</li>
<li><p><strong>特点</strong>:</p>
<ul>
<li><strong>灵活性和配置性</strong>：Webpack 提供了广泛的插件系统和配置选项，适用于复杂的项目需求。</li>
<li><strong>热模块替换（HMR）</strong>：在开发环境中，Webpack 支持热模块替换，允许应用在运行时更新模块而无需完全刷新。</li>
<li><strong>慢启动</strong>：由于需要分析整个项目的依赖和资源，Webpack 的启动和热更新可能比较慢。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>:</p>
<ul>
<li>适用于需要复杂配置和高度定制化构建流程的大型项目。</li>
</ul>
</li>
</ol>
<h3 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h3><ol>
<li><p><strong>概念</strong>:</p>
<ul>
<li>Vite 是一个更现代的前端构建工具，利用了最新的前端技术，如原生 ES 模块加载。</li>
</ul>
</li>
<li><p><strong>工作原理</strong>:</p>
<ul>
<li>在开发环境中，Vite 作为一个服务器运行，它利用浏览器原生的 ES 模块导入功能来服务模块请求。</li>
<li>在生产环境中，Vite 使用 Rollup 进行高效的打包。</li>
</ul>
</li>
<li><p><strong>特点</strong>:</p>
<ul>
<li><strong>快速启动</strong>：由于使用了原生 ES 模块，Vite 在开发环境中可以快速启动，无需等待打包过程。</li>
<li><strong>按需编译</strong>：Vite 只编译当前请求的模块，而不是整个应用，这使得热更新非常快。</li>
<li><strong>简化配置</strong>：Vite 设计理念倾向于减少配置，提供更简洁的开发体验。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>:</p>
<ul>
<li>适用于新项目，尤其是在追求快速开发和简化构建配置的场景下。</li>
</ul>
</li>
</ol>
<h3 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h3><ul>
<li><strong>启动速度</strong>：Vite 在开发环境中的启动速度通常比 Webpack 快，因为它不需要预先打包整个应用。</li>
<li><strong>热更新速度</strong>：Vite 的热更新通常比 Webpack 快，因为它只编译变更的模块。</li>
<li><strong>构建原理</strong>：Webpack 是一个传统的模块打包器，而 Vite 利用了现代浏览器的原生 ES 模块特性。</li>
<li><strong>兼容性</strong>：Webpack 支持更广泛的模块格式和浏览器兼容性，而 Vite 主要针对现代浏览器。</li>
<li><strong>配置复杂性</strong>：Webpack 的配置通常更复杂，而 Vite 旨在提供更简洁的配置。</li>
</ul>
<h2 id="vue2-和-vue3"><a href="#vue2-和-vue3" class="headerlink" title="vue2 和 vue3"></a>vue2 和 vue3</h2><p>Vue.js 是一个流行的 JavaScript 框架，用于构建用户界面和单页应用程序。Vue 3 是 Vue.js 的最新主要版本，相比于 Vue 2，它引入了许多新特性和改进。以下是 Vue 2 和 Vue 3 之间的主要区别：</p>
<h3 id="性能改进"><a href="#性能改进" class="headerlink" title="性能改进"></a>性能改进</h3><ol>
<li><p><strong>更快的虚拟 DOM</strong>:</p>
<ul>
<li>Vue 3 引入了一个全新的虚拟 DOM 实现，优化了渲染速度和内存消耗。</li>
</ul>
</li>
<li><p><strong>编译优化</strong>:</p>
<ul>
<li>Vue 3 的编译器进行了重写，提供了更好的编译优化，减少了运行时的开销。</li>
</ul>
</li>
<li><p><strong>树摇动（Tree-shaking）</strong>:</p>
<ul>
<li>Vue 3 支持树摇动，意味着在最终打包时可以去除未使用的代码，减小应用体积。</li>
</ul>
</li>
</ol>
<h3 id="组合式-API"><a href="#组合式-API" class="headerlink" title="组合式 API"></a>组合式 API</h3><p>Vue 3 引入了 Composition API（组合式 API），这是 Vue 3 最显著的新特性之一。</p>
<ol>
<li><p><strong>更好的逻辑复用和组织</strong>:</p>
<ul>
<li>Composition API 允许开发者更灵活地组织组件逻辑，特别是在处理复杂组件时。</li>
<li>使用 <code>setup</code> 函数和一系列新的 API（如 <code>ref</code>, <code>reactive</code>, <code>computed</code>, <code>watch</code> 等），可以更好地封装和重用逻辑。</li>
</ul>
</li>
<li><p><strong>与 Options API 的共存</strong>:</p>
<ul>
<li>Vue 3 依然支持 Vue 2 中的 Options API，两种风格可以共存。</li>
</ul>
</li>
</ol>
<h3 id="更好的-TypeScript-支持"><a href="#更好的-TypeScript-支持" class="headerlink" title="更好的 TypeScript 支持"></a>更好的 TypeScript 支持</h3><ul>
<li>Vue 3 从一开始就考虑到了 TypeScript 的支持，其代码基于 TypeScript 编写，提供了更好的类型推断和集成。</li>
</ul>
<h3 id="其他新特性和改进"><a href="#其他新特性和改进" class="headerlink" title="其他新特性和改进"></a>其他新特性和改进</h3><ol>
<li><p><strong>组合式 API</strong>:</p>
<ul>
<li>引入了更灵活的组合式 API，为组件逻辑提供了更强的组织能力。</li>
</ul>
</li>
<li><p><strong>更小的体积</strong>:</p>
<ul>
<li>Vue 3 的体积比 Vue 2 更小，主要得益于树摇动。</li>
</ul>
</li>
<li><p><strong>多根节点组件</strong>:</p>
<ul>
<li>Vue 3 允许组件有多个根节点，而 Vue 2 中每个组件只能有一个根节点。</li>
</ul>
</li>
<li><p><strong>响应式系统的重写</strong>:</p>
<ul>
<li>Vue 3 的响应式系统基于 Proxy API 重写，提供了更好的性能和兼容性。</li>
</ul>
</li>
<li><p><strong>全新的生命周期钩子</strong>:</p>
<ul>
<li>引入了新的生命周期钩子，如 <code>onMounted</code>, <code>onUpdated</code> 等。</li>
</ul>
</li>
<li><p><strong>Fragment, Teleport, Suspense</strong>:</p>
<ul>
<li>引入了新的内置组件，如 Fragment（允许多个根节点），Teleport（允许将子节点传送到 DOM 树的其他位置），Suspense（用于异步组件的数据获取和渲染）。</li>
</ul>
</li>
</ol>
<h3 id="兼容性和迁移"><a href="#兼容性和迁移" class="headerlink" title="兼容性和迁移"></a>兼容性和迁移</h3><ul>
<li>Vue 3 考虑到了向后兼容性，提供了从 Vue 2 迁移到 Vue 3 的工具和指南。</li>
</ul>
<h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><ol>
<li><p><strong>事件循环</strong>:</p>
<ul>
<li>Node.js 运行时基于事件循环。事件循环负责处理异步回调，如 I&#x2F;O 操作、计时器、网络请求等。</li>
</ul>
</li>
<li><p><strong>微任务队列</strong>:</p>
<ul>
<li><code>process.nextTick</code> 将回调函数放入微任务队列。这个队列在事件循环的每个阶段之间执行，甚至在事件循环的当前阶段完成之前。</li>
</ul>
</li>
<li><p><strong>优先级</strong>:</p>
<ul>
<li>通过 <code>process.nextTick</code> 调度的任务比通过 <code>setImmediate</code> 或 <code>setTimeout</code>、<code>setInterval</code> 调度的任务优先级更高。这意味着 <code>nextTick</code> 回调在任何 I&#x2F;O 事件（包括定时器）之前执行。</li>
</ul>
</li>
</ol>
<h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><ul>
<li>当调用 <code>process.nextTick</code> 时，传入的回调函数不会立即执行。而是在当前操作完成后、事件循环继续进行之前执行。</li>
<li>这意味着即使在 I&#x2F;O 操作或定时器触发之前，所有通过 <code>nextTick</code> 排队的回调都会首先执行。</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><p><strong>错误处理</strong>:</p>
<ul>
<li><code>process.nextTick</code> 经常用于异步 API 中的错误处理。这是因为它允许在堆栈被解构之前抛出异常，从而可以捕获和处理错误。</li>
</ul>
</li>
<li><p><strong>确保异步性</strong>:</p>
<ul>
<li>有时候，你可能需要确保代码总是以异步方式运行，即使是在同步代码块中。<code>process.nextTick</code> 可以用于确保回调总是异步调用，从而避免了同步操作和异步操作之间的潜在问题。</li>
</ul>
</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始&#x27;</span>);</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextTick 回调&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;计划的 nextTick&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，输出将会是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开始</span><br><span class="line">计划的 nextTick</span><br><span class="line">nextTick 回调</span><br></pre></td></tr></table></figure>

<p>即使 <code>process.nextTick</code> 的回调是在最后一行调用的，它仍然在当前事件循环的末尾执行，即在任何其他的 I&#x2F;O 事件或计时器之前执行。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>使用 <code>process.nextTick</code> 可能导致 I&#x2F;O 饿死，因为如果不断地添加 <code>nextTick</code> 回调，那么 I&#x2F;O 事件可能永远无法被处理。因此，适当地使用 <code>nextTick</code> 是非常重要的。</li>
<li>对于绝大多数场景，<code>setImmediate</code> 是处理异步操作的更好选择，因为它更加公平地对待事件循环中的所有类型的事件。</li>
</ul>
<h2 id="javascript-和-typescript"><a href="#javascript-和-typescript" class="headerlink" title="javascript 和 typescript"></a>javascript 和 typescript</h2><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><ol>
<li><p><strong>定义</strong>:</p>
<ul>
<li>JavaScript 是一种高级的、解释型的编程语言。它是 Web 的核心语言，几乎所有的现代网页都使用 JavaScript 来增加交互性。</li>
</ul>
</li>
<li><p><strong>特点</strong>:</p>
<ul>
<li><strong>动态类型</strong>: JavaScript 是一种动态类型语言，这意味着变量的类型是在运行时确定的。</li>
<li><strong>解释执行</strong>: 作为一种解释型语言，JavaScript 代码在运行时由浏览器或 Node.js 的解释器直接执行。</li>
<li><strong>灵活性</strong>: 它是一种非常灵活的语言，支持面向对象、命令式和函数式编程风格。</li>
</ul>
</li>
<li><p><strong>应用范围</strong>:</p>
<ul>
<li>用于浏览器端的脚本编写，也被广泛用于服务器端（Node.js），以及移动应用和桌面应用开发。</li>
</ul>
</li>
</ol>
<h3 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h3><ol>
<li><p><strong>定义</strong>:</p>
<ul>
<li>TypeScript 是 JavaScript 的一个超集，由 Microsoft 开发和维护。它在 JavaScript 的基础上添加了静态类型系统。</li>
</ul>
</li>
<li><p><strong>特点</strong>:</p>
<ul>
<li><strong>静态类型</strong>: TypeScript 提供了静态类型检查，这意味着类型错误可以在编译阶段被捕获，而不是在运行时。</li>
<li><strong>编译为 JavaScript</strong>: TypeScript 代码需要被编译成 JavaScript 代码，这样浏览器和 Node.js 才能执行。</li>
<li><strong>面向对象特性</strong>: TypeScript 支持更先进的面向对象编程特性，如类、接口、继承和泛型。</li>
</ul>
</li>
<li><p><strong>优势</strong>:</p>
<ul>
<li>提高了大型项目的可维护性和开发效率。</li>
<li>提供了编译时类型检查，有助于及早发现错误。</li>
<li>改善了代码质量和可读性。</li>
</ul>
</li>
<li><p><strong>应用范围</strong>:</p>
<ul>
<li>TypeScript 适用于需要高度维护性和可扩展性的大型项目，特别是在团队开发环境中。</li>
</ul>
</li>
</ol>
<h3 id="主要区别-1"><a href="#主要区别-1" class="headerlink" title="主要区别"></a>主要区别</h3><ul>
<li><strong>类型系统</strong>: TypeScript 的最大特点是它的静态类型系统，而 JavaScript 是动态类型的。</li>
<li><strong>错误检测</strong>: TypeScript 能够在编译期间检测到类型错误，而 JavaScript 中的类型错误通常在运行时出现。</li>
<li><strong>工具支持</strong>: TypeScript 由于其类型系统，提供了更好的自动完成、重构和接口文档。</li>
<li><strong>学习曲线</strong>: TypeScript 的学习曲线相对于 JavaScript 来说稍微陡峭一些，特别是对于不熟悉类型系统的开发者。</li>
</ul>
<p>总的来说，TypeScript 提供了更强大的工具和特性来帮助开发大型和复杂的应用，而 JavaScript 由于其广泛的应用和灵活性，仍然是最流行的前端开发语言之一。开发者可以根据项目的具体需求和团队的熟悉程度来选择使用 JavaScript 还是 TypeScript。</p>
<h2 id="Vue-双向绑定"><a href="#Vue-双向绑定" class="headerlink" title="Vue 双向绑定"></a>Vue 双向绑定</h2><p>Vue.js 中的双向绑定是一种机制，允许数据和 UI 界面之间建立一个响应式连接，使得数据的变化能够自动反映到 UI 上，同时用户对 UI 的操作也能自动更新到数据上。Vue 实现双向绑定主要依靠两个核心概念：响应式系统和 <code>v-model</code> 指令。</p>
<h3 id="响应式系统"><a href="#响应式系统" class="headerlink" title="响应式系统"></a>响应式系统</h3><ol>
<li><p><strong>观察者模式</strong>:</p>
<ul>
<li>Vue 使用观察者模式来跟踪数据的变化。当你把一个普通的 JavaScript 对象传入 Vue 实例作为 <code>data</code> 选项，Vue 会遍历它的所有属性，并使用 <code>Object.defineProperty</code> 把这些属性全部转为 getter&#x2F;setter。这是 Vue 响应式系统的核心。</li>
</ul>
</li>
<li><p><strong>依赖收集</strong>:</p>
<ul>
<li>当渲染函数被首次执行时，Vue 能够追踪到哪些属性被访问了，从而知道在哪些属性发生变化时需要重新渲染。</li>
</ul>
</li>
<li><p><strong>派发更新</strong>:</p>
<ul>
<li>当属性的 setter 被调用时（即属性值发生变化时），Vue 会通知那些依赖于这个属性的组件重新渲染。</li>
</ul>
</li>
</ol>
<h3 id="v-model-指令"><a href="#v-model-指令" class="headerlink" title="v-model 指令"></a><code>v-model</code> 指令</h3><ol>
<li><p><strong>基本用途</strong>:</p>
<ul>
<li><code>v-model</code> 在表单元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。</li>
</ul>
</li>
<li><p><strong>工作原理</strong>:</p>
<ul>
<li>对于输入框（<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>）和选择框（<code>&lt;select&gt;</code>），<code>v-model</code> 绑定的值通常是 <code>input</code> 事件中的 <code>value</code>。</li>
<li>在内部，<code>v-model</code> 实际上是一个语法糖，它相当于同时绑定了 <code>value</code> 属性和监听 <code>input</code> 事件，当控件的输入值变化时，更新数据。</li>
</ul>
</li>
</ol>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>假设有如下 Vue 实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;Hello Vue!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>和如下模板：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>&lt;input&gt;</code> 元素和 <code>message</code> 数据之间建立了双向绑定。用户在输入框中输入文本时，<code>message</code> 数据会实时更新，同时 <code>message</code> 数据的变化也会实时反映到输入框的值中。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>虽然 <code>v-model</code> 提供了方便的双向绑定，但它也可能导致数据流难以理解和追踪，特别是在复杂的应用中。因此，在一些场景下，推荐使用单向数据流（即数据的单向绑定和显式的事件处理）来保持数据流的清晰和可控。</li>
<li>在 Vue 3 中，响应式系统从 <code>Object.defineProperty</code> 改为了基于 ES6 的 Proxy，这使得 Vue 的响应式系统更加强大和高效，同时消除了一些 Vue 2 中存在的限制。</li>
</ul>
<h2 id="Cookie-Session-localStorage"><a href="#Cookie-Session-localStorage" class="headerlink" title="Cookie Session localStorage"></a>Cookie Session localStorage</h2><p><code>Cookie</code>、<code>Session</code> 和 <code>localStorage</code> 是用于存储和管理网站数据的三种不同技术，每种技术都有其特定的用途和限制。</p>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><ol>
<li><p><strong>定义</strong>:</p>
<ul>
<li>Cookie 是小段的数据，由服务器发送到用户浏览器，然后浏览器会将其存储，并在随后的每个请求中将其发送回服务器。</li>
</ul>
</li>
<li><p><strong>特点</strong>:</p>
<ul>
<li>体积小（通常限制为4KB）。</li>
<li>每次 HTTP 请求都会携带，包括静态资源请求，这可能影响性能。</li>
<li>可以设置过期时间。</li>
<li>支持同源策略。</li>
</ul>
</li>
<li><p><strong>用途</strong>:</p>
<ul>
<li>用户认证。</li>
<li>会话跟踪。</li>
<li>个性化设置。</li>
</ul>
</li>
<li><p><strong>安全性</strong>:</p>
<ul>
<li>支持设置为 HttpOnly（无法通过 JS 访问）和 Secure（只在 HTTPS 下传输）。</li>
</ul>
</li>
</ol>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><ol>
<li><p><strong>定义</strong>:</p>
<ul>
<li>Session 是服务器端用来存储用户信息的一种机制，通常用于识别用户和存储用户特定的数据。</li>
</ul>
</li>
<li><p><strong>特点</strong>:</p>
<ul>
<li>存储在服务器端，对客户端是透明的。</li>
<li>可以存储较大量的数据。</li>
<li>生命周期通常取决于用户的会话（浏览器关闭，Session 结束）。</li>
</ul>
</li>
<li><p><strong>用途</strong>:</p>
<ul>
<li>管理用户会话（如登录状态）。</li>
<li>存储用户相关的敏感信息。</li>
</ul>
</li>
<li><p><strong>安全性</strong>:</p>
<ul>
<li>相比于 Cookie，Session 更安全，因为数据存储在服务器端。</li>
</ul>
</li>
</ol>
<h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><ol>
<li><p><strong>定义</strong>:</p>
<ul>
<li>localStorage 是 HTML5 提供的一种在客户端存储数据的方式。</li>
</ul>
</li>
<li><p><strong>特点</strong>:</p>
<ul>
<li>存储容量较大（最多 5MB）。</li>
<li>仅在客户端存储，不随 HTTP 请求发送。</li>
<li>没有过期时间，数据永久保存，直到手动清除。</li>
</ul>
</li>
<li><p><strong>用途</strong>:</p>
<ul>
<li>存储不经常变化的大量数据。</li>
<li>保存用户偏好设置。</li>
<li>缓存应用程序数据以提高性能。</li>
</ul>
</li>
<li><p><strong>安全性</strong>:</p>
<ul>
<li>由于存储在客户端，可能受到跨站脚本攻击（XSS）。</li>
</ul>
</li>
</ol>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ul>
<li><p><strong>存储位置</strong>:</p>
<ul>
<li>Cookie 和 localStorage 存储在客户端。</li>
<li>Session 存储在服务器端。</li>
</ul>
</li>
<li><p><strong>安全性</strong>:</p>
<ul>
<li>Session 比 Cookie 更安全。</li>
<li>localStorage 适用于非敏感数据的存储。</li>
</ul>
</li>
<li><p><strong>生命周期</strong>:</p>
<ul>
<li>Cookie 可以设置过期时间。</li>
<li>Session 通常与用户会话绑定。</li>
<li>localStorage 永久存储，直到被清除。</li>
</ul>
</li>
<li><p><strong>容量</strong>:</p>
<ul>
<li>Cookie 容量最小。</li>
<li>localStorage 提供最大的存储空间。</li>
</ul>
</li>
<li><p><strong>性能</strong>:</p>
<ul>
<li>Cookie 每次请求都会发送，可能影响性能。</li>
<li>Session 和 localStorage 不影响网络性能。</li>
</ul>
</li>
</ul>
<h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><p>跨域是 Web 开发中常见的安全问题之一，它是由浏览器的同源策略引起的。同源策略是浏览器的一种安全措施，它限制了一个域的脚本与另一个域的资源进行交互。如果协议、端口（如果有指定）或主机对于两个页面不同，则这两个页面具有不同的源。</p>
<h3 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h3><p>当一个网页尝试请求另一个与自己域名、端口号或协议不同的网页的资源时，就会发生跨域。例如，由 <code>http://example.com</code> 发起的 AJAX 请求尝试访问 <code>https://api.anotherdomain.com</code> 的资源，由于协议和域名不同，这将是一个跨域请求。</p>
<h3 id="常见的解决方法"><a href="#常见的解决方法" class="headerlink" title="常见的解决方法"></a>常见的解决方法</h3><ol>
<li><p><strong>CORS（跨源资源共享）</strong>:</p>
<ul>
<li>最常用的解决跨域问题的方法是在服务器端设置 CORS。这种方法通过在服务器的响应头中添加 <code>Access-Control-Allow-Origin</code> 来允许特定的外部域访问资源。</li>
<li>例如，<code>Access-Control-Allow-Origin: *</code> 允许所有域名访问资源，而 <code>Access-Control-Allow-Origin: http://example.com</code> 只允许 <code>http://example.com</code> 访问资源。</li>
</ul>
</li>
<li><p><strong>JSONP（JSON with Padding）</strong>:</p>
<ul>
<li>早期解决跨域问题的一种技术，主要用于 GET 请求。</li>
<li>它通过动态创建 <code>&lt;script&gt;</code> 标签来向不同源的服务器请求数据。服务器端返回的数据被包装在一个函数调用中。</li>
<li>JSONP 的缺点是它只支持 GET 请求，并且安全性较低。</li>
</ul>
</li>
<li><p><strong>代理服务器</strong>:</p>
<ul>
<li>使用代理服务器进行跨域请求。在这种情况下，浏览器向代理服务器发送请求，代理服务器将请求发送到目标服务器，并将响应返回给浏览器。</li>
<li>这种方法的优点是可以控制和缓存请求，但缺点是增加了服务器端的复杂性和成本。</li>
</ul>
</li>
<li><p><strong>PostMessage</strong>:</p>
<ul>
<li><code>window.postMessage</code> 是 HTML5 引入的一种安全的跨源通信方法。</li>
<li>这种方法允许不同源之间的窗口相互通信，适用于在不同域之间传递信息。</li>
</ul>
</li>
<li><p><strong>服务器端配置</strong>:</p>
<ul>
<li>对于某些服务，如字体或一些 API，可以在服务器配置文件（如 <code>.htaccess</code> 或 Nginx 配置文件）中设置允许跨域。</li>
</ul>
</li>
<li><p><strong>WebSockets</strong>:</p>
<ul>
<li>WebSockets 本身不受同源策略的限制，可以用于跨域通信。</li>
</ul>
</li>
</ol>
<h3 id="选择合适的方法"><a href="#选择合适的方法" class="headerlink" title="选择合适的方法"></a>选择合适的方法</h3><p>在选择解决跨域问题的方法时，需要考虑安全性、易用性和环境兼容性。对于大多数现代 Web 应用程序，推荐使用 CORS，因为它既安全又灵活。JSONP 可以作为旧系统的一种后备方案，但应谨慎使用，因为它容易受到 XSS 攻击。代理服务器在需要控制或缓存请求时非常有效，但会增加复杂性和成本。</p>
<h2 id="XSS-攻击"><a href="#XSS-攻击" class="headerlink" title="XSS 攻击"></a>XSS 攻击</h2><h3 id="XSS-攻击是什么？"><a href="#XSS-攻击是什么？" class="headerlink" title="XSS 攻击是什么？"></a>XSS 攻击是什么？</h3><p>XSS（跨站脚本攻击，Cross-Site Scripting）是一种在网页上执行恶意脚本的攻击方式，主要目标是在用户的浏览器中执行未经授权的代码。它允许攻击者注入可执行的脚本代码到合法的网页中，这些脚本在其他用户的浏览器中运行时，攻击者可以窃取用户的会话令牌、登录凭证，或者对用户进行其他恶意操作。</p>
<p>XSS 攻击通常分为以下几种类型：</p>
<ol>
<li><p><strong>存储型 XSS</strong>:</p>
<ul>
<li>恶意脚本被永久地存储在目标服务器上（如数据库、消息论坛、访客留言等），当用户访问含有恶意脚本的页面时，脚本就会执行。</li>
</ul>
</li>
<li><p><strong>反射型 XSS</strong>:</p>
<ul>
<li>恶意脚本作为请求的一部分发送给服务器，然后服务器将其作为响应的一部分返回，脚本在用户浏览器执行。这通常涉及到欺骗用户点击一个恶意链接。</li>
</ul>
</li>
<li><p><strong>DOM 型 XSS</strong>:</p>
<ul>
<li>通过恶意脚本修改页面的 DOM 结构实现的攻击，这种攻击完全在客户端进行，不涉及到服务器端的数据处理。</li>
</ul>
</li>
</ol>
<h3 id="如何防范-XSS-攻击？"><a href="#如何防范-XSS-攻击？" class="headerlink" title="如何防范 XSS 攻击？"></a>如何防范 XSS 攻击？</h3><ol>
<li><p><strong>转义输入内容</strong>:</p>
<ul>
<li>对用户输入的内容进行适当的转义处理，特别是在插入到 HTML 页面、JavaScript 代码或 URL 中时。例如，转义 HTML 特殊字符（如 <code>&lt;</code> 变为 <code>&amp;lt;</code>、<code>&gt;</code> 变为 <code>&amp;gt;</code>）。</li>
</ul>
</li>
<li><p><strong>使用内容安全策略（CSP）</strong>:</p>
<ul>
<li>实施内容安全策略（CSP）是防止 XSS 的一种有效方法。CSP 允许网站管理员定义哪些内容源是可信的，可以有效阻止恶意脚本的加载和执行。</li>
</ul>
</li>
<li><p><strong>验证和过滤输入</strong>:</p>
<ul>
<li>对所有用户输入进行严格的验证和过滤，确保输入的内容不包含恶意脚本。</li>
</ul>
</li>
<li><p><strong>使用 HTTP 的 Cookie <code>HttpOnly</code> 属性</strong>:</p>
<ul>
<li>将敏感的 cookie 标记为 <code>HttpOnly</code>，可以阻止 JavaScript 访问这些 cookie，从而减少某些类型的 XSS 攻击。</li>
</ul>
</li>
<li><p><strong>避免直接在 JavaScript 中嵌入用户输入</strong>:</p>
<ul>
<li>避免在 JavaScript 代码中直接使用用户输入的数据，特别是在构建动态 HTML 或执行其他动态操作时。</li>
</ul>
</li>
<li><p><strong>框架的内置 XSS 防护</strong>:</p>
<ul>
<li>许多现代的 Web 开发框架提供了自动的 XSS 防护。了解并正确使用这些框架的安全特性是非常重要的。</li>
</ul>
</li>
<li><p><strong>正则表达式过滤</strong>:</p>
<ul>
<li>使用正则表达式或其他方法过滤可能的攻击向量。</li>
</ul>
</li>
</ol>
<h2 id="git-flow"><a href="#git-flow" class="headerlink" title="git flow"></a>git flow</h2><p>Git Flow 是一种基于 Git 的分支管理策略，由 Vincent Driessen 在 2010 年提出。它定义了一组规范化的分支操作，旨在帮助团队更有效地进行版本控制和软件发布。Git Flow 中的主要分支包括：<code>master</code>、<code>develop</code>、<code>feature</code>、<code>release</code> 和 <code>hotfix</code> 分支。</p>
<h3 id="主要分支"><a href="#主要分支" class="headerlink" title="主要分支"></a>主要分支</h3><ol>
<li><p><strong>Main 分支</strong>:</p>
<ul>
<li>用于存储正式发布的历史。</li>
<li>每次在 main 分支上进行提交，都应该对应一个版本发布。</li>
</ul>
</li>
<li><p><strong>Develop 分支</strong>:</p>
<ul>
<li>开发分支，是为了开发新功能、改进和日常工作而设置的。</li>
<li>通常所有新功能都会首先合并到这个分支。</li>
</ul>
</li>
</ol>
<h3 id="辅助分支"><a href="#辅助分支" class="headerlink" title="辅助分支"></a>辅助分支</h3><ol>
<li><p><strong>Feature 分支</strong>:</p>
<ul>
<li>从 <code>develop</code> 分支派生出来。</li>
<li>用于开发新功能。</li>
<li>完成开发后，会合并回 <code>develop</code> 分支。</li>
<li>分支命名通常遵循 <code>feature/</code> 的模式。</li>
</ul>
</li>
<li><p><strong>Release 分支</strong>:</p>
<ul>
<li>从 <code>develop</code> 分支派生出来，用于准备即将发布的版本。</li>
<li>允许进行最后的调整（如 bug 修复、文档编写等）。</li>
<li>完成后，应该合并到 <code>main</code> 和 <code>develop</code> 分支。</li>
<li>分支命名通常遵循 <code>release/</code> 的模式。</li>
</ul>
</li>
<li><p><strong>Hotfix 分支</strong>:</p>
<ul>
<li>从 <code>main</code> 分支派生出来，用于修复生产环境中的紧急问题。</li>
<li>修复完成后，应该合并到 <code>main</code> 和 <code>develop</code> 分支。</li>
<li>分支命名通常遵循 <code>hotfix/</code> 的模式。</li>
</ul>
</li>
</ol>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol>
<li><p><strong>新功能开发</strong>:</p>
<ul>
<li>从 <code>develop</code> 分支创建新的 <code>feature</code> 分支。</li>
<li>完成开发后，将 <code>feature</code> 分支合并回 <code>develop</code>。</li>
</ul>
</li>
<li><p><strong>发布准备</strong>:</p>
<ul>
<li>当 <code>develop</code> 分支达到一个稳定点，从中创建一个 <code>release</code> 分支。</li>
<li>在 <code>release</code> 分支上完成最后的测试和修订。</li>
<li>完成后，将 <code>release</code> 分支合并到 <code>main</code> 和 <code>develop</code>。</li>
</ul>
</li>
<li><p><strong>紧急修复</strong>:</p>
<ul>
<li>当在生产版本中发现紧急问题时，从 <code>main</code> 分支创建 <code>hotfix</code> 分支。</li>
<li>完成修复后，将 <code>hotfix</code> 分支合并到 <code>main</code> 和 <code>develop</code>。</li>
</ul>
</li>
<li><p><strong>发布</strong>:</p>
<ul>
<li>在 <code>main</code> 分支上的每次合并都应该对应一个新的版本发布。</li>
</ul>
</li>
</ol>
<h3 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h3><ul>
<li><p><strong>优点</strong>:</p>
<ul>
<li>清晰定义了不同类型的分支和它们的用途。</li>
<li>适合大型项目和需要严格发布管理的场景。</li>
</ul>
</li>
<li><p><strong>缺点</strong>:</p>
<ul>
<li>流程相对复杂，可能不适合小团队或轻量级项目。</li>
<li>需要团队成员理解并遵循规定的流程。</li>
</ul>
</li>
</ul>
<h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p>中间人攻击（Man-in-the-Middle Attack，简称 MITM ）是一种常见的网络安全威胁，其中攻击者秘密地拦截并可能更改通信双方之间的通信。在这种攻击中，攻击者插入自己到受害者之间的通信过程，使受害者认为他们正在直接与预期的通信对象进行通信。</p>
<h3 id="如何进行中间人攻击"><a href="#如何进行中间人攻击" class="headerlink" title="如何进行中间人攻击"></a>如何进行中间人攻击</h3><ol>
<li><p><strong>拦截通信</strong>:</p>
<ul>
<li>攻击者首先需要找到一种方式拦截双方之间的通信。这可以通过多种方式实现，比如在无线网络中拦截 Wi-Fi 信号，或者在网络路由中插入恶意设备。</li>
</ul>
</li>
<li><p><strong>监听和&#x2F;或篡改数据</strong>:</p>
<ul>
<li>一旦通信被拦截，攻击者就能够监听通信内容，并且在必要时更改传输的数据。</li>
</ul>
</li>
<li><p><strong>伪装和欺骗</strong>:</p>
<ul>
<li>攻击者可能会伪装成通信的一方，向另一方发送消息。在受害者看来，这些消息看起来是从他们预期的通信对象发送的。</li>
</ul>
</li>
</ol>
<h3 id="常见的中间人攻击类型"><a href="#常见的中间人攻击类型" class="headerlink" title="常见的中间人攻击类型"></a>常见的中间人攻击类型</h3><ol>
<li><p><strong>电子邮件劫持</strong>:</p>
<ul>
<li>攻击者拦截并更改电子邮件内容。</li>
</ul>
</li>
<li><p><strong>Wi-Fi 欺骗</strong>:</p>
<ul>
<li>在公共 Wi-Fi 中，攻击者可以创建一个假冒的 Wi-Fi 热点，诱使用户连接，并拦截通过该网络的数据。</li>
</ul>
</li>
<li><p><strong>HTTPS 欺骗</strong>:</p>
<ul>
<li>攻击者通过伪造证书来拦截和解密 HTTPS 加密的通信。</li>
</ul>
</li>
<li><p><strong>DNS 劫持</strong>:</p>
<ul>
<li>攻击者篡改 DNS 服务器的响应，将用户重定向到恶意网站。</li>
</ul>
</li>
<li><p><strong>会话劫持</strong>:</p>
<ul>
<li>攻击者窃取用户的会话令牌，以获取对用户账户的访问权限。</li>
</ul>
</li>
</ol>
<h3 id="如何防范中间人攻击"><a href="#如何防范中间人攻击" class="headerlink" title="如何防范中间人攻击"></a>如何防范中间人攻击</h3><ol>
<li><p><strong>使用加密协议</strong>:</p>
<ul>
<li>使用 HTTPS、SSL&#x2F;TLS 等加密协议可以保护数据传输的安全。</li>
</ul>
</li>
<li><p><strong>验证证书</strong>:</p>
<ul>
<li>确保网站的证书是有效的，并且由可信的证书颁发机构签发。</li>
</ul>
</li>
<li><p><strong>VPN 使用</strong>:</p>
<ul>
<li>使用虚拟私人网络（VPN）可以在公共网络上提供加密的通信通道。</li>
</ul>
</li>
<li><p><strong>强化 Wi-Fi 安全</strong>:</p>
<ul>
<li>使用强密码和最新的 Wi-Fi 安全协议（如 WPA3）。</li>
</ul>
</li>
</ol>
<h2 id="单点登录-SSO"><a href="#单点登录-SSO" class="headerlink" title="单点登录 SSO"></a>单点登录 SSO</h2><h3 id="单点登录（SSO）的理解"><a href="#单点登录（SSO）的理解" class="headerlink" title="单点登录（SSO）的理解"></a>单点登录（SSO）的理解</h3><p>单点登录（Single Sign-On，简称 SSO）是一种身份验证服务，它允许用户使用一组登录凭证（例如用户名和密码）来访问多个应用程序。目的是通过减少用户需要记住的密码数量和登录次数，来提高用户体验和安全性。</p>
<h3 id="SSO-的工作原理"><a href="#SSO-的工作原理" class="headerlink" title="SSO 的工作原理"></a>SSO 的工作原理</h3><ol>
<li><p><strong>中央认证</strong>:</p>
<ul>
<li>在 SSO 系统中，存在一个中央认证服务器。用户首次尝试访问应用时，会被重定向到这个认证服务器。</li>
</ul>
</li>
<li><p><strong>身份验证</strong>:</p>
<ul>
<li>用户在认证服务器上输入登录凭证（如用户名和密码）。如果凭证有效，认证服务器会创建一个认证令牌（通常是一个临时的、加密的令牌）。</li>
</ul>
</li>
<li><p><strong>令牌颁发</strong>:</p>
<ul>
<li>认证服务器将令牌发放给用户，令牌表明用户已被验证。</li>
</ul>
</li>
<li><p><strong>访问应用</strong>:</p>
<ul>
<li>用户再次尝试访问原来的应用或其他应用时，会携带这个令牌。应用会向认证服务器验证令牌的有效性。</li>
</ul>
</li>
<li><p><strong>授权访问</strong>:</p>
<ul>
<li>如果认证服务器确认令牌有效，用户将被授权访问应用。这一过程对用户来说是透明的，无需再次输入登录凭证。</li>
</ul>
</li>
<li><p><strong>会话创建</strong>:</p>
<ul>
<li>每个应用会为用户创建一个会话，允许用户在不再输入凭证的情况下访问。</li>
</ul>
</li>
</ol>
<h3 id="SSO-的流程"><a href="#SSO-的流程" class="headerlink" title="SSO 的流程"></a>SSO 的流程</h3><ol>
<li><p><strong>登录请求</strong>:</p>
<ul>
<li>用户首次访问某个应用时，会被重定向到 SSO 的认证服务器。</li>
</ul>
</li>
<li><p><strong>输入凭证</strong>:</p>
<ul>
<li>用户在认证服务器上输入登录凭证。</li>
</ul>
</li>
<li><p><strong>身份验证</strong>:</p>
<ul>
<li>认证服务器验证用户凭证。如果验证成功，则生成认证令牌。</li>
</ul>
</li>
<li><p><strong>重定向回应用</strong>:</p>
<ul>
<li>用户携带令牌返回应用。</li>
</ul>
</li>
<li><p><strong>令牌验证</strong>:</p>
<ul>
<li>应用向认证服务器验证令牌的有效性。</li>
</ul>
</li>
<li><p><strong>授权与访问</strong>:</p>
<ul>
<li>一旦令牌被确认有效，应用将允许用户访问，用户无需再次登录。</li>
</ul>
</li>
<li><p><strong>访问其他应用</strong>:</p>
<ul>
<li>当用户访问其他集成了 SSO 的应用时，只需重复令牌验证步骤，无需再次登录。</li>
</ul>
</li>
</ol>
<h3 id="SSO-的优势和挑战"><a href="#SSO-的优势和挑战" class="headerlink" title="SSO 的优势和挑战"></a>SSO 的优势和挑战</h3><ul>
<li><p><strong>优势</strong>:</p>
<ul>
<li>提高用户体验：用户只需记住一套凭证。</li>
<li>增加安全性：减少密码泄露的风险，便于集中管理。</li>
<li>减少管理工作：为管理员提供集中的用户管理和审计。</li>
</ul>
</li>
<li><p><strong>挑战</strong>:</p>
<ul>
<li>集成复杂性：对现有系统进行 SSO 集成可能复杂。</li>
<li>单点故障：认证服务器出现问题可能导致所有应用不可用。</li>
<li>安全风险：如果认证服务器被攻破，所有关联应用都可能受到影响。</li>
</ul>
</li>
</ul>
<h2 id="TypeScript-interface-type"><a href="#TypeScript-interface-type" class="headerlink" title="TypeScript interface type"></a>TypeScript interface type</h2><h3 id="语法和功能"><a href="#语法和功能" class="headerlink" title="语法和功能"></a>语法和功能</h3><ol>
<li><p><strong>扩展方式</strong>:</p>
<ul>
<li><code>interface</code> 可以被扩展和实现（extends 和 implements）。这使得它们非常适合定义对象的形状或类的契约。</li>
<li><code>type</code> 可以通过交集（<code>&amp;</code>）来组合现有类型，但不能使用 <code>extends</code> 或 <code>implements</code>。这使得 <code>type</code> 更适合联合类型或特定函数的签名。</li>
</ul>
</li>
<li><p><strong>声明合并</strong>:</p>
<ul>
<li><code>interface</code> 支持声明合并，即同名的 <code>interface</code> 会被自动合并为一个。</li>
<li><code>type</code> 不支持声明合并。</li>
</ul>
</li>
</ol>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li><p><strong>Interface</strong>:</p>
<ul>
<li>当定义对象的结构或类的契约时，推荐使用 <code>interface</code>。尤其是在定义库的类型或外部 API 的类型定义时，<code>interface</code> 由于其可扩展性，更加合适。</li>
<li>示例：<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Employee</span> <span class="keyword">extends</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">salary</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>Type</strong>:</p>
<ul>
<li>当需要使用联合类型或元组类型时，或者你的类型不适合通过一个简单的接口来表示时，应该使用 <code>type</code>。</li>
<li>示例：<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Operation</span> = <span class="string">&#x27;add&#x27;</span> | <span class="string">&#x27;subtract&#x27;</span> | <span class="string">&#x27;multiply&#x27;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = [<span class="built_in">boolean</span>, <span class="built_in">string</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="性能考虑"><a href="#性能考虑" class="headerlink" title="性能考虑"></a>性能考虑</h3><ul>
<li>在大多数情况下，<code>interface</code> 和 <code>type</code> 在性能上没有显著差异。</li>
<li>但在某些大型项目中，<code>interface</code> 由于其声明合并的特性，可能会稍微提高编译速度。</li>
</ul>
<h3 id="兼容性和扩展性"><a href="#兼容性和扩展性" class="headerlink" title="兼容性和扩展性"></a>兼容性和扩展性</h3><ul>
<li><code>interface</code> 更适合在声明 API 或库的类型定义时使用，因为它们更容易在不同的代码库中被扩展和维护。</li>
<li><code>type</code> 由于其能够表达更复杂的类型组合，提供了更多的灵活性。</li>
</ul>
<h2 id="函数入参实现类型映射"><a href="#函数入参实现类型映射" class="headerlink" title="函数入参实现类型映射"></a>函数入参实现类型映射</h2><p>在 TypeScript 中，你可以使用高级类型特性来实现函数入参的类型映射。这主要涉及到泛型和条件类型的使用。以下是一些实现类型映射的方法：</p>
<h3 id="1-使用泛型"><a href="#1-使用泛型" class="headerlink" title="1. 使用泛型"></a>1. 使用泛型</h3><p>泛型允许你定义一个函数，它可以适用于多种类型而不仅仅是一个。你可以在函数定义时声明一个泛型类型参数，然后在函数体内或作为参数类型使用它。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> output = identity&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;myString&quot;</span>);  <span class="comment">// 输出类型为 &#x27;string&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>T</code> 是一个泛型类型变量，它捕获传递给 <code>identity</code> 的参数类型。这样，你就可以使用这个类型来保证函数的输入和输出类型是一致的。</p>
<h3 id="2-条件类型"><a href="#2-条件类型" class="headerlink" title="2. 条件类型"></a>2. 条件类型</h3><p>条件类型（Conditional Types）允许你根据类型关系创建更复杂的类型表达式。它们在类型映射中非常有用，特别是当你想根据输入类型生成不同的输出类型时。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TypeName</span>&lt;T&gt; =</span><br><span class="line">    T <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="string">&quot;string&quot;</span> :</span><br><span class="line">    T <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="string">&quot;number&quot;</span> :</span><br><span class="line">    T <span class="keyword">extends</span> <span class="built_in">boolean</span> ? <span class="string">&quot;boolean&quot;</span> :</span><br><span class="line">    T <span class="keyword">extends</span> <span class="literal">undefined</span> ? <span class="string">&quot;undefined&quot;</span> :</span><br><span class="line">    T <span class="keyword">extends</span> <span class="title class_">Function</span> ? <span class="string">&quot;function&quot;</span> :</span><br><span class="line">    <span class="string">&quot;object&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> typeOf&lt;T&gt;(<span class="attr">arg</span>: T): <span class="title class_">TypeName</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> arg <span class="keyword">as</span> <span class="title class_">TypeName</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="title function_">typeOf</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// str 类型为 &quot;string&quot;</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="title function_">typeOf</span>(<span class="number">123</span>);     <span class="comment">// num 类型为 &quot;number&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>TypeName</code> 是一个条件类型，它根据传入的类型 <code>T</code> 返回不同的字符串字面量类型。</p>
<h3 id="3-映射类型"><a href="#3-映射类型" class="headerlink" title="3. 映射类型"></a>3. 映射类型</h3><p>映射类型（Mapped Types）允许你根据旧类型创建新类型。它们通过对一个已知的类型的每个属性应用某种变换来工作。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ReadOnly</span>&lt;T&gt; = &#123; <span class="keyword">readonly</span> [K <span class="keyword">in</span> keyof T]: T[K] &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> freeze&lt;T&gt;(<span class="attr">obj</span>: T): <span class="title class_">ReadOnly</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">freeze</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> original = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> frozen = <span class="title function_">freeze</span>(original); <span class="comment">// frozen 类型为 ReadOnly&lt;&#123; a: number; b: number; &#125;&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>ReadOnly</code> 是一个映射类型，它将 <code>T</code> 的所有属性标记为 <code>readonly</code>。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>根据你的具体需求，你可以选择使用泛型、条件类型或映射类型来实现函数参数的类型映射。这些高级类型特性提供了强大的工具，可以帮助你创建灵活且类型安全的代码。</p>
<h2 id="HTTPS-工作原理"><a href="#HTTPS-工作原理" class="headerlink" title="HTTPS 工作原理"></a>HTTPS 工作原理</h2><p>HTTPS（全称为 Hyper Text Transfer Protocol Secure）是 HTTP 的安全版本。它主要通过 SSL&#x2F;TLS 协议来提供身份验证和加密通信，以保护数据在互联网上的传输。以下是 HTTPS 的主要工作原理：</p>
<h3 id="1-加密"><a href="#1-加密" class="headerlink" title="1. 加密"></a>1. 加密</h3><p>HTTPS 使用对称加密和非对称加密相结合的方式来保护数据传输的安全：</p>
<ul>
<li><strong>非对称加密</strong>：在建立连接阶段使用，用于安全地交换对称密钥。</li>
<li><strong>对称加密</strong>：在交换密钥之后，对传输的数据进行加密。</li>
</ul>
<h3 id="2-SSL-x2F-TLS-握手"><a href="#2-SSL-x2F-TLS-握手" class="headerlink" title="2. SSL&#x2F;TLS 握手"></a>2. SSL&#x2F;TLS 握手</h3><p>当你的浏览器连接到一个 HTTPS 网站时，会发生一个叫做 SSL&#x2F;TLS 握手的过程，它包括以下步骤：</p>
<ol>
<li><p><strong>客户端发送加密偏好</strong>：</p>
<ul>
<li>浏览器（客户端）向服务器发送一个“Client Hello”消息，其中包含支持的 SSL&#x2F;TLS 版本、加密算法选项等。</li>
</ul>
</li>
<li><p><strong>服务器响应</strong>：</p>
<ul>
<li>服务器选择一组最合适的加密算法和 SSL&#x2F;TLS 版本，并且发送一个“Server Hello”消息给客户端。同时，服务器还会发送它的公钥和证书。</li>
</ul>
</li>
<li><p><strong>验证服务器证书</strong>：</p>
<ul>
<li>客户端验证服务器的 SSL&#x2F;TLS 证书（通常是由第三方证书机构 CA 颁发的）。证书验证包括检查证书是否过期、是否被撤销，以及是否由可信的 CA 签发。</li>
</ul>
</li>
<li><p><strong>客户端响应</strong>：</p>
<ul>
<li>一旦验证了服务器的证书，客户端生成一个随机的对称加密密钥，并使用服务器的公钥加密这个密钥，然后发送给服务器。</li>
</ul>
</li>
<li><p><strong>服务器解密密钥</strong>：</p>
<ul>
<li>服务器使用其私钥解密客户端发送的对称密钥。</li>
</ul>
</li>
<li><p><strong>加密通信</strong>：</p>
<ul>
<li>从这一步开始，客户端和服务器使用对称密钥来加密通信数据，确保数据传输的安全性。</li>
</ul>
</li>
</ol>
<h3 id="3-安全通信"><a href="#3-安全通信" class="headerlink" title="3. 安全通信"></a>3. 安全通信</h3><p>一旦 SSL&#x2F;TLS 握手完成，客户端和服务器之间的通信就会使用对称加密保护。这意味着即使通信被拦截，没有密钥的第三方也无法解读通信内容。</p>
<h3 id="4-会话结束"><a href="#4-会话结束" class="headerlink" title="4. 会话结束"></a>4. 会话结束</h3><p>当通信结束时，会话密钥会被丢弃。如果用户再次访问服务器，将进行新的握手过程和密钥交换。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>HTTPS 通过结合使用对称和非对称加密，以及通过可信的 CA 验证服务器的身份，有效保护了数据传输的安全性。虽然 HTTPS 在性能上有一定的开销，但它显著提升了网络通信的安全性，对于保护敏感数据，如登录凭据、支付信息等，是非常重要的。</p>
<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>在网络通信中，端口的作用主要是区分同一台主机上的不同服务或进程。端口是一种数字标记，它与 IP 地址一起使用，以标识主机上运行的特定应用程序或服务的实例。端口位于 OSI 七层模型的传输层（第四层），该层还包括定义传输协议，如 TCP（传输控制协议）和 UDP（用户数据报协议）。</p>
<h3 id="端口的作用"><a href="#端口的作用" class="headerlink" title="端口的作用"></a>端口的作用</h3><ol>
<li><p><strong>区分服务</strong>:</p>
<ul>
<li>在一台主机上可能运行着多种网络服务，如 HTTP 服务器、FTP 服务器、邮件服务器等。端口用于区分这些服务，例如，HTTP 默认使用端口 80，而 FTP 默认使用端口 21。</li>
</ul>
</li>
<li><p><strong>通信管理</strong>:</p>
<ul>
<li>端口允许同一物理网络上的多个应用程序同时进行通信，每个应用程序都可以有自己的端口号。</li>
</ul>
</li>
<li><p><strong>连接指定</strong>:</p>
<ul>
<li>在一个网络连接中，一个端口号与一个 IP 地址组合在一起，可以精确地指定通信的发送方和接收方。</li>
</ul>
</li>
</ol>
<h2 id="ESLint-Prettier-Husky-Lint-Staged"><a href="#ESLint-Prettier-Husky-Lint-Staged" class="headerlink" title="ESLint Prettier Husky Lint-Staged"></a>ESLint Prettier Husky Lint-Staged</h2><p>这些工具是现代前端开发中常用的代码质量和风格一致性工具。它们各自扮演着不同的角色：</p>
<h3 id="1-ESLint"><a href="#1-ESLint" class="headerlink" title="1. ESLint"></a>1. ESLint</h3><ul>
<li><strong>用途</strong>：ESLint 是一个静态代码分析工具，用于识别 JavaScript 中的问题。它不仅能找出错误，还能检测出代码风格的问题，如不一致的缩进、未使用的变量等。</li>
<li><strong>特点</strong>：<ul>
<li>可配置性高，可以根据项目需求自定义规则。</li>
<li>可以集成到多数编辑器和构建过程中。</li>
<li>支持 ES6+、React、Vue 等现代 JavaScript 特性。</li>
</ul>
</li>
</ul>
<h3 id="2-Prettier"><a href="#2-Prettier" class="headerlink" title="2. Prettier"></a>2. Prettier</h3><ul>
<li><strong>用途</strong>：Prettier 是一个代码格式化工具，它支持多种语言和文件格式。它强制执行一致的代码风格，确保整个团队的代码看起来和感觉一致。</li>
<li><strong>特点</strong>：<ul>
<li>重点关注代码的外观。</li>
<li>支持 JavaScript、TypeScript、CSS、HTML 等多种语言。</li>
<li>与 ESLint 不同，Prettier 不会检查代码错误。</li>
</ul>
</li>
</ul>
<h3 id="3-Husky"><a href="#3-Husky" class="headerlink" title="3. Husky"></a>3. Husky</h3><ul>
<li><strong>用途</strong>：Husky 是一个用于创建 Git 钩子（hooks）的工具。它可以在执行诸如提交（commit）或推送（push）等 Git 操作时自动运行脚本。</li>
<li><strong>特点</strong>：<ul>
<li>常用于在提交代码前自动运行 Lint 或测试。</li>
<li>防止不符合标准或有问题的代码被提交到仓库。</li>
</ul>
</li>
</ul>
<h3 id="4-Lint-Staged"><a href="#4-Lint-Staged" class="headerlink" title="4. Lint-Staged"></a>4. Lint-Staged</h3><ul>
<li><strong>用途</strong>：Lint-Staged 是一个在 Git 暂存文件（即即将被提交的文件）上运行 Linters 或其他工具的工具。</li>
<li><strong>特点</strong>：<ul>
<li>结合 Husky 使用，只对即将提交的更改执行 Lint 操作，而不是整个项目。</li>
<li>提高了代码质量，确保提交的代码符合预定义的规则。</li>
</ul>
</li>
</ul>
<h3 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h3><p>这些工具常常一起使用，以提高代码质量和提升开发效率：</p>
<ul>
<li>使用 ESLint 来检测代码中的问题和不一致性。</li>
<li>使用 Prettier 来格式化代码，确保一致的风格。</li>
<li>使用 Husky 创建 Git 钩子，在代码提交前自动运行 Lint 和测试。</li>
<li>使用 Lint-Staged 确保只检查和格式化被修改并准备提交的文件，而不是整个代码库。</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>JavaScript 中的迭代器是一个对象，它定义了一个 <code>next()</code> 方法，返回一个包含 <code>done</code> 和 <code>value</code> 属性的对象。当 <code>done</code> 为 <code>true</code> 时，表示迭代器已经遍历完所有元素。</p>
<p>以下是一个简单的迭代器实现示例，它迭代一个数字数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createIterator</span>(<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">next</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> currentIndex &lt; array.<span class="property">length</span> ?</span><br><span class="line">                &#123; <span class="attr">value</span>: array[currentIndex++], <span class="attr">done</span>: <span class="literal">false</span> &#125; :</span><br><span class="line">                &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">const</span> myArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> myIterator = <span class="title function_">createIterator</span>(myArray);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myIterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myIterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myIterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myIterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>createIterator</code> 函数接收一个数组并返回一个迭代器。迭代器的 <code>next</code> 方法在每次被调用时返回数组的下一个元素，直到数组被完全遍历。</p>
<p>请注意，这个迭代器是手动实现的，用于展示迭代器的基本原理。在实际的 JavaScript 开发中，你通常可以使用 ES6 提供的内置迭代器，比如通过 <code>for...of</code> 循环、展开操作符 <code>...</code> 或 <code>Array.prototype.entries()</code> 方法等来遍历可迭代对象。</p>
<h2 id="防抖（Debouncing）"><a href="#防抖（Debouncing）" class="headerlink" title="防抖（Debouncing）"></a>防抖（Debouncing）</h2><p>防抖（Debouncing）是一种优化技术，用于确保一个函数在特定时间内不被频繁调用。它是通过在指定时间内延迟函数的执行来实现的。如果在这段延迟时间内再次触发该函数，那么原来的延迟调用会被取消，并重新开始计算延迟时间。这对于一些需要频繁触发但执行成本较高的操作（如窗口大小调整、输入框内容变化等）非常有用。</p>
<p>下面是一个简单的防抖函数的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">const</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">onResize</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;窗口大小变化了！&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> debouncedResize = <span class="title function_">debounce</span>(onResize, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, debouncedResize);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>debounce</code> 函数接受两个参数：一个要执行的函数 <code>func</code> 和延迟时间 <code>wait</code>。返回的函数会在调用后等待指定的 <code>wait</code> 毫秒数，然后执行 <code>func</code>。如果在这个等待时间内再次被调用，之前的等待就会被清除，并重新开始计时。</p>
<p>这个防抖函数的应用示例是窗口调整大小事件的处理函数 <code>onResize</code>。通过使用 <code>debounce</code>，我们可以确保在窗口调整大小的过程中，<code>onResize</code> 函数不会被频繁调用，而是在调整结束后的 500 毫秒才执行一次。</p>
<h2 id="js原型链和利用原型链实现集成"><a href="#js原型链和利用原型链实现集成" class="headerlink" title="js原型链和利用原型链实现集成"></a>js原型链和利用原型链实现集成</h2><p>在JavaScript中，原型链是实现继承的主要机制。每个对象都有一个内部链接到另一个对象，即其“原型”，该原型对象自身也有一个原型，以此类推，形成了一个“原型链”。当试图访问一个对象的属性或方法时，如果对象本身没有这个属性或方法，JavaScript引擎就会沿着原型链向上查找，直到找到该属性或方法或到达原型链的末端（<code>null</code>）。</p>
<h3 id="JavaScript的原型"><a href="#JavaScript的原型" class="headerlink" title="JavaScript的原型"></a>JavaScript的原型</h3><p>每个JavaScript对象在创建时都会关联另一个对象，这个关联的对象就是我们所说的“原型”。对象可以通过其原型继承属性和方法。在JavaScript中，几乎所有的对象都是<code>Object</code>的实例，它们在默认情况下都会继承<code>Object.prototype</code>的属性和方法，除非明确地将对象的原型设置为<code>null</code>。</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>原型链的基础是原型继承。每个构造函数都有一个<code>prototype</code>属性，指向一个对象，这个对象包含了可以由该构造函数的所有实例继承的属性和方法。当创建一个对象实例时（使用<code>new</code>操作符），这个实例内部的<code>[[Prototype]]</code>（或<code>__proto__</code>，虽然后者是非标准的，但在大多数浏览器中可以使用）会被赋值为构造函数的<code>prototype</code>对象。</p>
<p>当访问对象的一个属性或方法时，如果对象本身没有这个属性或方法，JavaScript会继续在对象的原型（即<code>__proto__</code>指向的对象）中查找，如果还没找到，就去原型的原型中查找，依此类推，直到找到该属性或方法，或者在原型链的末端（<code>Object.prototype.__proto__</code>，其值为<code>null</code>）停止查找。</p>
<h3 id="实现继承"><a href="#实现继承" class="headerlink" title="实现继承"></a>实现继承</h3><p>在JavaScript中，可以通过原型链来实现继承。这里是一个基本的例子，展示如何使用原型链实现继承：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="title class_">Animal</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name); <span class="comment">// 调用父类构造函数，继承属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// 设置Dog的原型为Animal的实例，继承方法</span></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Dog</span>; <span class="comment">// 修复构造函数指向</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bark</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Woof!&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myDog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Rex&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myDog.<span class="title function_">getName</span>()); <span class="comment">// 输出: Rex</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myDog.<span class="title function_">bark</span>()); <span class="comment">// 输出: Woof!</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Dog</code>继承自<code>Animal</code>。首先，通过<code>Animal.call(this, name)</code>继承属性。接着，通过<code>Dog.prototype = Object.create(Animal.prototype)</code>让<code>Dog</code>的原型指向<code>Animal</code>的原型的一个实例，从而继承<code>Animal</code>原型上的方法。最后，修复<code>Dog.prototype.constructor</code>指向，确保它指回<code>Dog</code>本身，而不是<code>Animal</code>。</p>
<p>通过这种方式，我们能够利用原型链在JavaScript中实现继承，让不同的对象共享方法，同时保持各自的属性。</p>
<h2 id="HTTP-amp-amp-TCP"><a href="#HTTP-amp-amp-TCP" class="headerlink" title="HTTP &amp;&amp; TCP"></a>HTTP &amp;&amp; TCP</h2><p>HTTP（超文本传输协议）和TCP（传输控制协议）是互联网中常用的两种协议，它们在网络通信中扮演着不同的角色。</p>
<h3 id="TCP（传输控制协议）"><a href="#TCP（传输控制协议）" class="headerlink" title="TCP（传输控制协议）"></a>TCP（传输控制协议）</h3><p>TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议。它的主要特点和功能包括：</p>
<ul>
<li><strong>面向连接</strong>：在数据传输开始之前，TCP会在两端建立一个稳定的连接，这一过程通常称为“三次握手”。</li>
<li><strong>可靠传输</strong>：TCP通过序列号、确认应答、重传机制等确保数据完整性和顺序性。即使在网络条件不佳的情况下，TCP也能保证数据包的正确传输。</li>
<li><strong>流量控制</strong>：TCP使用滑动窗口机制来控制发送方的数据传输速率，防止接收方因来不及处理而丢失数据。</li>
<li><strong>拥塞控制</strong>：TCP还有一系列拥塞控制算法，如慢启动、拥塞避免、快速重传和快速恢复，用以在整个网络中避免或控制拥塞情况。</li>
</ul>
<h3 id="HTTP（超文本传输协议）"><a href="#HTTP（超文本传输协议）" class="headerlink" title="HTTP（超文本传输协议）"></a>HTTP（超文本传输协议）</h3><p>HTTP是应用层的协议，用于在网络中传输超文本（如HTML文档）从Web服务器到本地浏览器。HTTP的主要特点包括：</p>
<ul>
<li><strong>无连接</strong>：HTTP协议自身是无状态的，意味着每次请求之间相互独立，服务器不会保留任何数据（状态）来关联两个请求。不过，现代Web应用通常使用Cookies等机制来维护状态。</li>
<li><strong>简单快速</strong>：客户向服务器请求服务时只需传送请求方法和路径。HTTP的简单性使得它非常快速。</li>
<li><strong>灵活</strong>：HTTP允许传输任意类型的数据对象，只需在头部字段中加入内容类型即可。</li>
<li><strong>无状态但可使用Cookie维持会话</strong>：虽然HTTP本身是无状态的，但引入Cookie后，可以在客户端保留状态信息，以支持诸如用户登录状态、购物车等功能。</li>
</ul>
<h3 id="关系和区别"><a href="#关系和区别" class="headerlink" title="关系和区别"></a>关系和区别</h3><ul>
<li><strong>层级关系</strong>：TCP位于传输层，为HTTP等应用层协议提供稳定可靠的数据传输服务。HTTP建立在TCP提供的连接基础上，HTTP的请求和响应过程都是通过TCP连接完成的。</li>
<li><strong>用途区别</strong>：TCP是一种通用的连接协议，提供可靠的数据传输功能，而HTTP专注于规范客户端和服务器之间的通信格式和规则，用于传输超文本等数据。</li>
</ul>
<p>简而言之，TCP为HTTP提供了可靠的传输基础，而HTTP定义了如何通过这种传输方式来交换超文本等信息。</p>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTPS（安全超文本传输协议）是HTTP的安全版本，在HTTP和TCP之间加入了SSL&#x2F;TLS协议层，用以加密数据传输。HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性，防止数据在传输过程中被窃听、篡改或伪造。</p>
<h3 id="HTTPS如何实现安全"><a href="#HTTPS如何实现安全" class="headerlink" title="HTTPS如何实现安全"></a>HTTPS如何实现安全</h3><ol>
<li><p><strong>加密</strong>：HTTPS使用对称加密和非对称加密相结合的方式来加密数据。在握手阶段，使用非对称加密算法交换对称密钥，一旦密钥交换成功，之后的通信就使用对称加密算法进行，这样既保证了加密的安全性，又提高了数据传输的效率。</p>
</li>
<li><p><strong>认证</strong>：HTTPS利用证书认证机构（CA）颁发的SSL&#x2F;TLS证书对服务器进行身份验证。这确保了客户端与真正的服务器建立连接，而不是被中间人攻击者所欺骗。当用户访问一个HTTPS网站时，浏览器会自动检查服务器的SSL证书是否由受信任的CA签发、是否已过期、是否被撤销，以及证书中的域名是否与正在访问的网站域名一致。</p>
</li>
<li><p><strong>数据完整性</strong>：通过消息摘要（如SHA）和消息认证码（MAC）等技术，HTTPS可以检测数据传输过程中是否被篡改。即使数据被截获，攻击者也无法不被察觉地修改数据，因为任何改动都会导致接收方验证失败。</p>
</li>
</ol>
<h3 id="HTTPS的工作流程"><a href="#HTTPS的工作流程" class="headerlink" title="HTTPS的工作流程"></a>HTTPS的工作流程</h3><ol>
<li><p><strong>客户端发送HTTPS请求</strong>：用户在浏览器中输入一个HTTPS网址，浏览器向服务器发起一个安全连接请求。</p>
</li>
<li><p><strong>服务器回应并提供证书</strong>：服务器将自己的SSL证书（包括公钥）发送给客户端。</p>
</li>
<li><p><strong>客户端验证证书</strong>：客户端验证证书的合法性，包括证书是否由受信任的CA签发、是否过期或撤销，以及证书的域名是否与网站匹配。</p>
</li>
<li><p><strong>密钥交换</strong>：一旦证书验证通过，客户端会生成一个随机的对称加密密钥（会话密钥），并使用服务器的公钥加密这个密钥，发送给服务器。</p>
</li>
<li><p><strong>服务器解密并建立加密会话</strong>：服务器使用自己的私钥解密接收到的会话密钥，然后双方便利用这个会话密钥进行对称加密通信。</p>
</li>
<li><p><strong>安全通信</strong>：此时，客户端和服务器间的通信都是加密的，第三方无法直接读取或篡改传输的数据。</p>
</li>
</ol>
<p>通过这种方式，HTTPS为网络通信提供了一层强大的安全保护，使得用户数据在互联网上的传输变得更加安全可靠。</p>
<h2 id="前端缓存技术"><a href="#前端缓存技术" class="headerlink" title="前端缓存技术"></a>前端缓存技术</h2><p>前端缓存技术是一种重要的性能优化手段，它可以减少服务器的负载，加快网页的加载速度，提升用户体验。前端缓存大体上可以分为两大类：HTTP缓存和浏览器存储。</p>
<h3 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h3><p>HTTP缓存利用的是HTTP头信息中的缓存控制指令来实现的，主要分为强缓存和协商缓存：</p>
<ol>
<li><p><strong>强缓存</strong>：浏览器不会向服务器发送请求，直接从缓存中读取资源。它主要通过<code>Cache-Control</code>的<code>max-age</code>指令和<code>Expires</code>头实现。如果缓存的资源还未过期，浏览器就会直接使用缓存的资源。</p>
</li>
<li><p><strong>协商缓存</strong>：浏览器会向服务器发送请求，询问资源是否有更新。主要通过<code>Last-Modified</code>&#x2F;<code>If-Modified-Since</code>和<code>ETag</code>&#x2F;<code>If-None-Match</code>这两对头信息来控制。如果服务器上的资源没有变化，服务器会返回304状态码，告诉浏览器可以从缓存中加载资源。</p>
</li>
</ol>
<h3 id="浏览器存储"><a href="#浏览器存储" class="headerlink" title="浏览器存储"></a>浏览器存储</h3><p>浏览器提供了几种客户端存储数据的方法，可以用于缓存更多类型的数据，包括应用程序的数据、用户信息等：</p>
<ol>
<li><p><strong>Cookie</strong>：最古老的客户端存储技术。由于大小限制（每个域名下约4KB）、每次HTTP请求都会携带Cookie等缺点，现在多用于存储识别用户身份的小块数据。</p>
</li>
<li><p><strong>Web Storage（本地存储）</strong>：包括<code>localStorage</code>和<code>sessionStorage</code>，提供更大的存储空间（约5MB），并且只在客户端进行数据的保存和访问。<code>localStorage</code>用于长期存储数据，浏览器关闭后数据不会被清除；<code>sessionStorage</code>的数据在页面会话结束时被清除（即浏览器关闭时）。</p>
</li>
<li><p><strong>IndexedDB</strong>：是一种低级API，用于客户端存储大量结构化数据。这个API提供丰富的查询功能，并能够创建和维护一个数据库。IndexedDB适合存储大量数据和进行复杂查询，存储空间比Web Storage大得多。</p>
</li>
<li><p><strong>Service Worker缓存</strong>：Service Workers提供了一个可编程的网络代理，在客户端浏览器背后，允许你控制页面上的网络请求。通过使用Service Workers，可以截取网络请求，从缓存中提供资源，即使在离线时也能加载页面。</p>
</li>
</ol>
<h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><ul>
<li><strong>可缓存性</strong>：决定哪些资源可以被缓存。</li>
<li><strong>过期机制</strong>：设置资源过期时间，控制缓存多久需要更新。</li>
<li><strong>缓存验证</strong>：检查缓存的资源是否仍然有效。</li>
<li><strong>重新验证</strong>：更新过期的缓存资源。</li>
</ul>
<p>前端缓存的合理应用能显著提高应用性能，降低延迟，减少服务器负担。开发者需要根据实际需求选择合适的缓存策略和技术。</p>
<h2 id="虚拟-dom"><a href="#虚拟-dom" class="headerlink" title="虚拟 dom"></a>虚拟 dom</h2><p>虚拟DOM（Virtual DOM）是一个编程概念，其中UI的状态被保留在内存中，通过一个轻量级的JS对象来表示，而不是直接与真实的DOM同步。当状态变化时，虚拟DOM提供了一种计算出最小变更的方法来更新真实DOM，这种机制旨在提高前端应用的性能和效率。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>虚拟DOM的工作原理可以分为三个主要步骤：</p>
<ol>
<li><p><strong>创建虚拟DOM树</strong>：应用的UI结构用JavaScript对象形式创建，这些对象结构构成了一个虚拟DOM树。相比于真实DOM操作，操作JavaScript对象要快得多。</p>
</li>
<li><p><strong>比较虚拟DOM树</strong>：当应用状态变化时，会创建一个新的虚拟DOM树。然后，新旧虚拟DOM树通过一个“差异对比”算法（diffing algorithm）进行比较，以确定实际发生变化的部分。这个过程称为“对比”。</p>
</li>
<li><p><strong>更新真实DOM</strong>：一旦找出变化的部分，这些最小的变更将应用于真实的DOM树上，从而使其与虚拟DOM的最新状态同步。这个过程称为“重绘”。</p>
</li>
</ol>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>虚拟DOM提供了几个关键优势：</p>
<ul>
<li><strong>性能提升</strong>：操作真实DOM是昂贵的（性能开销大），因为它涉及到浏览器的布局计算和重绘。虚拟DOM通过批量和最小化DOM操作减少这些开销，从而提高性能。</li>
<li><strong>跨平台</strong>：虚拟DOM不依赖真实DOM，可以在服务器、移动设备等环境下运行，实现跨平台应用。</li>
<li><strong>简化编程模型</strong>：开发者可以像操作普通JavaScript对象那样操作虚拟DOM，无需担心后台的复杂DOM操作和性能问题，简化了前端开发的复杂性。</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>React是最早采用虚拟DOM概念的前端库之一，它通过虚拟DOM来提升渲染性能。Vue和Angular等其他现代前端框架也采用了类似的机制来优化DOM操作和更新过程。</p>
<p>总之，虚拟DOM通过在JavaScript和真实DOM之间提供一个抽象层，使得前端开发更高效、更简单，并且能够提高应用的性能。</p>
<h2 id="MVC-MVVM"><a href="#MVC-MVVM" class="headerlink" title="MVC MVVM"></a>MVC MVVM</h2><p>React和Vue是目前最流行的前端JavaScript库和框架之一，它们分别采用了不同的架构模式——React通常与MVC（模型-视图-控制器）模式结合使用，而Vue则基于MVVM（模型-视图-视图模型）模式。理解这两种架构模式有助于深入理解React和Vue的设计理念及其在实际应用中的差异。</p>
<h3 id="React与MVC模式"><a href="#React与MVC模式" class="headerlink" title="React与MVC模式"></a>React与MVC模式</h3><p>React是一个用于构建用户界面的库，它主要关注视图层。在React应用中，可以将React视为MVC模式中的“V”（视图），而数据（模型）和逻辑（控制器）通常通过其他库或框架（如Redux、MobX等）来管理。</p>
<ul>
<li><strong>模型（Model）</strong>：代表应用的数据。在React中，模型通常是以状态（state）和属性（props）的形式存在。</li>
<li><strong>视图（View）</strong>：用户界面。React组件构成了应用的视图层，负责渲染数据模型到UI。</li>
<li><strong>控制器（Controller）</strong>：业务逻辑和数据操作。在React中，组件本身或使用Redux等状态管理库承担了部分控制器的角色，负责响应用户输入，处理事件，以及更新模型。</li>
</ul>
<p>React的特点是声明式编程和组件化结构，使得构建大型应用时能够保持高效的更新和渲染。</p>
<h3 id="Vue与MVVM模式"><a href="#Vue与MVVM模式" class="headerlink" title="Vue与MVVM模式"></a>Vue与MVVM模式</h3><p>Vue是一个渐进式JavaScript框架，设计上采用了MVVM模式，目的是通过数据绑定和DOM的抽象来简化开发者编写交互逻辑的复杂度。</p>
<ul>
<li><strong>模型（Model）</strong>：代表JavaScript对象中的数据。</li>
<li><strong>视图（View）</strong>：HTML模板，用户看到和与之交互的界面。</li>
<li><strong>视图模型（ViewModel）</strong>：Vue实例。Vue的核心是<code>ViewModel</code>，它是连接视图和数据的桥梁。通过响应式和双向数据绑定，<code>ViewModel</code>自动将数据模型的变更反映到视图上，同时将视图上的更改（如用户输入）同步回数据模型。</li>
</ul>
<p>Vue的MVVM模式使得开发者几乎不需要直接操作DOM，只需要关注数据的状态，框架会负责渲染和更新视图。</p>
<h3 id="比较-1"><a href="#比较-1" class="headerlink" title="比较"></a>比较</h3><ul>
<li><strong>数据绑定</strong>：Vue在MVVM模式下提供了双向数据绑定，即视图的变化能自动更新到数据模型，数据模型的更新也能即时反映到视图上。React则采用单向数据流，组件状态（state）更新后，会重新渲染组件和子组件。</li>
<li><strong>模板vs JSX</strong>：Vue使用基于HTML的模板语法，它使得定义组件的结构更加直观。React采用JSX，一个看起来类似HTML的JavaScript扩展，通过JSX可以在JavaScript中以声明方式描述UI组件。</li>
<li><strong>灵活性和学习曲线</strong>：React提供了更多的JavaScript表达能力，给开发者带来了更高的灵活性，但相应的学习成本也更高。Vue的学习曲线通常认为更平滑，尤其是对于那些熟悉HTML和JavaScript基础的开发者。</li>
</ul>
<p>两者都提供了高效的方式来构建现代Web应用，选择哪一个主要取决于项目需求、团队熟悉度和个人偏好。</p>
<h2 id="同源策略和跨域"><a href="#同源策略和跨域" class="headerlink" title="同源策略和跨域"></a>同源策略和跨域</h2><h3 id="为什么要有同源策略"><a href="#为什么要有同源策略" class="headerlink" title="为什么要有同源策略"></a>为什么要有同源策略</h3><p>同源策略（Same-Origin Policy）是一种约定，它是Web安全的基石。同源策略确保了来自不同源的文档或脚本，在没有明确授权的情况下，不能进行某些交互。这里的“源”指的是协议、域名和端口这三者的组合。同源策略的目的是为了保护用户的数据安全，防止恶意文档窃取数据、会话劫持等安全威胁。</p>
<p>如果没有同源策略，脚本可以无限制地访问跨域的文档和API，这将导致严重的安全问题。例如，恶意网站可能读取另一个网站上的敏感数据，或者在不知情的情况下代表用户执行操作。</p>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>跨域（Cross-Origin）是指在不同源之间进行资源共享或通信的行为。由于同源策略的限制，不同源的网页默认无法直接访问对方的资源。然而，在现代Web应用中，经常需要从不同的源加载资源或调用API，这就需要一些方法来安全地实现跨域请求。</p>
<h3 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h3><ol>
<li><p><strong>CORS（跨源资源共享）</strong>：CORS是一种机制，它允许服务器指定哪些源可以访问其资源。这是通过在HTTP响应头中设置<code>Access-Control-Allow-Origin</code>来实现的。如果服务器允许来自某个源的请求，它会在响应中包含这个源，浏览器接收到响应后会允许请求成功。</p>
</li>
<li><p><strong>JSONP（JSON with Padding）</strong>：JSONP是一种较老的技术，利用<code>&lt;script&gt;</code>标签没有跨域限制的特性来绕过同源策略。通过动态创建<code>&lt;script&gt;</code>标签来请求一个带有回调函数的URL，服务器响应该请求时会将数据作为参数传递给回调函数，从而实现跨域。JSONP只支持GET请求。</p>
</li>
<li><p><strong>代理服务器</strong>：在服务器端设置一个代理，前端发送请求到同源的服务器代理上，由代理服务器转发请求到目标服务器，并将响应返回给前端。这样，实际的跨域请求是在服务器端完成的，绕过了浏览器的同源策略限制。</p>
</li>
<li><p><strong>Web Sockets</strong>：Web Sockets提供了全双工的通信通道，它在建立连接时不受同源策略的限制。一旦建立了WebSocket连接，服务器和客户端就可以自由通信，不论它们的源是否相同。</p>
</li>
<li><p><strong>PostMessage</strong>：<code>window.postMessage</code>方法允许来自不同源的窗口进行安全的双向通信。它可以用于跨文档、多窗口、跨域消息传递。</p>
</li>
</ol>
<p>同源策略是为了保护用户信息安全而设计的，但通过上述方法，我们可以在确保安全的前提下，实现跨域资源共享和通信。</p>
<h2 id="vue3-computed-和-watch"><a href="#vue3-computed-和-watch" class="headerlink" title="vue3 computed 和 watch"></a>vue3 computed 和 watch</h2><p>Vue 3中的<code>computed</code>和<code>watch</code>是两种响应式特性，用于处理数据变化，但它们在用途、响应方式和实现机制上有所不同。理解这些差异有助于在实际开发中更合理地选择使用它们。</p>
<h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p><code>computed</code>属性用于声明基于响应式状态变化而变化的计算属性。它是基于它们的响应式依赖进行缓存的。只有当依赖项发生变化时，计算属性才会重新计算。这使得<code>computed</code>非常适合用于复杂逻辑的计算，特别是当这些计算操作依赖于响应式状态，并且这些状态变化不频繁时。</p>
<ul>
<li><strong>缓存</strong>：Vue会缓存<code>computed</code>属性的结果，只有当它依赖的响应式属性变化时，它才会重新计算。</li>
<li><strong>用途</strong>：适用于需要根据响应式数据计算得出新数据的场景。</li>
<li><strong>性能</strong>：由于缓存，当依赖数据没有变化时，访问<code>computed</code>属性不会重新进行计算，性能较好。</li>
</ul>
<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p><code>watch</code>用于观察Vue实例上的数据变化，然后执行相应的回调函数。与<code>computed</code>相比，<code>watch</code>更适合执行数据变化时的异步操作或较为复杂的业务逻辑，如数据请求或在数据变化时执行副作用。</p>
<ul>
<li><strong>无缓存</strong>：每当监听的数据变化时，<code>watch</code>都会执行回调函数。</li>
<li><strong>用途</strong>：适用于数据变化时需要执行异步操作或比较复杂的业务逻辑的场景。</li>
<li><strong>灵活性</strong>：<code>watch</code>提供了更多的配置选项，如立即执行、深度监听等。</li>
</ul>
<h3 id="主要区别-2"><a href="#主要区别-2" class="headerlink" title="主要区别"></a>主要区别</h3><ol>
<li><p><strong>设计目的</strong>：<code>computed</code>用于根据依赖的响应式数据计算新的结果，并且会根据依赖数据的变化自动更新。<code>watch</code>则用于监听响应式数据的变化，然后执行一些特定的回调函数，适合处理更复杂的业务逻辑或异步操作。</p>
</li>
<li><p><strong>缓存与重计算</strong>：<code>computed</code>是基于它们的响应式依赖进行缓存的，只有依赖项改变时才会重新计算。而<code>watch</code>每次监听的数据变化时都会执行回调，不涉及缓存。</p>
</li>
<li><p><strong>使用场景</strong>：当你需要基于一些数据动态计算新数据时，使用<code>computed</code>更合适。如果你需要在数据变化时执行异步操作或较为复杂的逻辑，使用<code>watch</code>会更加适合。</p>
</li>
</ol>
<p>总之，<code>computed</code>和<code>watch</code>都是Vue中处理数据变化的重要工具，选择使用哪一个取决于你的具体需求和场景。</p>
<h2 id="Vue3-生命周期"><a href="#Vue3-生命周期" class="headerlink" title="Vue3 生命周期"></a>Vue3 生命周期</h2><p>Vue 3引入了对Vue 2生命周期钩子的一些改变，包括新的命名方式以及Composition API下的生命周期函数。以下是Vue 3中的生命周期钩子，首先列出的是Vue 3中的新命名方式，括号内是Vue 2中对应的命名。</p>
<h3 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h3><ul>
<li>**<code>setup()</code>**：在Composition API中，这是一个新的生命周期钩子，它在组件创建之前执行，是声明响应式状态和生命周期钩子的地方。</li>
<li>**<code>beforeCreate</code>**（<code>beforeCreate</code>）：在实例初始化之后，数据观测（响应式）和事件&#x2F;生命周期钩子配置之前同步调用。</li>
<li>**<code>created</code>**（<code>created</code>）：在实例创建完成后被立即调用。在这一步，实例已完成数据观测（即响应式数据）、计算属性、方法、watch&#x2F;event回调的配置。</li>
<li>**<code>beforeMount</code>**（<code>beforeMount</code>）：在挂载开始之前被调用：相关的渲染函数首次被调用。</li>
<li>**<code>mounted</code>**（<code>mounted</code>）：在实例被挂载后调用。如果组件是函数式组件，那么它将不会有<code>mounted</code>函数。</li>
</ul>
<h3 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h3><ul>
<li>**<code>beforeUpdate</code>**（<code>beforeUpdate</code>）：在数据发生变化之后，DOM被重新渲染和更新之前调用，可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</li>
<li>**<code>updated</code>**（<code>updated</code>）：在数据更改导致的虚拟DOM重新渲染和打补丁之后调用。</li>
</ul>
<h3 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段"></a>卸载阶段</h3><ul>
<li>**<code>beforeUnmount</code>**（<code>beforeDestroy</code>）：在卸载组件实例之前调用。在这一步，实例仍然完全可用。</li>
<li>**<code>unmounted</code>**（<code>destroyed</code>）：在卸载组件实例之后调用。</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>**<code>activated</code>**（<code>activated</code>）：被<code>&lt;keep-alive&gt;</code>缓存的组件激活时调用。</li>
<li>**<code>deactivated</code>**（<code>deactivated</code>）：被<code>&lt;keep-alive&gt;</code>缓存的组件停用时调用。</li>
<li>**<code>errorCaptured</code>**（<code>errorCaptured</code>）：当捕获一个来自子孙组件的错误时被调用。</li>
</ul>
<h3 id="Composition-API生命周期钩子"><a href="#Composition-API生命周期钩子" class="headerlink" title="Composition API生命周期钩子"></a>Composition API生命周期钩子</h3><p>在Vue 3的Composition API中，生命周期钩子有对应的函数形式，允许在<code>setup()</code>函数中使用。这些是：</p>
<ul>
<li><code>onBeforeMount</code></li>
<li><code>onMounted</code></li>
<li><code>onBeforeUpdate</code></li>
<li><code>onUpdated</code></li>
<li><code>onBeforeUnmount</code></li>
<li><code>onUnmounted</code></li>
<li><code>onActivated</code></li>
<li><code>onDeactivated</code></li>
<li><code>onErrorCaptured</code></li>
</ul>
<p>使用这些函数可以使得在使用Composition API时，代码更加模块化和可重用。</p>
<h2 id="Vue-Diff-算法"><a href="#Vue-Diff-算法" class="headerlink" title="Vue Diff 算法"></a>Vue Diff 算法</h2><p>Diff算法是用来比较两个对象（如虚拟DOM树）并找出它们之间差异的算法。在前端框架中，比如React和Vue，Diff算法是实现高效更新DOM的关键。Diff算法的核心目标是尽可能高效地识别出由数据变化引起的具体DOM操作，从而最小化真实DOM的操作次数，提升应用的性能。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol>
<li><p><strong>树比较</strong>：由于直接对真实DOM树进行比较成本过高，现代前端框架使用虚拟DOM技术，即用JavaScript对象来表示DOM树，然后在这些JavaScript对象上应用Diff算法。</p>
</li>
<li><p><strong>层级比较</strong>：大多数Diff算法只在同一层级上进行比较，忽略跨层级的DOM元素移动，因为跨层级移动的情况相对较少，而且增加跨层级的比较会极大地提高算法的复杂度。</p>
</li>
</ol>
<h3 id="React中的Diff算法"><a href="#React中的Diff算法" class="headerlink" title="React中的Diff算法"></a>React中的Diff算法</h3><p>React的Diff算法可以分为三个层次的比较：</p>
<ol>
<li><strong>树的Diff</strong>：比较两棵树时，首先比较根节点。如果根节点的类型不同，那么整棵树将会被替换。</li>
<li><strong>组件的Diff</strong>：当比较两个相同类型的React组件时，会比较它们的属性（props），然后更新必要的部分。</li>
<li><strong>元素列表的Diff</strong>：处理列表元素时，React使用了一种称为“Reconciliation”的过程。在这个过程中，React会尝试重用DOM节点而非创建新的节点，以此来提高性能。为了识别哪些元素是新的，哪些被移动了位置，React推荐使用唯一的<code>key</code>属性来标识每个元素。</li>
</ol>
<h3 id="Vue中的Diff算法"><a href="#Vue中的Diff算法" class="headerlink" title="Vue中的Diff算法"></a>Vue中的Diff算法</h3><p>Vue的Diff算法同样基于虚拟DOM，它的实现有以下特点：</p>
<ol>
<li><strong>双端比较</strong>：Vue在比较新旧虚拟DOM节点时，采用了双端比较的策略。它同时从虚拟DOM树的两端（头部和尾部）开始比较，根据比较结果逐步向中间靠拢，这种方式可以更有效地识别节点的增加、删除和移动。</li>
<li><strong>Patch过程</strong>：在确定需要更新的节点后，Vue会进行Patch操作，即应用差异，更新真实DOM。Patch过程中会尽可能重用DOM节点，以减少DOM操作。</li>
</ol>
<h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><ol>
<li><strong>添加与删除</strong>：如果新的虚拟DOM树中有新添加的节点，那么在真实DOM中相应地添加新节点；如果有节点在旧树中而不在新树中，则在真实DOM中删除这些节点。</li>
<li><strong>更新</strong>：如果节点在两棵树中都存在，但是节点的某些属性或子节点有变化，那么仅更新有变化的部分。</li>
<li><strong>列表对比</strong>：使用“key”来优化列表的对比过程，识别哪些元素是新的，哪些元素仅仅是移动了位置。</li>
</ol>
<p>Diff算法是现代前端框架中非常关键的一个环节，它直接关系到应用的性能和用户体验。尽管具体实现可能有所不同，但基本原理和目标是一致的：通过智能的算法最小化对真实DOM的操作，从而提高效率。</p>
<h2 id="HTTP-版本"><a href="#HTTP-版本" class="headerlink" title="HTTP 版本"></a>HTTP 版本</h2><p>HTTP（超文本传输协议）是互联网上应用最为广泛的协议之一，它定义了客户端与服务器之间交换信息的格式和规则。自从1991年HTTP&#x2F;0.9首次提出以来，HTTP经历了多次重要的更新和改进。以下是HTTP的主要版本及其特点：</p>
<h3 id="HTTP-x2F-0-9"><a href="#HTTP-x2F-0-9" class="headerlink" title="HTTP&#x2F;0.9"></a>HTTP&#x2F;0.9</h3><ul>
<li><strong>发布时间</strong>：1991年。</li>
<li><strong>特点</strong>：<ul>
<li>只有一个命令GET。</li>
<li>没有HEADER等描述数据的信息。</li>
<li>服务器发送完毕，就关闭TCP连接。</li>
</ul>
</li>
</ul>
<h3 id="HTTP-x2F-1-0"><a href="#HTTP-x2F-1-0" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h3><ul>
<li><strong>发布时间</strong>：1996年，正式规范化为RFC 1945。</li>
<li><strong>特点</strong>：<ul>
<li>引入了HEAD、POST等新方法。</li>
<li>引入了状态码，描述请求的处理结果。</li>
<li>支持多种类型的MIME类型。</li>
<li>引入了HTTP Header，允许传输关于请求和响应的额外信息。</li>
</ul>
</li>
</ul>
<h3 id="HTTP-x2F-1-1"><a href="#HTTP-x2F-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h3><ul>
<li><strong>发布时间</strong>：1997年，定义在RFC 2068中，后经过修订发布为RFC 2616（1999年），最新修订版为RFC 7230-RFC 7235（2014年）。</li>
<li><strong>特点</strong>：<ul>
<li>支持持久连接（Connection: keep-alive），提高了传输效率。</li>
<li>引入了更多的缓存控制策略（如ETag，Cache-Control）。</li>
<li>引入了分块传输编码，允许发送方在完全生成响应内容之前就开始发送响应。</li>
<li>引入了虚拟主机的概念，允许一台服务器上托管多个域名。</li>
<li>支持管道化的请求处理，进一步优化性能。</li>
</ul>
</li>
</ul>
<h3 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h3><ul>
<li><strong>发布时间</strong>：2015年，定义在RFC 7540。</li>
<li><strong>特点</strong>：<ul>
<li>所有数据包为二进制格式，提高了解析效率。</li>
<li>多路复用（Multiplexing），一个连接中可以并行交换多个请求和响应，消除了因多个连接造成的延迟。</li>
<li>服务器推送（Server Push），服务器可以对一个客户端请求发送多个响应。</li>
<li>头信息压缩，减少了传输数据的体积。</li>
</ul>
</li>
</ul>
<h3 id="HTTP-x2F-3"><a href="#HTTP-x2F-3" class="headerlink" title="HTTP&#x2F;3"></a>HTTP&#x2F;3</h3><ul>
<li><strong>发布时间</strong>：尚在开发中，草案阶段。</li>
<li><strong>特点</strong>：<ul>
<li>基于QUIC协议，QUIC是一种基于UDP的传输层协议，解决了TCP的头阻塞问题，减少了连接和传输延迟。</li>
<li>继续使用和HTTP&#x2F;2相似的高级功能，如头信息压缩、服务器推送等。</li>
</ul>
</li>
</ul>
<p>随着网络技术的发展，HTTP协议不断进化以适应新的需求和挑战。从简单的请求&#x2F;响应模型到现在的复杂多功能性协议，HTTP已经成为现代网络不可或缺的部分。</p>
<h2 id="视频传输"><a href="#视频传输" class="headerlink" title="视频传输"></a>视频传输</h2><p>为视频内容网站（如Netflix）设计前端视频传输系统时，需要考虑多个关键因素，以确保高效、稳定且具有良好用户体验的视频流服务。这些设计考虑包括但不限于内容的适配性、网络状况的应对、安全性、兼容性和用户体验。</p>
<h3 id="1-内容适配与自适应流"><a href="#1-内容适配与自适应流" class="headerlink" title="1. 内容适配与自适应流"></a>1. 内容适配与自适应流</h3><ul>
<li><strong>自适应比特率流</strong>：采用HLS（HTTP Live Streaming）或DASH（Dynamic Adaptive Streaming over HTTP）协议，根据用户的网络状况动态调整视频质量。这可以最小化缓冲延迟，提供平滑的播放体验。</li>
<li><strong>预处理和多比特率编码</strong>：视频内容应预先被转码成多个不同比特率的版本。这样，自适应流技术可以在多个版本之间切换，选择最适合当前网络条件的版本。</li>
</ul>
<h3 id="2-网络性能优化"><a href="#2-网络性能优化" class="headerlink" title="2. 网络性能优化"></a>2. 网络性能优化</h3><ul>
<li><strong>CDN（内容分发网络）</strong>：利用CDN可以将视频内容缓存于世界各地的边缘服务器，减少传输距离，降低延迟，提高加载速度。</li>
<li><strong>数据预加载</strong>：智能地预加载视频的下一部分内容，以减少播放时的等待时间。</li>
<li><strong>网络状况检测</strong>：实时监测用户的网络状况，并据此调整视频流的质量。</li>
</ul>
<h3 id="3-安全性"><a href="#3-安全性" class="headerlink" title="3. 安全性"></a>3. 安全性</h3><ul>
<li><strong>传输加密</strong>：使用HTTPS保证数据在传输过程中的安全性，防止中间人攻击。</li>
<li><strong>DRM（数字版权管理）</strong>：实现DRM保护，以防止内容的未经授权的访问和复制。常见的DRM解决方案包括Widevine（Google）、PlayReady（Microsoft）和FairPlay Streaming（Apple）。</li>
</ul>
<h3 id="4-兼容性与跨平台支持"><a href="#4-兼容性与跨平台支持" class="headerlink" title="4. 兼容性与跨平台支持"></a>4. 兼容性与跨平台支持</h3><ul>
<li><strong>广泛支持的视频格式</strong>：选择广泛支持的视频编码格式（如H.264&#x2F;AVC）确保视频内容能在多数设备和浏览器上播放。</li>
<li><strong>响应式设计</strong>：确保视频播放界面在不同大小和分辨率的屏幕上均能良好显示，提供响应式的用户界面。</li>
</ul>
<h3 id="5-用户体验"><a href="#5-用户体验" class="headerlink" title="5. 用户体验"></a>5. 用户体验</h3><ul>
<li><strong>用户界面设计</strong>：简洁直观的播放控制、清晰的质量选择、无缝的全屏切换等，都能显著提升用户体验。</li>
<li><strong>错误处理和反馈</strong>：优雅地处理播放错误，如网络问题或格式不支持等，并给予用户明确的错误信息和建议的操作。</li>
</ul>
<h3 id="6-分析与优化"><a href="#6-分析与优化" class="headerlink" title="6. 分析与优化"></a>6. 分析与优化</h3><ul>
<li><strong>用户行为分析</strong>：收集用户播放行为数据，如播放质量、缓冲次数、观看时长等，分析这些数据来进一步优化视频流服务。</li>
<li><strong>A&#x2F;B测试</strong>：通过A&#x2F;B测试不同的播放策略或用户界面设计，找出最优化的方案。</li>
</ul>
<p>视频内容网站的前端视频传输设计是一项复杂的工程，需要跨多个领域的技术协同工作，从而实现高效、稳定且用户友好的视频流服务。</p>
<h2 id="Vue-Loader"><a href="#Vue-Loader" class="headerlink" title="Vue Loader"></a>Vue Loader</h2><p>Vue Loader 是一个webpack的loader，它允许你以一种名为单文件组件（Single-File Components，SFCs）的格式来编写Vue组件。这种文件通常保存为<code>.vue</code>后缀，包含三种类型的顶级语言块 <code>&lt;template&gt;</code>、<code>&lt;script&gt;</code>和<code>&lt;style&gt;</code>，分别用于标记组件的结构、逻辑和样式。</p>
<h3 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h3><ul>
<li><strong>模块化的单文件组件</strong>：每个<code>.vue</code>文件包含了一个组件的完整定义，包括它的HTML模板、JavaScript逻辑和CSS样式。这种模块化方式使得组件更加整洁和可维护。</li>
<li><strong>预处理支持</strong>：Vue Loader 支持使用预处理器，如Pug（HTML模板预处理器）、Babel（JavaScript编译器）或Sass（CSS预处理器）。这意味着你可以在<code>.vue</code>文件中直接使用这些工具扩展的语言特性。</li>
<li><strong>作用域CSS</strong>：通过在<code>&lt;style&gt;</code>标签中添加<code>scoped</code>属性，Vue Loader 可以自动将CSS作用域应用到当前组件，避免样式冲突。</li>
<li><strong>热重载</strong>：在开发过程中，当<code>.vue</code>文件中的组件发生变化时，Vue Loader 支持热重载，即无需刷新页面就可以更新组件。</li>
</ul>
<h3 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h3><p>当webpack遇到<code>.vue</code>文件时，Vue Loader会解析文件，并把每个语言块（如<code>&lt;template&gt;</code>、<code>&lt;script&gt;</code>、<code>&lt;style&gt;</code>）提取出来。然后，根据配置，它会使用相应的loader来处理这些块。例如，<code>&lt;template&gt;</code>块可能会通过<code>html-loader</code>处理，<code>&lt;script&gt;</code>块通过<code>babel-loader</code>，而<code>&lt;style&gt;</code>块通过<code>css-loader</code>和<code>style-loader</code>。</p>
<h3 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h3><p>在webpack配置文件中，你需要添加Vue Loader及其插件<code>VueLoaderPlugin</code>的配置，示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">VueLoaderPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;vue-loader&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;vue-loader&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 配置其他loader...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// 确保引入这个插件来处理.vue文件</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">VueLoaderPlugin</span>()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Vue Loader 为Vue.js开发提供了强大的支持，它让开发者能够以单文件组件的形式高效地开发Vue应用。通过与webpack的紧密集成，Vue Loader使得项目的构建过程既灵活又高效。</p>
<h2 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h2><p>Sass（Syntactically Awesome Style Sheets）是一种强大的CSS扩展语言，它使得CSS的使用变得更加高效和有趣。Sass提供了许多高级功能，如变量、嵌套规则、混入（Mixins）、继承、模块等，这些功能可以帮助开发者以更结构化的方式编写可重用且易于维护的样式代码。</p>
<h3 id="主要特性-1"><a href="#主要特性-1" class="headerlink" title="主要特性"></a>主要特性</h3><ol>
<li><p><strong>变量</strong>：允许你定义样式的一些通用属性（如颜色、字体大小等），然后在整个样式表中复用它们。这样，在需要修改样式时，只需更改变量的值即可。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$primary-color</span>: <span class="number">#333</span>;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$primary-color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>嵌套规则</strong>：Sass允许你将CSS规则嵌套在另一个规则内部，这样可以减少重复代码，使结构更清晰。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">li</span> &#123; <span class="attribute">display</span>: inline-block; &#125;</span><br><span class="line">  <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">6px</span> <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>混入（Mixins）</strong>：它们是可以重用的代码块，可以接受参数，从而让你能够定义一组样式并在多处使用，还可以根据参数定制样式。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> border-radius(<span class="variable">$radius</span>) &#123;</span><br><span class="line">  -webkit-<span class="attribute">border-radius</span>: <span class="variable">$radius</span>;</span><br><span class="line">     -moz-<span class="attribute">border-radius</span>: <span class="variable">$radius</span>;</span><br><span class="line">      -ms-<span class="attribute">border-radius</span>: <span class="variable">$radius</span>;</span><br><span class="line">          <span class="attribute">border-radius</span>: <span class="variable">$radius</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123; <span class="keyword">@include</span> border-radius(<span class="number">10px</span>); &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>模块</strong>：Sass支持模块化，允许将样式分割到不同的文件中，然后通过<code>@use</code>和<code>@forward</code>规则导入和使用。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _variables.scss</span></span><br><span class="line"><span class="variable">$primary-color</span>: <span class="number">#333</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.scss</span></span><br><span class="line"><span class="keyword">@use</span> <span class="string">&#x27;variables&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: variables.<span class="variable">$primary-color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>继承</strong>：通过<code>@extend</code>指令，一个选择器可以继承另一个选择器的样式，有助于避免代码重复。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.message</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.success-message</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> .message;</span><br><span class="line">  <span class="attribute">border-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="使用Sass"><a href="#使用Sass" class="headerlink" title="使用Sass"></a>使用Sass</h3><p>Sass支持两种格式：SCSS（Sassy CSS）和缩进语法（原Sass语法）。SCSS的语法完全兼容CSS，而缩进语法是一种简化的语法风格。大多数情况下，开发者倾向于使用SCSS因为它更接近原生CSS。</p>
<p>要使用Sass，你需要将Sass文件编译成标准的CSS。这可以通过Sass的命令行工具、Webpack等模块打包工具，或是其他构建工具和任务运行器（如Gulp或Grunt）来完成。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>Sass通过提供一套丰富的语言特性，极大地增强了CSS的能力，帮助开发者以更快、更模块化的方式构建复杂的样式表。随着前端项目的不断增长和复杂化，Sass成为了现代Web开发工具箱中不可或缺的一部分。</p>
<h2 id="小程序-x2F-Web-鉴权"><a href="#小程序-x2F-Web-鉴权" class="headerlink" title="小程序&#x2F; Web 鉴权"></a>小程序&#x2F; Web 鉴权</h2><p>在小程序和Web项目中实现鉴权，通常涉及到用户的身份认证和授权。OpenID和JWT（JSON Web Tokens）是两种常用的技术用于处理这些问题。下面是如何在小程序和Web项目中使用它们进行鉴权的概述：</p>
<h3 id="OpenID"><a href="#OpenID" class="headerlink" title="OpenID"></a>OpenID</h3><p>OpenID主要用于身份认证。在小程序中，特别是微信小程序，OpenID用来唯一标识一个用户。当用户第一次登录小程序时，后端会通过微信提供的API获取用户的OpenID，并将其与用户的账号绑定。这样，以后用户每次请求时，只需要通过OpenID就能识别出用户身份。</p>
<p><strong>使用OpenID的步骤</strong>：</p>
<ol>
<li><strong>用户登录</strong>：用户在小程序中登录，小程序通过微信提供的接口获取到用户的code。</li>
<li><strong>获取OpenID</strong>：小程序将code发送到服务器，服务器再调用微信的API换取用户的OpenID。</li>
<li><strong>创建&#x2F;查询用户信息</strong>：服务器根据OpenID创建新用户或查询现有用户信息，并生成一个会话或令牌（如JWT）返回给小程序。</li>
</ol>
<h3 id="JWT（JSON-Web-Tokens）"><a href="#JWT（JSON-Web-Tokens）" class="headerlink" title="JWT（JSON Web Tokens）"></a>JWT（JSON Web Tokens）</h3><p>JWT是一种开放标准（RFC 7519），用于在网络应用环境间安全地传递声明（如认证信息）。JWT可以用于任何Web应用或服务的身份验证和信息交换，它使得从客户端到服务器的单点登录（SSO）变得简单。</p>
<p><strong>使用JWT的步骤</strong>：</p>
<ol>
<li><strong>用户登录</strong>：用户在Web页面或小程序中提交登录表单。</li>
<li><strong>生成JWT</strong>：服务器验证用户的登录信息（如用户名和密码）。如果认证成功，服务器会生成一个JWT，其中包含用户信息和签名，并将这个JWT返回给客户端。</li>
<li><strong>客户端存储JWT</strong>：客户端收到JWT后，会将其存储在本地（如localStorage、sessionStorage或小程序的storage中）。</li>
<li><strong>发送请求</strong>：客户端每次向服务器发送请求时，都会在HTTP头中携带这个JWT。</li>
<li><strong>服务器验证JWT</strong>：服务器接收到请求后，会验证JWT的签名。如果验证成功，服务器会处理该请求，并根据JWT中的信息提供相应的服务。</li>
</ol>
<h3 id="鉴权流程"><a href="#鉴权流程" class="headerlink" title="鉴权流程"></a>鉴权流程</h3><ol>
<li><strong>身份认证</strong>：用户登录系统，系统验证用户身份后发放一个JWT作为身份凭证。</li>
<li><strong>身份鉴权</strong>：用户在后续的请求中携带JWT，系统通过验证JWT来确认用户身份和权限。</li>
</ol>
<h3 id="安全性注意事项"><a href="#安全性注意事项" class="headerlink" title="安全性注意事项"></a>安全性注意事项</h3><ul>
<li><strong>HTTPS</strong>：确保所有通信都通过HTTPS进行，以防止中间人攻击。</li>
<li><strong>存储安全</strong>：在客户端安全地存储JWT，避免XSS攻击。</li>
<li><strong>令牌过期</strong>：为JWT设置合理的过期时间，减少令牌被滥用的风险。</li>
<li><strong>签名和加密</strong>：使用强签名算法，必要时对敏感信息进行加密。</li>
</ul>
<p>通过结合使用OpenID和JWT，可以在小程序和Web项目中实现安全可靠的鉴权机制，保障用户数据的安全和应用的安全性。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/wechat.png" alt="moke 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202309041556302.jpg" alt="moke 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>moke
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://csumoke.com/2023/12/07/note-interview/" title="前端实习面试问题准备">https://csumoke.com/2023/12/07/note-interview/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/01/10/software-test-review/" rel="prev" title="软件测试复习">
                  <i class="fa fa-chevron-left"></i> 软件测试复习
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/10/26/vscode-PR/" rel="next" title="VSCode 下的 PR 流程">
                  VSCode 下的 PR 流程 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">moke</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">118k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">7:09</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9taXN0Lw==">NexT.Mist</span> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL2plcnJ5NzY1" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.0/jquery.min.js" integrity="sha256-2Pmvv0kuTBOenSvLm6bvfBSSHrUJ+3A7x6P5Ebd07/g=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>



  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":false,"archive":false,"delay":true,"timeout":3000,"priority":true,"url":"https://csumoke.com/2023/12/07/note-interview/"}</script>
  <script src="/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"csumoke","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

<script>(function (w, d, s, id) {
            if (typeof (w.webpushr) !== 'undefined') return; w.webpushr = w.webpushr || function () { (w.webpushr.q = w.webpushr.q || []).push(arguments) }; var js, fjs = d.getElementsByTagName(s)[0]; js = d.createElement(s); js.id = id; js.async = 1; js.src = "https://cdn.webpushr.com/app.min.js";fjs.parentNode.appendChild(js);}(window, document, 'script', 'webpushr-jssdk'));webpushr('setup', { 'key': 'BAs1f6Lvs7ZICIjDSN6zmGgXIS0HES-FCnkp3hYWJ0mxRWyJ0KbPvK_ggwuXiBcOu2JyKyfTjf5XuSIMCHShK_w' });</script></body>
</html>
