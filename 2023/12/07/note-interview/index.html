<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"csumoke.com","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.17.1","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"bookmark":{"enable":true,"color":"#0080ff","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":true,"nav":null,"activeClass":"disqus"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>



<link rel="canonical" href="https://csumoke.com/2023/12/07/note-interview/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://csumoke.com/2023/12/07/note-interview/","path":"2023/12/07/note-interview/","title":"前端实习面试问题准备"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>前端实习面试问题准备 | Voilà</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-GC00V96X32"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-GC00V96X32","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Voilà</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">moke's blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8%E8%BF%9B%E5%BA%A6%E6%9D%A1"><span class="nav-number">1.1.</span> <span class="nav-text">视频播放器进度条</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Node-js-%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E4%B8%8D%E4%B8%AD%E6%96%AD%EF%BC%9F"><span class="nav-number">1.2.</span> <span class="nav-text">Node.js 单线程如何保证线程不中断？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#websocket-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">1.3.</span> <span class="nav-text">websocket 建立连接的过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#websocket%E5%92%8C%E9%95%BF%E8%BD%AE%E8%AF%A2%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.</span> <span class="nav-text">websocket和长轮询的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#WebSocket"><span class="nav-number">1.4.1.</span> <span class="nav-text">WebSocket</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%95%BF%E8%BD%AE%E8%AF%A2"><span class="nav-number">1.4.2.</span> <span class="nav-text">长轮询</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="nav-number">1.5.</span> <span class="nav-text">tcp 如何保证可靠性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E7%AE%97%E6%B3%95"><span class="nav-number">1.6.</span> <span class="nav-text">拥塞算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">1.7.</span> <span class="nav-text">三次握手</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9ASYN"><span class="nav-number">1.7.1.</span> <span class="nav-text">第一次握手：SYN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9ASYN-ACK"><span class="nav-number">1.7.2.</span> <span class="nav-text">第二次握手：SYN-ACK</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9AACK"><span class="nav-number">1.7.3.</span> <span class="nav-text">第三次握手：ACK</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F"><span class="nav-number">1.7.4.</span> <span class="nav-text">为什么需要三次握手？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http-%E5%92%8C-tcp-%E7%9A%84-keep-alive-%E5%8C%BA%E5%88%AB"><span class="nav-number">1.8.</span> <span class="nav-text">http 和 tcp 的 keep-alive 区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-Keep-Alive"><span class="nav-number">1.8.1.</span> <span class="nav-text">HTTP Keep-Alive</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-Keep-Alive"><span class="nav-number">1.8.2.</span> <span class="nav-text">TCP Keep-Alive</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93"><span class="nav-number">1.8.3.</span> <span class="nav-text">区别总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#js-%E9%97%AD%E5%8C%85%E3%80%81%E5%8E%9F%E5%9E%8B%E3%80%81%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.9.</span> <span class="nav-text">js 闭包、原型、事件循环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AD%E5%8C%85%EF%BC%88Closure%EF%BC%89"><span class="nav-number">1.9.1.</span> <span class="nav-text">闭包（Closure）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%EF%BC%88Prototype%EF%BC%89"><span class="nav-number">1.9.2.</span> <span class="nav-text">原型（Prototype）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88Event-Loop%EF%BC%89"><span class="nav-number">1.9.3.</span> <span class="nav-text">事件循环（Event Loop）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#webpack-%E4%B8%8E-vite"><span class="nav-number">1.10.</span> <span class="nav-text">webpack 与 vite</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Webpack"><span class="nav-number">1.10.1.</span> <span class="nav-text">Webpack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vite"><span class="nav-number">1.10.2.</span> <span class="nav-text">Vite</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB"><span class="nav-number">1.10.3.</span> <span class="nav-text">主要区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue2-%E5%92%8C-vue3"><span class="nav-number">1.11.</span> <span class="nav-text">vue2 和 vue3</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E6%94%B9%E8%BF%9B"><span class="nav-number">1.11.1.</span> <span class="nav-text">性能改进</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E5%BC%8F-API"><span class="nav-number">1.11.2.</span> <span class="nav-text">组合式 API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E5%A5%BD%E7%9A%84-TypeScript-%E6%94%AF%E6%8C%81"><span class="nav-number">1.11.3.</span> <span class="nav-text">更好的 TypeScript 支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%96%B0%E7%89%B9%E6%80%A7%E5%92%8C%E6%94%B9%E8%BF%9B"><span class="nav-number">1.11.4.</span> <span class="nav-text">其他新特性和改进</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%BC%E5%AE%B9%E6%80%A7%E5%92%8C%E8%BF%81%E7%A7%BB"><span class="nav-number">1.11.5.</span> <span class="nav-text">兼容性和迁移</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nextTick"><span class="nav-number">1.12.</span> <span class="nav-text">nextTick</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">1.12.1.</span> <span class="nav-text">基本原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="nav-number">1.12.2.</span> <span class="nav-text">工作机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.12.3.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.12.4.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.12.5.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#javascript-%E5%92%8C-typescript"><span class="nav-number">1.13.</span> <span class="nav-text">javascript 和 typescript</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript"><span class="nav-number">1.13.1.</span> <span class="nav-text">JavaScript</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TypeScript"><span class="nav-number">1.13.2.</span> <span class="nav-text">TypeScript</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB-1"><span class="nav-number">1.13.3.</span> <span class="nav-text">主要区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A"><span class="nav-number">1.14.</span> <span class="nav-text">Vue 双向绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.14.1.</span> <span class="nav-text">响应式系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#v-model-%E6%8C%87%E4%BB%A4"><span class="nav-number">1.14.2.</span> <span class="nav-text">v-model 指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">1.14.3.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F"><span class="nav-number">1.14.4.</span> <span class="nav-text">注意</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cookie-Session-localStorage"><span class="nav-number">1.15.</span> <span class="nav-text">Cookie Session localStorage</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Cookie"><span class="nav-number">1.15.1.</span> <span class="nav-text">Cookie</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Session"><span class="nav-number">1.15.2.</span> <span class="nav-text">Session</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#localStorage"><span class="nav-number">1.15.3.</span> <span class="nav-text">localStorage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%94%E8%BE%83"><span class="nav-number">1.15.4.</span> <span class="nav-text">比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="nav-number">1.16.</span> <span class="nav-text">跨域问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%EF%BC%9F"><span class="nav-number">1.16.1.</span> <span class="nav-text">什么是跨域？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">1.16.2.</span> <span class="nav-text">常见的解决方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.16.3.</span> <span class="nav-text">选择合适的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#XSS-%E6%94%BB%E5%87%BB"><span class="nav-number">1.17.</span> <span class="nav-text">XSS 攻击</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#XSS-%E6%94%BB%E5%87%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.17.1.</span> <span class="nav-text">XSS 攻击是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83-XSS-%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="nav-number">1.17.2.</span> <span class="nav-text">如何防范 XSS 攻击？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#git-flow"><span class="nav-number">1.18.</span> <span class="nav-text">git flow</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E5%88%86%E6%94%AF"><span class="nav-number">1.18.1.</span> <span class="nav-text">主要分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%85%E5%8A%A9%E5%88%86%E6%94%AF"><span class="nav-number">1.18.2.</span> <span class="nav-text">辅助分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.18.3.</span> <span class="nav-text">工作流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9%E4%B8%8E%E7%BC%BA%E7%82%B9"><span class="nav-number">1.18.4.</span> <span class="nav-text">优点与缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB"><span class="nav-number">1.19.</span> <span class="nav-text">中间人攻击</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB"><span class="nav-number">1.19.1.</span> <span class="nav-text">如何进行中间人攻击</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.19.2.</span> <span class="nav-text">常见的中间人攻击类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB"><span class="nav-number">1.19.3.</span> <span class="nav-text">如何防范中间人攻击</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95-SSO"><span class="nav-number">1.20.</span> <span class="nav-text">单点登录 SSO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%EF%BC%88SSO%EF%BC%89%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.20.1.</span> <span class="nav-text">单点登录（SSO）的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SSO-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.20.2.</span> <span class="nav-text">SSO 的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SSO-%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-number">1.20.3.</span> <span class="nav-text">SSO 的流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SSO-%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E6%8C%91%E6%88%98"><span class="nav-number">1.20.4.</span> <span class="nav-text">SSO 的优势和挑战</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TypeScript-interface-type"><span class="nav-number">1.21.</span> <span class="nav-text">TypeScript interface type</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E5%92%8C%E5%8A%9F%E8%83%BD"><span class="nav-number">1.21.1.</span> <span class="nav-text">语法和功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-number">1.21.2.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E8%80%83%E8%99%91"><span class="nav-number">1.21.3.</span> <span class="nav-text">性能考虑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%BC%E5%AE%B9%E6%80%A7%E5%92%8C%E6%89%A9%E5%B1%95%E6%80%A7"><span class="nav-number">1.21.4.</span> <span class="nav-text">兼容性和扩展性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%82%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84"><span class="nav-number">1.22.</span> <span class="nav-text">函数入参实现类型映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B"><span class="nav-number">1.22.1.</span> <span class="nav-text">1. 使用泛型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.22.2.</span> <span class="nav-text">2. 条件类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.22.3.</span> <span class="nav-text">3. 映射类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA"><span class="nav-number">1.22.4.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTPS-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.23.</span> <span class="nav-text">HTTPS 工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%8A%A0%E5%AF%86"><span class="nav-number">1.23.1.</span> <span class="nav-text">1. 加密</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-SSL-x2F-TLS-%E6%8F%A1%E6%89%8B"><span class="nav-number">1.23.2.</span> <span class="nav-text">2. SSL&#x2F;TLS 握手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%AE%89%E5%85%A8%E9%80%9A%E4%BF%A1"><span class="nav-number">1.23.3.</span> <span class="nav-text">3. 安全通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E4%BC%9A%E8%AF%9D%E7%BB%93%E6%9D%9F"><span class="nav-number">1.23.4.</span> <span class="nav-text">4. 会话结束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.23.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AB%AF%E5%8F%A3"><span class="nav-number">1.24.</span> <span class="nav-text">端口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AB%AF%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.24.1.</span> <span class="nav-text">端口的作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ESLint-Prettier-Husky-Lint-Staged"><span class="nav-number">1.25.</span> <span class="nav-text">ESLint Prettier Husky Lint-Staged</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-ESLint"><span class="nav-number">1.25.1.</span> <span class="nav-text">1. ESLint</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Prettier"><span class="nav-number">1.25.2.</span> <span class="nav-text">2. Prettier</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Husky"><span class="nav-number">1.25.3.</span> <span class="nav-text">3. Husky</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Lint-Staged"><span class="nav-number">1.25.4.</span> <span class="nav-text">4. Lint-Staged</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8"><span class="nav-number">1.25.5.</span> <span class="nav-text">组合使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81"><span class="nav-number">2.</span> <span class="nav-text">代码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">2.1.</span> <span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%B2%E6%8A%96%EF%BC%88Debouncing%EF%BC%89"><span class="nav-number">2.2.</span> <span class="nav-text">防抖（Debouncing）</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="moke"
      src="/images/avatar_kazuha_with_cats.jpg">
  <p class="site-author-name" itemprop="name">moke</p>
  <div class="site-description" itemprop="description">C'est pour cela que je suis née</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2plcnJ5NzY1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jerry765"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOjIwNjE2MTA1NzlAcXEuY29t" title="E-Mail → mailto:2061610579@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/big/by_nc_sa.svg" alt="Creative Commons"></span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <span class="exturl" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMzkxNDM5MDY5" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;391439069">Bilibili</span>
            </li>
        </ul>
      </div>
    </div>
        <div class="pjax">
        <div class="sidebar-inner sidebar-post-related">
          <div class="animated">
              <div class="links-of-blogroll-title"><i class="fa fa-signs-post fa-fw"></i>
    相关文章
  </div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <a class="popular-posts-link" href="/2023/08/22/use-websocket-in-vue/" rel="bookmark">
        <time class="popular-posts-time">2023-08-22</time>
        <br>
      websocket 在 vue 中的使用
      </a>
    </li>
  </ul>

          </div>
        </div>
        </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://csumoke.com/2023/12/07/note-interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar_kazuha_with_cats.jpg">
      <meta itemprop="name" content="moke">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Voilà">
      <meta itemprop="description" content="C'est pour cela que je suis née">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="前端实习面试问题准备 | Voilà">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          前端实习面试问题准备
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-12-07 16:29:16 / 修改时间：22:48:00" itemprop="dateCreated datePublished" datetime="2023-12-07T16:29:16+08:00">2023-12-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/note/" itemprop="url" rel="index"><span itemprop="name">note</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2023/12/07/note-interview/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2023/12/07/note-interview/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>15k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>56 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="视频播放器进度条"><a href="#视频播放器进度条" class="headerlink" title="视频播放器进度条"></a>视频播放器进度条</h2><p>视频播放器的进度条是一种用户界面组件，它显示了视频播放的当前位置和总时长，并允许用户通过拖动或点击进度条来跳转到视频的不同位置。实现这一功能通常涉及以下几个关键步骤：</p>
<ol>
<li><p><strong>HTML结构</strong>: 使用HTML创建进度条的基本结构。通常包括一个容器（如<code>div</code>元素），内部可能有用于显示进度的子元素。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;progress-bar-container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;progress-bar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>CSS样式</strong>: 通过CSS对进度条进行样式设计，如宽度、高度、颜色等。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#progress-bar-container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: grey;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#progress-bar</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0%</span>; <span class="comment">/* 初始宽度 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>JavaScript交互</strong>:</p>
<ul>
<li><p><strong>播放进度更新</strong>: 使用JavaScript监听视频播放器的<code>timeupdate</code>事件。当事件触发时，根据视频的<code>currentTime</code>和<code>duration</code>属性计算进度，并更新进度条的宽度。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> video = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;my-video&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> progressBar = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;progress-bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line">video.<span class="title function_">addEventListener</span>(<span class="string">&#x27;timeupdate&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> progress = (video.<span class="property">currentTime</span> / video.<span class="property">duration</span>) * <span class="number">100</span>;</span><br><span class="line">    progressBar.<span class="property">style</span>.<span class="property">width</span> = progress + <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>用户交互处理</strong>: 允许用户通过点击或拖动进度条来跳转视频。这通常涉及监听进度条的点击事件，计算点击位置相对于进度条的百分比，然后将视频的<code>currentTime</code>设置为<code>duration</code>乘以这个百分比。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> progressBarContainer = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;progress-bar-container&#x27;</span>);</span><br><span class="line"></span><br><span class="line">progressBarContainer.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> percent = e.<span class="property">offsetX</span> / progressBarContainer.<span class="property">offsetWidth</span>;</span><br><span class="line">    video.<span class="property">currentTime</span> = percent * video.<span class="property">duration</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>这些步骤展示了一个基本的视频播放器进度条的实现方式。当然，实际应用中可能需要更复杂的处理，比如考虑缓冲状态的显示、拖动操作的优化等。</p>
<span id="more"></span>

<h2 id="Node-js-单线程如何保证线程不中断？"><a href="#Node-js-单线程如何保证线程不中断？" class="headerlink" title="Node.js 单线程如何保证线程不中断？"></a>Node.js 单线程如何保证线程不中断？</h2><p>Node.js 被广泛认为是单线程的，但这个说法需要更准确的解释。Node.js 的主执行线程是单线程的，它运行在 V8 JavaScript 引擎上。然而，Node.js 使用多线程来处理 I&#x2F;O 密集型任务，这是通过其底层的 libuv 库实现的。以下是 Node.js 保证其单线程不中断的几个关键方面：</p>
<ol>
<li><p><strong>异步非阻塞 I&#x2F;O</strong>:</p>
<ul>
<li>Node.js 主要依靠事件循环和回调函数来处理 I&#x2F;O 操作（如文件读写、网络请求等），这些操作是异步和非阻塞的。</li>
<li>当一个 I&#x2F;O 操作开始时，它会被发送到事件循环，并继续执行后续的代码，而不是等待 I&#x2F;O 操作完成。当 I&#x2F;O 操作完成时，相应的回调函数会被放入事件队列中，等待主线程空闲时执行。</li>
</ul>
</li>
<li><p><strong>事件驱动架构</strong>:</p>
<ul>
<li>Node.js 使用事件驱动模型来处理各种异步操作。每当有事件发生时（如数据到达、超时、处理完成），相应的回调函数会被触发。</li>
<li>这种模型使得 Node.js 能够在不被阻塞的情况下高效地处理大量的并发请求。</li>
</ul>
</li>
<li><p><strong>libuv 库</strong>:</p>
<ul>
<li>尽管 JavaScript 代码在单个主线程上运行，Node.js 使用 libuv 库在背后管理一个线程池。</li>
<li>对于一些复杂的操作（如文件系统操作、某些加密操作），libuv 会在后台的多个线程上执行这些任务，而主线程继续执行 JavaScript 代码。</li>
</ul>
</li>
<li><p><strong>错误处理机制</strong>:</p>
<ul>
<li>Node.js 提供了异常处理机制，比如 <code>try-catch</code> 块和全局的 <code>uncaughtException</code> 事件，来处理同步和异步代码中的错误。</li>
<li>正确的错误处理能够防止异常导致主线程崩溃。</li>
</ul>
</li>
<li><p><strong>进程管理</strong>:</p>
<ul>
<li>对于 CPU 密集型任务，可以使用 Node.js 的 <code>child_process</code> 模块来创建子进程，分担主线程的负载。</li>
<li>还可以使用集群（Cluster）模块来创建多个进程，每个进程都有自己的事件循环和 V8 实例，可以更好地利用多核 CPU。</li>
</ul>
</li>
</ol>
<p>通过这些机制，Node.js 能够确保即使是在单个主线程上运行，也能高效地处理大量的并发 I&#x2F;O 操作，同时避免线程中断和阻塞。</p>
<h2 id="websocket-建立连接的过程"><a href="#websocket-建立连接的过程" class="headerlink" title="websocket 建立连接的过程"></a>websocket 建立连接的过程</h2><p>WebSocket 建立连接的过程是一个升级自 HTTP 协议的握手过程。WebSocket 允许在用户的浏览器和服务器之间建立一个持久的连接，使得数据可以双向传输。下面是 WebSocket 建立连接的详细步骤：</p>
<ol>
<li><p><strong>客户端发送握手请求</strong>:</p>
<ul>
<li>首先，客户端（通常是一个网页的 JavaScript）通过发送一个 HTTP 请求来初始化 WebSocket 连接。这个请求被称为”握手请求”。</li>
<li>这个请求使用普通的 HTTP GET 方法，但在请求头中包含特定的头部字段，指示这是一个 WebSocket 连接请求。主要的头部字段包括：<ul>
<li><code>Upgrade: websocket</code>：告诉服务器，客户端希望将 HTTP 连接升级到 WebSocket。</li>
<li><code>Connection: Upgrade</code>：同样表示这是一个升级请求。</li>
<li><code>Sec-WebSocket-Key</code>：一个 Base64 编码的随机值，服务器将用它来构建一个响应密钥，验证连接。</li>
<li><code>Sec-WebSocket-Version</code>：标示客户端支持的 WebSocket 版本。</li>
<li><code>Origin</code>（可选）：指示请求来自哪个源，用于服务器的跨源策略。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>服务器响应握手</strong>:</p>
<ul>
<li>服务器解析这个握手请求，如果接受升级请求，则会发送一个 HTTP 101 Switching Protocols 响应。</li>
<li>服务器的响应也包含几个特定的头部字段：<ul>
<li><code>Upgrade: websocket</code> 和 <code>Connection: Upgrade</code>：确认升级到 WebSocket。</li>
<li><code>Sec-WebSocket-Accept</code>：这是对客户端 <code>Sec-WebSocket-Key</code> 的响应，由服务器生成，客户端会验证这个值以确认连接的有效性。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>连接建立</strong>:</p>
<ul>
<li>客户端收到服务器的 101 响应后，WebSocket 连接被视为已经建立，客户端和服务器就可以开始通过这个连接双向传输数据了。</li>
<li>此时，连接从 HTTP 协议升级为 WebSocket 协议。</li>
</ul>
</li>
<li><p><strong>数据传输</strong>:</p>
<ul>
<li>一旦连接建立，客户端和服务器就可以开始发送和接收消息。</li>
<li>WebSocket 协议支持文本和二进制数据的传输。</li>
</ul>
</li>
<li><p><strong>保持连接</strong>:</p>
<ul>
<li>WebSocket 连接会保持活跃状态，直到客户端或服务器决定关闭连接。</li>
<li>连接保持活跃使得双方可以随时发送数据，无需重新建立连接。</li>
</ul>
</li>
</ol>
<p>这个握手过程的设计允许 WebSocket 连接轻松地穿过大多数防火墙，因为它们在初始阶段模仿标准的 HTTP 连接。这种方法还使得在不支持 WebSocket 的环境中回退到其他协议（如长轮询）变得更加容易。</p>
<h2 id="websocket和长轮询的区别"><a href="#websocket和长轮询的区别" class="headerlink" title="websocket和长轮询的区别"></a>websocket和长轮询的区别</h2><p>WebSocket 和长轮询（Long Polling）是两种在客户端和服务器之间实现实时数据通信的技术，但它们在工作原理和效率方面有显著区别。下面是 WebSocket 和长轮询之间的主要区别：</p>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><ol>
<li><p><strong>持久连接</strong>:</p>
<ul>
<li>WebSocket 协议建立的是一个持久的、全双工的连接。一旦连接建立，客户端和服务器可以随时互相发送数据，直到任一方主动关闭连接。</li>
</ul>
</li>
<li><p><strong>协议升级</strong>:</p>
<ul>
<li>WebSocket 通过一次 HTTP 握手升级到 WebSocket 协议。握手完成后，协议从 HTTP 切换到 WebSocket，这个连接将保持打开状态，不再是 HTTP 协议。</li>
</ul>
</li>
<li><p><strong>高效率</strong>:</p>
<ul>
<li>因为连接是持久的，所以不存在为了每次数据交换而建立和终止连接的额外开销。这使得 WebSocket 在数据实时性和网络效率方面优于长轮询。</li>
</ul>
</li>
<li><p><strong>双向通信</strong>:</p>
<ul>
<li>WebSocket 支持全双工通信，即客户端和服务器可以同时发送和接收数据。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>:</p>
<ul>
<li>适合需要高频率、实时性强的应用场景，例如在线游戏、实时聊天、实时数据更新等。</li>
</ul>
</li>
</ol>
<h3 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h3><ol>
<li><p><strong>基于 HTTP 请求</strong>:</p>
<ul>
<li>长轮询是在标准的 HTTP 协议上工作的。客户端发送一个 HTTP 请求到服务器，服务器保持这个请求开放直到有数据可发送。</li>
</ul>
</li>
<li><p><strong>非持久连接</strong>:</p>
<ul>
<li>每次服务器向客户端发送响应后，连接被关闭。对于新的数据，客户端需要发起新的 HTTP 请求。</li>
</ul>
</li>
<li><p><strong>效率较低</strong>:</p>
<ul>
<li>长轮询需要频繁地建立和关闭 HTTP 连接，这在某些场景下可能导致较高的网络开销和延迟。</li>
</ul>
</li>
<li><p><strong>单向请求模式</strong>:</p>
<ul>
<li>尽管长轮询可以较快地将服务器的更新推送到客户端，但它本质上仍然是一种单向请求模式，即服务器不能主动向客户端发送消息，除非客户端首先发送请求。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>:</p>
<ul>
<li>适合对实时性要求不是特别高的应用，或是在不支持 WebSocket 的环境中作为替代方案使用。</li>
</ul>
</li>
</ol>
<p>总结来说，WebSocket 提供了更高效、更适合实时通信的双向连接，而长轮询是一种更简单、在旧浏览器上更容易实现的替代方案。WebSocket 是实现实时应用的首选技术，但在某些场景下，长轮询可能因其简单性和兼容性而被选择。</p>
<h2 id="tcp-如何保证可靠性"><a href="#tcp-如何保证可靠性" class="headerlink" title="tcp 如何保证可靠性"></a>tcp 如何保证可靠性</h2><p>TCP（传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。它通过一系列机制来保证数据传输的可靠性，包括：</p>
<ol>
<li><p><strong>三次握手建立连接</strong>:</p>
<ul>
<li>在传输数据之前，TCP 使用一种被称为“三次握手”的过程来建立连接。这确保了双方都准备好接收和发送数据，并防止了初始化连接时的一些常见的问题。</li>
</ul>
</li>
<li><p><strong>序列号和确认应答</strong>:</p>
<ul>
<li>TCP 给发送的每个数据包分配一个序列号，并要求接收方对每个接收到的数据包发送确认（ACK）。</li>
<li>如果发送方在预定的超时时间内没有收到对特定数据包的确认，它会重新发送该数据包。</li>
</ul>
</li>
<li><p><strong>数据校验和</strong>:</p>
<ul>
<li>每个 TCP 数据包包含一个校验和，以确保数据在传输过程中没有被破坏或更改。</li>
<li>如果接收方检测到数据包损坏（校验和不匹配），它将丢弃该数据包并不发送确认，导致发送方重新发送数据。</li>
</ul>
</li>
<li><p><strong>流量控制</strong>:</p>
<ul>
<li>TCP 使用窗口大小控制来进行流量控制，以避免发送方过快发送数据，导致接收方来不及处理。</li>
<li>接收方通过在确认应答中指定一个“窗口大小”来告诉发送方它还能接收多少数据，从而控制发送方的数据发送速率。</li>
</ul>
</li>
<li><p><strong>拥塞控制</strong>:</p>
<ul>
<li>TCP 还实现了拥塞控制机制，以避免网络中过多的数据包导致网络拥塞。</li>
<li>当网络拥塞时，TCP 会减少其数据传输速率，并在网络状况改善时逐渐增加速率。</li>
</ul>
</li>
<li><p><strong>乱序数据重新排序</strong>:</p>
<ul>
<li>由于网络原因，TCP 数据包可能会乱序到达。TCP 在接收端会根据序列号重新对数据包进行排序，以确保数据的正确顺序。</li>
</ul>
</li>
<li><p><strong>保持活动检测</strong>:</p>
<ul>
<li>TCP 定期发送保持活动包，以检测连接是否仍然有效，防止“死”连接占用资源。</li>
</ul>
</li>
</ol>
<p>通过这些机制，TCP 能够在不可靠的互联网环境中提供可靠的数据传输服务。这些特性使得 TCP 成为了许多需要高可靠性数据传输的应用（如Web页面加载、文件传输、电子邮件等）的理想选择。</p>
<h2 id="拥塞算法"><a href="#拥塞算法" class="headerlink" title="拥塞算法"></a>拥塞算法</h2><p>TCP拥塞控制算法是为了解决和避免网络拥塞问题而设计的一组算法。当多个网络设备尝试同时发送过多数据时，网络拥塞可能发生，导致网络性能下降和数据包丢失。TCP拥塞控制算法的目的是确保每个网络连接获得公平的带宽使用，并减少数据包丢失。下面是一些主要的TCP拥塞控制算法：</p>
<ol>
<li><p><strong>慢启动（Slow Start）</strong>:</p>
<ul>
<li>在TCP连接开始时，慢启动算法被用来探测网络的载荷能力。</li>
<li>慢启动通过逐渐增加拥塞窗口（Congestion Window, cwnd）的大小来增加网络中的数据量，开始时cwnd从一个或几个数据包开始，每收到一个确认响应，cwnd就增加一倍，呈指数增长。</li>
<li>当cwnd达到一个阈值（ssthresh）时，切换到拥塞避免算法。</li>
</ul>
</li>
<li><p><strong>拥塞避免（Congestion Avoidance）</strong>:</p>
<ul>
<li>在拥塞避免阶段，每经过一个往返时间（Round-Trip Time, RTT），cwnd线性增加一个数据包，而不是指数增长。</li>
<li>这个阶段旨在维持网络载荷在一个相对稳定的水平。</li>
</ul>
</li>
<li><p><strong>快重传（Fast Retransmit）</strong>:</p>
<ul>
<li>快重传是指在接收方连续收到三个相同的确认（Triple Duplicate ACKs）时，立即重传丢失的数据包，而不是等待重传计时器到期。</li>
<li>这种机制可以更快地纠正丢包的情况。</li>
</ul>
</li>
<li><p><strong>快恢复（Fast Recovery）</strong>:</p>
<ul>
<li>快恢复算法与快重传一起工作，当检测到丢包（通过三个重复的 ACK ）时，它会减少 cwnd 的大小而不是像慢启动时那样将其减至1，通常将 cwnd 设置为 ssthresh 的一半。</li>
<li>在快恢复阶段，对于每个接收到的重复 ACK ， cwnd 逐渐增加，直到收到新的数据确认。</li>
</ul>
</li>
<li><p><strong>TCP Tahoe 和 Reno</strong>:</p>
<ul>
<li>TCP Tahoe 和 Reno 是两种实现了上述拥塞控制算法的TCP变体。</li>
<li>Tahoe 使用慢启动、拥塞避免和快重传，但在检测到丢包时，它会将cwnd重置为1。</li>
<li>Reno 则引入了快恢复算法，它在丢包时减少cwnd而不是重置。</li>
</ul>
</li>
<li><p><strong>其他算法</strong>:</p>
<ul>
<li>随着网络技术的发展，出现了更多的拥塞控制算法，如TCP Vegas, TCP BBR（Bottleneck Bandwidth and RTT）等，它们在不同的网络环境和场景中提供了改进的性能。</li>
</ul>
</li>
</ol>
<p>TCP拥塞控制算法的设计旨在使TCP连接能够自适应网络状况的变化，优化网络资源的使用，同时保证网络的稳定性和公平性。随着网络条件的不断变化，这些算法也在不断地进化和优化。</p>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>TCP（传输控制协议）的三次握手（Three-Way Handshake）过程是用于在两个网络实体之间建立一个可靠的连接的关键机制。这个过程不仅用于协商和初始化连接参数，还用于确保双方准备好进行数据传输。下面是三次握手的详细介绍：</p>
<h3 id="第一次握手：SYN"><a href="#第一次握手：SYN" class="headerlink" title="第一次握手：SYN"></a>第一次握手：SYN</h3><ol>
<li><p><strong>发起方发送SYN包</strong>:</p>
<ul>
<li>连接的发起方（客户端）开始握手过程，发送一个包含 SYN（同步序列编号）标志的数据包到接收方（服务器）。</li>
<li>在这个数据包中，发起方选择一个随机的序列号（Seq &#x3D; X），这个序列号在后续数据传输中用于保证数据的有序和完整性。</li>
</ul>
</li>
<li><p><strong>目的</strong>:</p>
<ul>
<li>主要是向接收方表明发起方希望建立连接。</li>
</ul>
</li>
</ol>
<h3 id="第二次握手：SYN-ACK"><a href="#第二次握手：SYN-ACK" class="headerlink" title="第二次握手：SYN-ACK"></a>第二次握手：SYN-ACK</h3><ol>
<li><p><strong>接收方响应SYN-ACK包</strong>:</p>
<ul>
<li>接收方收到 SYN 包后，需要确认这个请求。它发送一个包含 SYN 和 ACK（确认响应）标志的数据包。</li>
<li>这个数据包中的确认号（Ack &#x3D; X + 1）是对发起方 SYN 包中序列号的确认，同时接收方也选择自己的一个随机序列号（Seq &#x3D; Y）。</li>
</ul>
</li>
<li><p><strong>目的</strong>:</p>
<ul>
<li>确认发起方的 SYN，并且通知发起方接收方也准备好建立连接。</li>
</ul>
</li>
</ol>
<h3 id="第三次握手：ACK"><a href="#第三次握手：ACK" class="headerlink" title="第三次握手：ACK"></a>第三次握手：ACK</h3><ol>
<li><p><strong>发起方发送ACK包</strong>:</p>
<ul>
<li>发起方收到 SYN-ACK 包后，发送一个包含 ACK 标志的数据包，这个包的确认号被设置为接收方的序列号加一（Ack &#x3D; Y + 1）。</li>
<li>这一步完成了对接收方初始序列号的确认。</li>
</ul>
</li>
<li><p><strong>连接建立</strong>:</p>
<ul>
<li>一旦接收方收到这个 ACK 包，连接就被认为是建立了。现在，双方都已确认彼此的初始序列号，并且都准备好进行数据传输。</li>
</ul>
</li>
</ol>
<h3 id="为什么需要三次握手？"><a href="#为什么需要三次握手？" class="headerlink" title="为什么需要三次握手？"></a>为什么需要三次握手？</h3><p>三次握手的设计是为了确保双方都能确认对方的接收和发送能力。它主要解决了以下几个问题：</p>
<ul>
<li>确保双方都知道对方准备好发送和接收数据。</li>
<li>避免旧的延迟连接初始化请求突然建立连接。</li>
<li>确保在连接开始时双方的序列号被正确初始化和同步。</li>
</ul>
<p>这个过程是建立一个可靠的 TCP 连接的基础，确保了数据传输的可靠性和顺序性。</p>
<h2 id="http-和-tcp-的-keep-alive-区别"><a href="#http-和-tcp-的-keep-alive-区别" class="headerlink" title="http 和 tcp 的 keep-alive 区别"></a>http 和 tcp 的 keep-alive 区别</h2><p>HTTP Keep-Alive 和 TCP Keep-Alive 是两种不同层次上的保持连接活跃的机制，它们的目的和实现方式有所不同：</p>
<h3 id="HTTP-Keep-Alive"><a href="#HTTP-Keep-Alive" class="headerlink" title="HTTP Keep-Alive"></a>HTTP Keep-Alive</h3><ol>
<li><p><strong>层次</strong>:</p>
<ul>
<li>HTTP Keep-Alive 工作在应用层，是 HTTP 协议的一部分。</li>
</ul>
</li>
<li><p><strong>目的</strong>:</p>
<ul>
<li>HTTP Keep-Alive 的主要目的是减少建立和关闭连接的频繁操作，提高 HTTP 传输效率。</li>
<li>它允许在一个 TCP 连接上发送和接收多个 HTTP 请求&#x2F;响应，而不需要为每个请求&#x2F;响应对重新建立新的 TCP 连接。</li>
</ul>
</li>
<li><p><strong>实现</strong>:</p>
<ul>
<li>在 HTTP 1.1 中，默认开启 Keep-Alive。</li>
<li>客户端和服务器在 HTTP 头部信息中通过 <code>Connection: keep-alive</code> 来通告对方它们希望保持连接打开。</li>
<li>连接会保持活跃直到客户端或服务器决定关闭，或者超过预定的超时时间。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>:</p>
<ul>
<li>HTTP Keep-Alive 特别适用于需要多个连续的 HTTP 请求&#x2F;响应的场景，如网页加载中包含多个资源（CSS、JavaScript、图片等）的情况。</li>
</ul>
</li>
</ol>
<h3 id="TCP-Keep-Alive"><a href="#TCP-Keep-Alive" class="headerlink" title="TCP Keep-Alive"></a>TCP Keep-Alive</h3><ol>
<li><p><strong>层次</strong>:</p>
<ul>
<li>TCP Keep-Alive 工作在传输层，是 TCP 协议的一部分。</li>
</ul>
</li>
<li><p><strong>目的</strong>:</p>
<ul>
<li>TCP Keep-Alive 的目的是检测死亡连接（即长时间无数据交换的连接），确保连接的双方仍然可达。</li>
<li>它用于维护和监控 TCP 连接的状态。</li>
</ul>
</li>
<li><p><strong>实现</strong>:</p>
<ul>
<li>TCP Keep-Alive 通过定期发送探测数据包来实现。如果在一定次数的探测后仍然没有收到响应，则认为连接已经断开，并关闭连接。</li>
<li>这个机制在某些操作系统中默认关闭，并且探测间隔和次数可以配置。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>:</p>
<ul>
<li>TCP Keep-Alive 适用于任何基于 TCP 的网络服务，特别是那些可能长时间空闲但需要保持连接的场景，如数据库连接。</li>
</ul>
</li>
</ol>
<h3 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h3><ul>
<li><strong>层次不同</strong>：HTTP Keep-Alive 是应用层协议，TCP Keep-Alive 是传输层协议。</li>
<li><strong>目的不同</strong>：HTTP Keep-Alive 用于提高 HTTP 效率，减少连接重建的开销；而 TCP Keep-Alive 用于检测和维护连接的活跃状态。</li>
<li><strong>适用范围</strong>：HTTP Keep-Alive 仅用于 HTTP 协议，而 TCP Keep-Alive 适用于所有基于 TCP 的通信。</li>
<li><strong>工作方式</strong>：HTTP Keep-Alive 通过重用连接进行多个请求&#x2F;响应交换，TCP Keep-Alive 通过发送探测数据包来检测连接状态。</li>
</ul>
<h2 id="js-闭包、原型、事件循环"><a href="#js-闭包、原型、事件循环" class="headerlink" title="js 闭包、原型、事件循环"></a>js 闭包、原型、事件循环</h2><h3 id="闭包（Closure）"><a href="#闭包（Closure）" class="headerlink" title="闭包（Closure）"></a>闭包（Closure）</h3><p>闭包是 JavaScript 中一个非常重要的特性，它允许一个函数访问并操作该函数外部的变量。</p>
<ol>
<li><p><strong>定义</strong>: 在 JavaScript 中，当一个函数嵌套在另一个函数内，并引用外层函数的变量时，就形成了闭包。</p>
</li>
<li><p><strong>作用</strong>:</p>
<ul>
<li><strong>访问外部函数的变量</strong>: 内部函数可以访问定义在外部函数中的变量，即使外部函数已经执行完毕。</li>
<li><strong>数据封装和私有性</strong>: 闭包可以用来创建私有变量，提供类似于面向对象编程中的封装和隐藏数据的功能。</li>
</ul>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> secret = <span class="string">&quot;I&#x27;m a secret!&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">innerFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(secret);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getSecret = <span class="title function_">outerFunction</span>();</span><br><span class="line"><span class="title function_">getSecret</span>(); <span class="comment">// 输出 &quot;I&#x27;m a secret!&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="原型（Prototype）"><a href="#原型（Prototype）" class="headerlink" title="原型（Prototype）"></a>原型（Prototype）</h3><p>原型是 JavaScript 中实现继承和共享属性或方法的一种机制。</p>
<ol>
<li><p><strong>原型对象</strong>: 每个 JavaScript 对象都有一个原型对象（<code>prototype</code>），对象从其原型继承属性和方法。</p>
</li>
<li><p><strong>原型链</strong>: 当访问一个对象的属性或方法时，如果该对象自身不包含这个属性或方法，JavaScript 会沿着原型链向上查找，直到找到或到达原型链的顶端（<code>Object.prototype</code>）。</p>
</li>
<li><p><strong>使用</strong>:</p>
<ul>
<li>常用于创建具有相似属性和方法的多个对象，提高代码复用性。</li>
<li>原型链是 JavaScript 中实现继承的基础。</li>
</ul>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">person1.<span class="title function_">sayHello</span>(); <span class="comment">// 输出 &quot;Hello, my name is Alice&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="事件循环（Event-Loop）"><a href="#事件循环（Event-Loop）" class="headerlink" title="事件循环（Event Loop）"></a>事件循环（Event Loop）</h3><p>事件循环是 JavaScript 中处理异步操作和保持单线程运行的机制。</p>
<ol>
<li><p><strong>单线程和异步</strong>: JavaScript 是单线程语言，但支持异步编程（例如，通过回调函数、Promises、async&#x2F;await）。</p>
</li>
<li><p><strong>任务类型</strong>:</p>
<ul>
<li><strong>宏任务（Macro Task）</strong>: 如 <code>setTimeout</code>, <code>setInterval</code>, I&#x2F;O 操作。</li>
<li><strong>微任务（Micro Task）</strong>: 如 Promise 回调、<code>process.nextTick</code>（在 Node.js 中）。</li>
</ul>
</li>
<li><p><strong>工作机制</strong>:</p>
<ul>
<li>事件循环不断检查是否有待执行的任务。</li>
<li>如果执行栈为空，事件循环会查看任务队列。如果队列中有宏任务，从队列中取出一个执行。</li>
<li>在每个宏任务执行之后，事件循环会处理所有的微任务队列，之后再执行下一个宏任务。</li>
<li>这个循环持续进行，直到所有任务完成。</li>
</ul>
</li>
<li><p><strong>示例</strong>:</p>
<ul>
<li>异步操作（如通过 <code>setTimeout</code> 设置的定时器）不会立即执行，而是被加入队列，在当前和其他微任务执行完毕后再执行。</li>
</ul>
</li>
</ol>
<h2 id="webpack-与-vite"><a href="#webpack-与-vite" class="headerlink" title="webpack 与 vite"></a>webpack 与 vite</h2><p>Webpack 和 Vite 是两种流行的前端构建工具，它们用于优化开发和生产环境下的前端项目。虽然两者的目标相似，但它们在实现方式和性能上有明显的区别：</p>
<h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><ol>
<li><p><strong>概念</strong>:</p>
<ul>
<li>Webpack 是一个模块打包器（bundler），主要用于 JavaScript 和相关资源文件（如 CSS、图片）的模块化构建和打包。</li>
</ul>
</li>
<li><p><strong>工作原理</strong>:</p>
<ul>
<li>Webpack 通过一个入口点开始，分析项目中的模块和资源依赖，将这些资源转换和打包成少数几个文件，通常用于生产环境。</li>
</ul>
</li>
<li><p><strong>特点</strong>:</p>
<ul>
<li><strong>灵活性和配置性</strong>：Webpack 提供了广泛的插件系统和配置选项，适用于复杂的项目需求。</li>
<li><strong>热模块替换（HMR）</strong>：在开发环境中，Webpack 支持热模块替换，允许应用在运行时更新模块而无需完全刷新。</li>
<li><strong>慢启动</strong>：由于需要分析整个项目的依赖和资源，Webpack 的启动和热更新可能比较慢。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>:</p>
<ul>
<li>适用于需要复杂配置和高度定制化构建流程的大型项目。</li>
</ul>
</li>
</ol>
<h3 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h3><ol>
<li><p><strong>概念</strong>:</p>
<ul>
<li>Vite 是一个更现代的前端构建工具，利用了最新的前端技术，如原生 ES 模块加载。</li>
</ul>
</li>
<li><p><strong>工作原理</strong>:</p>
<ul>
<li>在开发环境中，Vite 作为一个服务器运行，它利用浏览器原生的 ES 模块导入功能来服务模块请求。</li>
<li>在生产环境中，Vite 使用 Rollup 进行高效的打包。</li>
</ul>
</li>
<li><p><strong>特点</strong>:</p>
<ul>
<li><strong>快速启动</strong>：由于使用了原生 ES 模块，Vite 在开发环境中可以快速启动，无需等待打包过程。</li>
<li><strong>按需编译</strong>：Vite 只编译当前请求的模块，而不是整个应用，这使得热更新非常快。</li>
<li><strong>简化配置</strong>：Vite 设计理念倾向于减少配置，提供更简洁的开发体验。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>:</p>
<ul>
<li>适用于新项目，尤其是在追求快速开发和简化构建配置的场景下。</li>
</ul>
</li>
</ol>
<h3 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h3><ul>
<li><strong>启动速度</strong>：Vite 在开发环境中的启动速度通常比 Webpack 快，因为它不需要预先打包整个应用。</li>
<li><strong>热更新速度</strong>：Vite 的热更新通常比 Webpack 快，因为它只编译变更的模块。</li>
<li><strong>构建原理</strong>：Webpack 是一个传统的模块打包器，而 Vite 利用了现代浏览器的原生 ES 模块特性。</li>
<li><strong>兼容性</strong>：Webpack 支持更广泛的模块格式和浏览器兼容性，而 Vite 主要针对现代浏览器。</li>
<li><strong>配置复杂性</strong>：Webpack 的配置通常更复杂，而 Vite 旨在提供更简洁的配置。</li>
</ul>
<h2 id="vue2-和-vue3"><a href="#vue2-和-vue3" class="headerlink" title="vue2 和 vue3"></a>vue2 和 vue3</h2><p>Vue.js 是一个流行的 JavaScript 框架，用于构建用户界面和单页应用程序。Vue 3 是 Vue.js 的最新主要版本，相比于 Vue 2，它引入了许多新特性和改进。以下是 Vue 2 和 Vue 3 之间的主要区别：</p>
<h3 id="性能改进"><a href="#性能改进" class="headerlink" title="性能改进"></a>性能改进</h3><ol>
<li><p><strong>更快的虚拟 DOM</strong>:</p>
<ul>
<li>Vue 3 引入了一个全新的虚拟 DOM 实现，优化了渲染速度和内存消耗。</li>
</ul>
</li>
<li><p><strong>编译优化</strong>:</p>
<ul>
<li>Vue 3 的编译器进行了重写，提供了更好的编译优化，减少了运行时的开销。</li>
</ul>
</li>
<li><p><strong>树摇动（Tree-shaking）</strong>:</p>
<ul>
<li>Vue 3 支持树摇动，意味着在最终打包时可以去除未使用的代码，减小应用体积。</li>
</ul>
</li>
</ol>
<h3 id="组合式-API"><a href="#组合式-API" class="headerlink" title="组合式 API"></a>组合式 API</h3><p>Vue 3 引入了 Composition API（组合式 API），这是 Vue 3 最显著的新特性之一。</p>
<ol>
<li><p><strong>更好的逻辑复用和组织</strong>:</p>
<ul>
<li>Composition API 允许开发者更灵活地组织组件逻辑，特别是在处理复杂组件时。</li>
<li>使用 <code>setup</code> 函数和一系列新的 API（如 <code>ref</code>, <code>reactive</code>, <code>computed</code>, <code>watch</code> 等），可以更好地封装和重用逻辑。</li>
</ul>
</li>
<li><p><strong>与 Options API 的共存</strong>:</p>
<ul>
<li>Vue 3 依然支持 Vue 2 中的 Options API，两种风格可以共存。</li>
</ul>
</li>
</ol>
<h3 id="更好的-TypeScript-支持"><a href="#更好的-TypeScript-支持" class="headerlink" title="更好的 TypeScript 支持"></a>更好的 TypeScript 支持</h3><ul>
<li>Vue 3 从一开始就考虑到了 TypeScript 的支持，其代码基于 TypeScript 编写，提供了更好的类型推断和集成。</li>
</ul>
<h3 id="其他新特性和改进"><a href="#其他新特性和改进" class="headerlink" title="其他新特性和改进"></a>其他新特性和改进</h3><ol>
<li><p><strong>组合式 API</strong>:</p>
<ul>
<li>引入了更灵活的组合式 API，为组件逻辑提供了更强的组织能力。</li>
</ul>
</li>
<li><p><strong>更小的体积</strong>:</p>
<ul>
<li>Vue 3 的体积比 Vue 2 更小，主要得益于树摇动。</li>
</ul>
</li>
<li><p><strong>多根节点组件</strong>:</p>
<ul>
<li>Vue 3 允许组件有多个根节点，而 Vue 2 中每个组件只能有一个根节点。</li>
</ul>
</li>
<li><p><strong>响应式系统的重写</strong>:</p>
<ul>
<li>Vue 3 的响应式系统基于 Proxy API 重写，提供了更好的性能和兼容性。</li>
</ul>
</li>
<li><p><strong>全新的生命周期钩子</strong>:</p>
<ul>
<li>引入了新的生命周期钩子，如 <code>onMounted</code>, <code>onUpdated</code> 等。</li>
</ul>
</li>
<li><p><strong>Fragment, Teleport, Suspense</strong>:</p>
<ul>
<li>引入了新的内置组件，如 Fragment（允许多个根节点），Teleport（允许将子节点传送到 DOM 树的其他位置），Suspense（用于异步组件的数据获取和渲染）。</li>
</ul>
</li>
</ol>
<h3 id="兼容性和迁移"><a href="#兼容性和迁移" class="headerlink" title="兼容性和迁移"></a>兼容性和迁移</h3><ul>
<li>Vue 3 考虑到了向后兼容性，提供了从 Vue 2 迁移到 Vue 3 的工具和指南。</li>
</ul>
<h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><ol>
<li><p><strong>事件循环</strong>:</p>
<ul>
<li>Node.js 运行时基于事件循环。事件循环负责处理异步回调，如 I&#x2F;O 操作、计时器、网络请求等。</li>
</ul>
</li>
<li><p><strong>微任务队列</strong>:</p>
<ul>
<li><code>process.nextTick</code> 将回调函数放入微任务队列。这个队列在事件循环的每个阶段之间执行，甚至在事件循环的当前阶段完成之前。</li>
</ul>
</li>
<li><p><strong>优先级</strong>:</p>
<ul>
<li>通过 <code>process.nextTick</code> 调度的任务比通过 <code>setImmediate</code> 或 <code>setTimeout</code>、<code>setInterval</code> 调度的任务优先级更高。这意味着 <code>nextTick</code> 回调在任何 I&#x2F;O 事件（包括定时器）之前执行。</li>
</ul>
</li>
</ol>
<h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><ul>
<li>当调用 <code>process.nextTick</code> 时，传入的回调函数不会立即执行。而是在当前操作完成后、事件循环继续进行之前执行。</li>
<li>这意味着即使在 I&#x2F;O 操作或定时器触发之前，所有通过 <code>nextTick</code> 排队的回调都会首先执行。</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><p><strong>错误处理</strong>:</p>
<ul>
<li><code>process.nextTick</code> 经常用于异步 API 中的错误处理。这是因为它允许在堆栈被解构之前抛出异常，从而可以捕获和处理错误。</li>
</ul>
</li>
<li><p><strong>确保异步性</strong>:</p>
<ul>
<li>有时候，你可能需要确保代码总是以异步方式运行，即使是在同步代码块中。<code>process.nextTick</code> 可以用于确保回调总是异步调用，从而避免了同步操作和异步操作之间的潜在问题。</li>
</ul>
</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始&#x27;</span>);</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextTick 回调&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;计划的 nextTick&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，输出将会是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开始</span><br><span class="line">计划的 nextTick</span><br><span class="line">nextTick 回调</span><br></pre></td></tr></table></figure>

<p>即使 <code>process.nextTick</code> 的回调是在最后一行调用的，它仍然在当前事件循环的末尾执行，即在任何其他的 I&#x2F;O 事件或计时器之前执行。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>使用 <code>process.nextTick</code> 可能导致 I&#x2F;O 饿死，因为如果不断地添加 <code>nextTick</code> 回调，那么 I&#x2F;O 事件可能永远无法被处理。因此，适当地使用 <code>nextTick</code> 是非常重要的。</li>
<li>对于绝大多数场景，<code>setImmediate</code> 是处理异步操作的更好选择，因为它更加公平地对待事件循环中的所有类型的事件。</li>
</ul>
<h2 id="javascript-和-typescript"><a href="#javascript-和-typescript" class="headerlink" title="javascript 和 typescript"></a>javascript 和 typescript</h2><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><ol>
<li><p><strong>定义</strong>:</p>
<ul>
<li>JavaScript 是一种高级的、解释型的编程语言。它是 Web 的核心语言，几乎所有的现代网页都使用 JavaScript 来增加交互性。</li>
</ul>
</li>
<li><p><strong>特点</strong>:</p>
<ul>
<li><strong>动态类型</strong>: JavaScript 是一种动态类型语言，这意味着变量的类型是在运行时确定的。</li>
<li><strong>解释执行</strong>: 作为一种解释型语言，JavaScript 代码在运行时由浏览器或 Node.js 的解释器直接执行。</li>
<li><strong>灵活性</strong>: 它是一种非常灵活的语言，支持面向对象、命令式和函数式编程风格。</li>
</ul>
</li>
<li><p><strong>应用范围</strong>:</p>
<ul>
<li>用于浏览器端的脚本编写，也被广泛用于服务器端（Node.js），以及移动应用和桌面应用开发。</li>
</ul>
</li>
</ol>
<h3 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h3><ol>
<li><p><strong>定义</strong>:</p>
<ul>
<li>TypeScript 是 JavaScript 的一个超集，由 Microsoft 开发和维护。它在 JavaScript 的基础上添加了静态类型系统。</li>
</ul>
</li>
<li><p><strong>特点</strong>:</p>
<ul>
<li><strong>静态类型</strong>: TypeScript 提供了静态类型检查，这意味着类型错误可以在编译阶段被捕获，而不是在运行时。</li>
<li><strong>编译为 JavaScript</strong>: TypeScript 代码需要被编译成 JavaScript 代码，这样浏览器和 Node.js 才能执行。</li>
<li><strong>面向对象特性</strong>: TypeScript 支持更先进的面向对象编程特性，如类、接口、继承和泛型。</li>
</ul>
</li>
<li><p><strong>优势</strong>:</p>
<ul>
<li>提高了大型项目的可维护性和开发效率。</li>
<li>提供了编译时类型检查，有助于及早发现错误。</li>
<li>改善了代码质量和可读性。</li>
</ul>
</li>
<li><p><strong>应用范围</strong>:</p>
<ul>
<li>TypeScript 适用于需要高度维护性和可扩展性的大型项目，特别是在团队开发环境中。</li>
</ul>
</li>
</ol>
<h3 id="主要区别-1"><a href="#主要区别-1" class="headerlink" title="主要区别"></a>主要区别</h3><ul>
<li><strong>类型系统</strong>: TypeScript 的最大特点是它的静态类型系统，而 JavaScript 是动态类型的。</li>
<li><strong>错误检测</strong>: TypeScript 能够在编译期间检测到类型错误，而 JavaScript 中的类型错误通常在运行时出现。</li>
<li><strong>工具支持</strong>: TypeScript 由于其类型系统，提供了更好的自动完成、重构和接口文档。</li>
<li><strong>学习曲线</strong>: TypeScript 的学习曲线相对于 JavaScript 来说稍微陡峭一些，特别是对于不熟悉类型系统的开发者。</li>
</ul>
<p>总的来说，TypeScript 提供了更强大的工具和特性来帮助开发大型和复杂的应用，而 JavaScript 由于其广泛的应用和灵活性，仍然是最流行的前端开发语言之一。开发者可以根据项目的具体需求和团队的熟悉程度来选择使用 JavaScript 还是 TypeScript。</p>
<h2 id="Vue-双向绑定"><a href="#Vue-双向绑定" class="headerlink" title="Vue 双向绑定"></a>Vue 双向绑定</h2><p>Vue.js 中的双向绑定是一种机制，允许数据和 UI 界面之间建立一个响应式连接，使得数据的变化能够自动反映到 UI 上，同时用户对 UI 的操作也能自动更新到数据上。Vue 实现双向绑定主要依靠两个核心概念：响应式系统和 <code>v-model</code> 指令。</p>
<h3 id="响应式系统"><a href="#响应式系统" class="headerlink" title="响应式系统"></a>响应式系统</h3><ol>
<li><p><strong>观察者模式</strong>:</p>
<ul>
<li>Vue 使用观察者模式来跟踪数据的变化。当你把一个普通的 JavaScript 对象传入 Vue 实例作为 <code>data</code> 选项，Vue 会遍历它的所有属性，并使用 <code>Object.defineProperty</code> 把这些属性全部转为 getter&#x2F;setter。这是 Vue 响应式系统的核心。</li>
</ul>
</li>
<li><p><strong>依赖收集</strong>:</p>
<ul>
<li>当渲染函数被首次执行时，Vue 能够追踪到哪些属性被访问了，从而知道在哪些属性发生变化时需要重新渲染。</li>
</ul>
</li>
<li><p><strong>派发更新</strong>:</p>
<ul>
<li>当属性的 setter 被调用时（即属性值发生变化时），Vue 会通知那些依赖于这个属性的组件重新渲染。</li>
</ul>
</li>
</ol>
<h3 id="v-model-指令"><a href="#v-model-指令" class="headerlink" title="v-model 指令"></a><code>v-model</code> 指令</h3><ol>
<li><p><strong>基本用途</strong>:</p>
<ul>
<li><code>v-model</code> 在表单元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。</li>
</ul>
</li>
<li><p><strong>工作原理</strong>:</p>
<ul>
<li>对于输入框（<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>）和选择框（<code>&lt;select&gt;</code>），<code>v-model</code> 绑定的值通常是 <code>input</code> 事件中的 <code>value</code>。</li>
<li>在内部，<code>v-model</code> 实际上是一个语法糖，它相当于同时绑定了 <code>value</code> 属性和监听 <code>input</code> 事件，当控件的输入值变化时，更新数据。</li>
</ul>
</li>
</ol>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>假设有如下 Vue 实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;Hello Vue!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>和如下模板：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>&lt;input&gt;</code> 元素和 <code>message</code> 数据之间建立了双向绑定。用户在输入框中输入文本时，<code>message</code> 数据会实时更新，同时 <code>message</code> 数据的变化也会实时反映到输入框的值中。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>虽然 <code>v-model</code> 提供了方便的双向绑定，但它也可能导致数据流难以理解和追踪，特别是在复杂的应用中。因此，在一些场景下，推荐使用单向数据流（即数据的单向绑定和显式的事件处理）来保持数据流的清晰和可控。</li>
<li>在 Vue 3 中，响应式系统从 <code>Object.defineProperty</code> 改为了基于 ES6 的 Proxy，这使得 Vue 的响应式系统更加强大和高效，同时消除了一些 Vue 2 中存在的限制。</li>
</ul>
<h2 id="Cookie-Session-localStorage"><a href="#Cookie-Session-localStorage" class="headerlink" title="Cookie Session localStorage"></a>Cookie Session localStorage</h2><p><code>Cookie</code>、<code>Session</code> 和 <code>localStorage</code> 是用于存储和管理网站数据的三种不同技术，每种技术都有其特定的用途和限制。</p>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><ol>
<li><p><strong>定义</strong>:</p>
<ul>
<li>Cookie 是小段的数据，由服务器发送到用户浏览器，然后浏览器会将其存储，并在随后的每个请求中将其发送回服务器。</li>
</ul>
</li>
<li><p><strong>特点</strong>:</p>
<ul>
<li>体积小（通常限制为4KB）。</li>
<li>每次 HTTP 请求都会携带，包括静态资源请求，这可能影响性能。</li>
<li>可以设置过期时间。</li>
<li>支持同源策略。</li>
</ul>
</li>
<li><p><strong>用途</strong>:</p>
<ul>
<li>用户认证。</li>
<li>会话跟踪。</li>
<li>个性化设置。</li>
</ul>
</li>
<li><p><strong>安全性</strong>:</p>
<ul>
<li>支持设置为 HttpOnly（无法通过 JS 访问）和 Secure（只在 HTTPS 下传输）。</li>
</ul>
</li>
</ol>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><ol>
<li><p><strong>定义</strong>:</p>
<ul>
<li>Session 是服务器端用来存储用户信息的一种机制，通常用于识别用户和存储用户特定的数据。</li>
</ul>
</li>
<li><p><strong>特点</strong>:</p>
<ul>
<li>存储在服务器端，对客户端是透明的。</li>
<li>可以存储较大量的数据。</li>
<li>生命周期通常取决于用户的会话（浏览器关闭，Session 结束）。</li>
</ul>
</li>
<li><p><strong>用途</strong>:</p>
<ul>
<li>管理用户会话（如登录状态）。</li>
<li>存储用户相关的敏感信息。</li>
</ul>
</li>
<li><p><strong>安全性</strong>:</p>
<ul>
<li>相比于 Cookie，Session 更安全，因为数据存储在服务器端。</li>
</ul>
</li>
</ol>
<h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><ol>
<li><p><strong>定义</strong>:</p>
<ul>
<li>localStorage 是 HTML5 提供的一种在客户端存储数据的方式。</li>
</ul>
</li>
<li><p><strong>特点</strong>:</p>
<ul>
<li>存储容量较大（最多 5MB）。</li>
<li>仅在客户端存储，不随 HTTP 请求发送。</li>
<li>没有过期时间，数据永久保存，直到手动清除。</li>
</ul>
</li>
<li><p><strong>用途</strong>:</p>
<ul>
<li>存储不经常变化的大量数据。</li>
<li>保存用户偏好设置。</li>
<li>缓存应用程序数据以提高性能。</li>
</ul>
</li>
<li><p><strong>安全性</strong>:</p>
<ul>
<li>由于存储在客户端，可能受到跨站脚本攻击（XSS）。</li>
</ul>
</li>
</ol>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ul>
<li><p><strong>存储位置</strong>:</p>
<ul>
<li>Cookie 和 localStorage 存储在客户端。</li>
<li>Session 存储在服务器端。</li>
</ul>
</li>
<li><p><strong>安全性</strong>:</p>
<ul>
<li>Session 比 Cookie 更安全。</li>
<li>localStorage 适用于非敏感数据的存储。</li>
</ul>
</li>
<li><p><strong>生命周期</strong>:</p>
<ul>
<li>Cookie 可以设置过期时间。</li>
<li>Session 通常与用户会话绑定。</li>
<li>localStorage 永久存储，直到被清除。</li>
</ul>
</li>
<li><p><strong>容量</strong>:</p>
<ul>
<li>Cookie 容量最小。</li>
<li>localStorage 提供最大的存储空间。</li>
</ul>
</li>
<li><p><strong>性能</strong>:</p>
<ul>
<li>Cookie 每次请求都会发送，可能影响性能。</li>
<li>Session 和 localStorage 不影响网络性能。</li>
</ul>
</li>
</ul>
<h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><p>跨域是 Web 开发中常见的安全问题之一，它是由浏览器的同源策略引起的。同源策略是浏览器的一种安全措施，它限制了一个域的脚本与另一个域的资源进行交互。如果协议、端口（如果有指定）或主机对于两个页面不同，则这两个页面具有不同的源。</p>
<h3 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h3><p>当一个网页尝试请求另一个与自己域名、端口号或协议不同的网页的资源时，就会发生跨域。例如，由 <code>http://example.com</code> 发起的 AJAX 请求尝试访问 <code>https://api.anotherdomain.com</code> 的资源，由于协议和域名不同，这将是一个跨域请求。</p>
<h3 id="常见的解决方法"><a href="#常见的解决方法" class="headerlink" title="常见的解决方法"></a>常见的解决方法</h3><ol>
<li><p><strong>CORS（跨源资源共享）</strong>:</p>
<ul>
<li>最常用的解决跨域问题的方法是在服务器端设置 CORS。这种方法通过在服务器的响应头中添加 <code>Access-Control-Allow-Origin</code> 来允许特定的外部域访问资源。</li>
<li>例如，<code>Access-Control-Allow-Origin: *</code> 允许所有域名访问资源，而 <code>Access-Control-Allow-Origin: http://example.com</code> 只允许 <code>http://example.com</code> 访问资源。</li>
</ul>
</li>
<li><p><strong>JSONP（JSON with Padding）</strong>:</p>
<ul>
<li>早期解决跨域问题的一种技术，主要用于 GET 请求。</li>
<li>它通过动态创建 <code>&lt;script&gt;</code> 标签来向不同源的服务器请求数据。服务器端返回的数据被包装在一个函数调用中。</li>
<li>JSONP 的缺点是它只支持 GET 请求，并且安全性较低。</li>
</ul>
</li>
<li><p><strong>代理服务器</strong>:</p>
<ul>
<li>使用代理服务器进行跨域请求。在这种情况下，浏览器向代理服务器发送请求，代理服务器将请求发送到目标服务器，并将响应返回给浏览器。</li>
<li>这种方法的优点是可以控制和缓存请求，但缺点是增加了服务器端的复杂性和成本。</li>
</ul>
</li>
<li><p><strong>PostMessage</strong>:</p>
<ul>
<li><code>window.postMessage</code> 是 HTML5 引入的一种安全的跨源通信方法。</li>
<li>这种方法允许不同源之间的窗口相互通信，适用于在不同域之间传递信息。</li>
</ul>
</li>
<li><p><strong>服务器端配置</strong>:</p>
<ul>
<li>对于某些服务，如字体或一些 API，可以在服务器配置文件（如 <code>.htaccess</code> 或 Nginx 配置文件）中设置允许跨域。</li>
</ul>
</li>
<li><p><strong>WebSockets</strong>:</p>
<ul>
<li>WebSockets 本身不受同源策略的限制，可以用于跨域通信。</li>
</ul>
</li>
</ol>
<h3 id="选择合适的方法"><a href="#选择合适的方法" class="headerlink" title="选择合适的方法"></a>选择合适的方法</h3><p>在选择解决跨域问题的方法时，需要考虑安全性、易用性和环境兼容性。对于大多数现代 Web 应用程序，推荐使用 CORS，因为它既安全又灵活。JSONP 可以作为旧系统的一种后备方案，但应谨慎使用，因为它容易受到 XSS 攻击。代理服务器在需要控制或缓存请求时非常有效，但会增加复杂性和成本。</p>
<h2 id="XSS-攻击"><a href="#XSS-攻击" class="headerlink" title="XSS 攻击"></a>XSS 攻击</h2><h3 id="XSS-攻击是什么？"><a href="#XSS-攻击是什么？" class="headerlink" title="XSS 攻击是什么？"></a>XSS 攻击是什么？</h3><p>XSS（跨站脚本攻击，Cross-Site Scripting）是一种在网页上执行恶意脚本的攻击方式，主要目标是在用户的浏览器中执行未经授权的代码。它允许攻击者注入可执行的脚本代码到合法的网页中，这些脚本在其他用户的浏览器中运行时，攻击者可以窃取用户的会话令牌、登录凭证，或者对用户进行其他恶意操作。</p>
<p>XSS 攻击通常分为以下几种类型：</p>
<ol>
<li><p><strong>存储型 XSS</strong>:</p>
<ul>
<li>恶意脚本被永久地存储在目标服务器上（如数据库、消息论坛、访客留言等），当用户访问含有恶意脚本的页面时，脚本就会执行。</li>
</ul>
</li>
<li><p><strong>反射型 XSS</strong>:</p>
<ul>
<li>恶意脚本作为请求的一部分发送给服务器，然后服务器将其作为响应的一部分返回，脚本在用户浏览器执行。这通常涉及到欺骗用户点击一个恶意链接。</li>
</ul>
</li>
<li><p><strong>DOM 型 XSS</strong>:</p>
<ul>
<li>通过恶意脚本修改页面的 DOM 结构实现的攻击，这种攻击完全在客户端进行，不涉及到服务器端的数据处理。</li>
</ul>
</li>
</ol>
<h3 id="如何防范-XSS-攻击？"><a href="#如何防范-XSS-攻击？" class="headerlink" title="如何防范 XSS 攻击？"></a>如何防范 XSS 攻击？</h3><ol>
<li><p><strong>转义输入内容</strong>:</p>
<ul>
<li>对用户输入的内容进行适当的转义处理，特别是在插入到 HTML 页面、JavaScript 代码或 URL 中时。例如，转义 HTML 特殊字符（如 <code>&lt;</code> 变为 <code>&amp;lt;</code>、<code>&gt;</code> 变为 <code>&amp;gt;</code>）。</li>
</ul>
</li>
<li><p><strong>使用内容安全策略（CSP）</strong>:</p>
<ul>
<li>实施内容安全策略（CSP）是防止 XSS 的一种有效方法。CSP 允许网站管理员定义哪些内容源是可信的，可以有效阻止恶意脚本的加载和执行。</li>
</ul>
</li>
<li><p><strong>验证和过滤输入</strong>:</p>
<ul>
<li>对所有用户输入进行严格的验证和过滤，确保输入的内容不包含恶意脚本。</li>
</ul>
</li>
<li><p><strong>使用 HTTP 的 Cookie <code>HttpOnly</code> 属性</strong>:</p>
<ul>
<li>将敏感的 cookie 标记为 <code>HttpOnly</code>，可以阻止 JavaScript 访问这些 cookie，从而减少某些类型的 XSS 攻击。</li>
</ul>
</li>
<li><p><strong>避免直接在 JavaScript 中嵌入用户输入</strong>:</p>
<ul>
<li>避免在 JavaScript 代码中直接使用用户输入的数据，特别是在构建动态 HTML 或执行其他动态操作时。</li>
</ul>
</li>
<li><p><strong>框架的内置 XSS 防护</strong>:</p>
<ul>
<li>许多现代的 Web 开发框架提供了自动的 XSS 防护。了解并正确使用这些框架的安全特性是非常重要的。</li>
</ul>
</li>
<li><p><strong>正则表达式过滤</strong>:</p>
<ul>
<li>使用正则表达式或其他方法过滤可能的攻击向量。</li>
</ul>
</li>
</ol>
<h2 id="git-flow"><a href="#git-flow" class="headerlink" title="git flow"></a>git flow</h2><p>Git Flow 是一种基于 Git 的分支管理策略，由 Vincent Driessen 在 2010 年提出。它定义了一组规范化的分支操作，旨在帮助团队更有效地进行版本控制和软件发布。Git Flow 中的主要分支包括：<code>master</code>、<code>develop</code>、<code>feature</code>、<code>release</code> 和 <code>hotfix</code> 分支。</p>
<h3 id="主要分支"><a href="#主要分支" class="headerlink" title="主要分支"></a>主要分支</h3><ol>
<li><p><strong>Main 分支</strong>:</p>
<ul>
<li>用于存储正式发布的历史。</li>
<li>每次在 main 分支上进行提交，都应该对应一个版本发布。</li>
</ul>
</li>
<li><p><strong>Develop 分支</strong>:</p>
<ul>
<li>开发分支，是为了开发新功能、改进和日常工作而设置的。</li>
<li>通常所有新功能都会首先合并到这个分支。</li>
</ul>
</li>
</ol>
<h3 id="辅助分支"><a href="#辅助分支" class="headerlink" title="辅助分支"></a>辅助分支</h3><ol>
<li><p><strong>Feature 分支</strong>:</p>
<ul>
<li>从 <code>develop</code> 分支派生出来。</li>
<li>用于开发新功能。</li>
<li>完成开发后，会合并回 <code>develop</code> 分支。</li>
<li>分支命名通常遵循 <code>feature/</code> 的模式。</li>
</ul>
</li>
<li><p><strong>Release 分支</strong>:</p>
<ul>
<li>从 <code>develop</code> 分支派生出来，用于准备即将发布的版本。</li>
<li>允许进行最后的调整（如 bug 修复、文档编写等）。</li>
<li>完成后，应该合并到 <code>main</code> 和 <code>develop</code> 分支。</li>
<li>分支命名通常遵循 <code>release/</code> 的模式。</li>
</ul>
</li>
<li><p><strong>Hotfix 分支</strong>:</p>
<ul>
<li>从 <code>main</code> 分支派生出来，用于修复生产环境中的紧急问题。</li>
<li>修复完成后，应该合并到 <code>main</code> 和 <code>develop</code> 分支。</li>
<li>分支命名通常遵循 <code>hotfix/</code> 的模式。</li>
</ul>
</li>
</ol>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol>
<li><p><strong>新功能开发</strong>:</p>
<ul>
<li>从 <code>develop</code> 分支创建新的 <code>feature</code> 分支。</li>
<li>完成开发后，将 <code>feature</code> 分支合并回 <code>develop</code>。</li>
</ul>
</li>
<li><p><strong>发布准备</strong>:</p>
<ul>
<li>当 <code>develop</code> 分支达到一个稳定点，从中创建一个 <code>release</code> 分支。</li>
<li>在 <code>release</code> 分支上完成最后的测试和修订。</li>
<li>完成后，将 <code>release</code> 分支合并到 <code>main</code> 和 <code>develop</code>。</li>
</ul>
</li>
<li><p><strong>紧急修复</strong>:</p>
<ul>
<li>当在生产版本中发现紧急问题时，从 <code>main</code> 分支创建 <code>hotfix</code> 分支。</li>
<li>完成修复后，将 <code>hotfix</code> 分支合并到 <code>main</code> 和 <code>develop</code>。</li>
</ul>
</li>
<li><p><strong>发布</strong>:</p>
<ul>
<li>在 <code>main</code> 分支上的每次合并都应该对应一个新的版本发布。</li>
</ul>
</li>
</ol>
<h3 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h3><ul>
<li><p><strong>优点</strong>:</p>
<ul>
<li>清晰定义了不同类型的分支和它们的用途。</li>
<li>适合大型项目和需要严格发布管理的场景。</li>
</ul>
</li>
<li><p><strong>缺点</strong>:</p>
<ul>
<li>流程相对复杂，可能不适合小团队或轻量级项目。</li>
<li>需要团队成员理解并遵循规定的流程。</li>
</ul>
</li>
</ul>
<h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p>中间人攻击（Man-in-the-Middle Attack，简称 MITM ）是一种常见的网络安全威胁，其中攻击者秘密地拦截并可能更改通信双方之间的通信。在这种攻击中，攻击者插入自己到受害者之间的通信过程，使受害者认为他们正在直接与预期的通信对象进行通信。</p>
<h3 id="如何进行中间人攻击"><a href="#如何进行中间人攻击" class="headerlink" title="如何进行中间人攻击"></a>如何进行中间人攻击</h3><ol>
<li><p><strong>拦截通信</strong>:</p>
<ul>
<li>攻击者首先需要找到一种方式拦截双方之间的通信。这可以通过多种方式实现，比如在无线网络中拦截 Wi-Fi 信号，或者在网络路由中插入恶意设备。</li>
</ul>
</li>
<li><p><strong>监听和&#x2F;或篡改数据</strong>:</p>
<ul>
<li>一旦通信被拦截，攻击者就能够监听通信内容，并且在必要时更改传输的数据。</li>
</ul>
</li>
<li><p><strong>伪装和欺骗</strong>:</p>
<ul>
<li>攻击者可能会伪装成通信的一方，向另一方发送消息。在受害者看来，这些消息看起来是从他们预期的通信对象发送的。</li>
</ul>
</li>
</ol>
<h3 id="常见的中间人攻击类型"><a href="#常见的中间人攻击类型" class="headerlink" title="常见的中间人攻击类型"></a>常见的中间人攻击类型</h3><ol>
<li><p><strong>电子邮件劫持</strong>:</p>
<ul>
<li>攻击者拦截并更改电子邮件内容。</li>
</ul>
</li>
<li><p><strong>Wi-Fi 欺骗</strong>:</p>
<ul>
<li>在公共 Wi-Fi 中，攻击者可以创建一个假冒的 Wi-Fi 热点，诱使用户连接，并拦截通过该网络的数据。</li>
</ul>
</li>
<li><p><strong>HTTPS 欺骗</strong>:</p>
<ul>
<li>攻击者通过伪造证书来拦截和解密 HTTPS 加密的通信。</li>
</ul>
</li>
<li><p><strong>DNS 劫持</strong>:</p>
<ul>
<li>攻击者篡改 DNS 服务器的响应，将用户重定向到恶意网站。</li>
</ul>
</li>
<li><p><strong>会话劫持</strong>:</p>
<ul>
<li>攻击者窃取用户的会话令牌，以获取对用户账户的访问权限。</li>
</ul>
</li>
</ol>
<h3 id="如何防范中间人攻击"><a href="#如何防范中间人攻击" class="headerlink" title="如何防范中间人攻击"></a>如何防范中间人攻击</h3><ol>
<li><p><strong>使用加密协议</strong>:</p>
<ul>
<li>使用 HTTPS、SSL&#x2F;TLS 等加密协议可以保护数据传输的安全。</li>
</ul>
</li>
<li><p><strong>验证证书</strong>:</p>
<ul>
<li>确保网站的证书是有效的，并且由可信的证书颁发机构签发。</li>
</ul>
</li>
<li><p><strong>VPN 使用</strong>:</p>
<ul>
<li>使用虚拟私人网络（VPN）可以在公共网络上提供加密的通信通道。</li>
</ul>
</li>
<li><p><strong>强化 Wi-Fi 安全</strong>:</p>
<ul>
<li>使用强密码和最新的 Wi-Fi 安全协议（如 WPA3）。</li>
</ul>
</li>
</ol>
<h2 id="单点登录-SSO"><a href="#单点登录-SSO" class="headerlink" title="单点登录 SSO"></a>单点登录 SSO</h2><h3 id="单点登录（SSO）的理解"><a href="#单点登录（SSO）的理解" class="headerlink" title="单点登录（SSO）的理解"></a>单点登录（SSO）的理解</h3><p>单点登录（Single Sign-On，简称 SSO）是一种身份验证服务，它允许用户使用一组登录凭证（例如用户名和密码）来访问多个应用程序。目的是通过减少用户需要记住的密码数量和登录次数，来提高用户体验和安全性。</p>
<h3 id="SSO-的工作原理"><a href="#SSO-的工作原理" class="headerlink" title="SSO 的工作原理"></a>SSO 的工作原理</h3><ol>
<li><p><strong>中央认证</strong>:</p>
<ul>
<li>在 SSO 系统中，存在一个中央认证服务器。用户首次尝试访问应用时，会被重定向到这个认证服务器。</li>
</ul>
</li>
<li><p><strong>身份验证</strong>:</p>
<ul>
<li>用户在认证服务器上输入登录凭证（如用户名和密码）。如果凭证有效，认证服务器会创建一个认证令牌（通常是一个临时的、加密的令牌）。</li>
</ul>
</li>
<li><p><strong>令牌颁发</strong>:</p>
<ul>
<li>认证服务器将令牌发放给用户，令牌表明用户已被验证。</li>
</ul>
</li>
<li><p><strong>访问应用</strong>:</p>
<ul>
<li>用户再次尝试访问原来的应用或其他应用时，会携带这个令牌。应用会向认证服务器验证令牌的有效性。</li>
</ul>
</li>
<li><p><strong>授权访问</strong>:</p>
<ul>
<li>如果认证服务器确认令牌有效，用户将被授权访问应用。这一过程对用户来说是透明的，无需再次输入登录凭证。</li>
</ul>
</li>
<li><p><strong>会话创建</strong>:</p>
<ul>
<li>每个应用会为用户创建一个会话，允许用户在不再输入凭证的情况下访问。</li>
</ul>
</li>
</ol>
<h3 id="SSO-的流程"><a href="#SSO-的流程" class="headerlink" title="SSO 的流程"></a>SSO 的流程</h3><ol>
<li><p><strong>登录请求</strong>:</p>
<ul>
<li>用户首次访问某个应用时，会被重定向到 SSO 的认证服务器。</li>
</ul>
</li>
<li><p><strong>输入凭证</strong>:</p>
<ul>
<li>用户在认证服务器上输入登录凭证。</li>
</ul>
</li>
<li><p><strong>身份验证</strong>:</p>
<ul>
<li>认证服务器验证用户凭证。如果验证成功，则生成认证令牌。</li>
</ul>
</li>
<li><p><strong>重定向回应用</strong>:</p>
<ul>
<li>用户携带令牌返回应用。</li>
</ul>
</li>
<li><p><strong>令牌验证</strong>:</p>
<ul>
<li>应用向认证服务器验证令牌的有效性。</li>
</ul>
</li>
<li><p><strong>授权与访问</strong>:</p>
<ul>
<li>一旦令牌被确认有效，应用将允许用户访问，用户无需再次登录。</li>
</ul>
</li>
<li><p><strong>访问其他应用</strong>:</p>
<ul>
<li>当用户访问其他集成了 SSO 的应用时，只需重复令牌验证步骤，无需再次登录。</li>
</ul>
</li>
</ol>
<h3 id="SSO-的优势和挑战"><a href="#SSO-的优势和挑战" class="headerlink" title="SSO 的优势和挑战"></a>SSO 的优势和挑战</h3><ul>
<li><p><strong>优势</strong>:</p>
<ul>
<li>提高用户体验：用户只需记住一套凭证。</li>
<li>增加安全性：减少密码泄露的风险，便于集中管理。</li>
<li>减少管理工作：为管理员提供集中的用户管理和审计。</li>
</ul>
</li>
<li><p><strong>挑战</strong>:</p>
<ul>
<li>集成复杂性：对现有系统进行 SSO 集成可能复杂。</li>
<li>单点故障：认证服务器出现问题可能导致所有应用不可用。</li>
<li>安全风险：如果认证服务器被攻破，所有关联应用都可能受到影响。</li>
</ul>
</li>
</ul>
<h2 id="TypeScript-interface-type"><a href="#TypeScript-interface-type" class="headerlink" title="TypeScript interface type"></a>TypeScript interface type</h2><h3 id="语法和功能"><a href="#语法和功能" class="headerlink" title="语法和功能"></a>语法和功能</h3><ol>
<li><p><strong>扩展方式</strong>:</p>
<ul>
<li><code>interface</code> 可以被扩展和实现（extends 和 implements）。这使得它们非常适合定义对象的形状或类的契约。</li>
<li><code>type</code> 可以通过交集（<code>&amp;</code>）来组合现有类型，但不能使用 <code>extends</code> 或 <code>implements</code>。这使得 <code>type</code> 更适合联合类型或特定函数的签名。</li>
</ul>
</li>
<li><p><strong>声明合并</strong>:</p>
<ul>
<li><code>interface</code> 支持声明合并，即同名的 <code>interface</code> 会被自动合并为一个。</li>
<li><code>type</code> 不支持声明合并。</li>
</ul>
</li>
</ol>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li><p><strong>Interface</strong>:</p>
<ul>
<li>当定义对象的结构或类的契约时，推荐使用 <code>interface</code>。尤其是在定义库的类型或外部 API 的类型定义时，<code>interface</code> 由于其可扩展性，更加合适。</li>
<li>示例：<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Employee</span> <span class="keyword">extends</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">salary</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>Type</strong>:</p>
<ul>
<li>当需要使用联合类型或元组类型时，或者你的类型不适合通过一个简单的接口来表示时，应该使用 <code>type</code>。</li>
<li>示例：<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Operation</span> = <span class="string">&#x27;add&#x27;</span> | <span class="string">&#x27;subtract&#x27;</span> | <span class="string">&#x27;multiply&#x27;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = [<span class="built_in">boolean</span>, <span class="built_in">string</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="性能考虑"><a href="#性能考虑" class="headerlink" title="性能考虑"></a>性能考虑</h3><ul>
<li>在大多数情况下，<code>interface</code> 和 <code>type</code> 在性能上没有显著差异。</li>
<li>但在某些大型项目中，<code>interface</code> 由于其声明合并的特性，可能会稍微提高编译速度。</li>
</ul>
<h3 id="兼容性和扩展性"><a href="#兼容性和扩展性" class="headerlink" title="兼容性和扩展性"></a>兼容性和扩展性</h3><ul>
<li><code>interface</code> 更适合在声明 API 或库的类型定义时使用，因为它们更容易在不同的代码库中被扩展和维护。</li>
<li><code>type</code> 由于其能够表达更复杂的类型组合，提供了更多的灵活性。</li>
</ul>
<h2 id="函数入参实现类型映射"><a href="#函数入参实现类型映射" class="headerlink" title="函数入参实现类型映射"></a>函数入参实现类型映射</h2><p>在 TypeScript 中，你可以使用高级类型特性来实现函数入参的类型映射。这主要涉及到泛型和条件类型的使用。以下是一些实现类型映射的方法：</p>
<h3 id="1-使用泛型"><a href="#1-使用泛型" class="headerlink" title="1. 使用泛型"></a>1. 使用泛型</h3><p>泛型允许你定义一个函数，它可以适用于多种类型而不仅仅是一个。你可以在函数定义时声明一个泛型类型参数，然后在函数体内或作为参数类型使用它。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> output = identity&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;myString&quot;</span>);  <span class="comment">// 输出类型为 &#x27;string&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>T</code> 是一个泛型类型变量，它捕获传递给 <code>identity</code> 的参数类型。这样，你就可以使用这个类型来保证函数的输入和输出类型是一致的。</p>
<h3 id="2-条件类型"><a href="#2-条件类型" class="headerlink" title="2. 条件类型"></a>2. 条件类型</h3><p>条件类型（Conditional Types）允许你根据类型关系创建更复杂的类型表达式。它们在类型映射中非常有用，特别是当你想根据输入类型生成不同的输出类型时。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TypeName</span>&lt;T&gt; =</span><br><span class="line">    T <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="string">&quot;string&quot;</span> :</span><br><span class="line">    T <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="string">&quot;number&quot;</span> :</span><br><span class="line">    T <span class="keyword">extends</span> <span class="built_in">boolean</span> ? <span class="string">&quot;boolean&quot;</span> :</span><br><span class="line">    T <span class="keyword">extends</span> <span class="literal">undefined</span> ? <span class="string">&quot;undefined&quot;</span> :</span><br><span class="line">    T <span class="keyword">extends</span> <span class="title class_">Function</span> ? <span class="string">&quot;function&quot;</span> :</span><br><span class="line">    <span class="string">&quot;object&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> typeOf&lt;T&gt;(<span class="attr">arg</span>: T): <span class="title class_">TypeName</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> arg <span class="keyword">as</span> <span class="title class_">TypeName</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="title function_">typeOf</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// str 类型为 &quot;string&quot;</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="title function_">typeOf</span>(<span class="number">123</span>);     <span class="comment">// num 类型为 &quot;number&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>TypeName</code> 是一个条件类型，它根据传入的类型 <code>T</code> 返回不同的字符串字面量类型。</p>
<h3 id="3-映射类型"><a href="#3-映射类型" class="headerlink" title="3. 映射类型"></a>3. 映射类型</h3><p>映射类型（Mapped Types）允许你根据旧类型创建新类型。它们通过对一个已知的类型的每个属性应用某种变换来工作。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ReadOnly</span>&lt;T&gt; = &#123; <span class="keyword">readonly</span> [K <span class="keyword">in</span> keyof T]: T[K] &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> freeze&lt;T&gt;(<span class="attr">obj</span>: T): <span class="title class_">ReadOnly</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">freeze</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> original = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> frozen = <span class="title function_">freeze</span>(original); <span class="comment">// frozen 类型为 ReadOnly&lt;&#123; a: number; b: number; &#125;&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>ReadOnly</code> 是一个映射类型，它将 <code>T</code> 的所有属性标记为 <code>readonly</code>。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>根据你的具体需求，你可以选择使用泛型、条件类型或映射类型来实现函数参数的类型映射。这些高级类型特性提供了强大的工具，可以帮助你创建灵活且类型安全的代码。</p>
<h2 id="HTTPS-工作原理"><a href="#HTTPS-工作原理" class="headerlink" title="HTTPS 工作原理"></a>HTTPS 工作原理</h2><p>HTTPS（全称为 Hyper Text Transfer Protocol Secure）是 HTTP 的安全版本。它主要通过 SSL&#x2F;TLS 协议来提供身份验证和加密通信，以保护数据在互联网上的传输。以下是 HTTPS 的主要工作原理：</p>
<h3 id="1-加密"><a href="#1-加密" class="headerlink" title="1. 加密"></a>1. 加密</h3><p>HTTPS 使用对称加密和非对称加密相结合的方式来保护数据传输的安全：</p>
<ul>
<li><strong>非对称加密</strong>：在建立连接阶段使用，用于安全地交换对称密钥。</li>
<li><strong>对称加密</strong>：在交换密钥之后，对传输的数据进行加密。</li>
</ul>
<h3 id="2-SSL-x2F-TLS-握手"><a href="#2-SSL-x2F-TLS-握手" class="headerlink" title="2. SSL&#x2F;TLS 握手"></a>2. SSL&#x2F;TLS 握手</h3><p>当你的浏览器连接到一个 HTTPS 网站时，会发生一个叫做 SSL&#x2F;TLS 握手的过程，它包括以下步骤：</p>
<ol>
<li><p><strong>客户端发送加密偏好</strong>：</p>
<ul>
<li>浏览器（客户端）向服务器发送一个“Client Hello”消息，其中包含支持的 SSL&#x2F;TLS 版本、加密算法选项等。</li>
</ul>
</li>
<li><p><strong>服务器响应</strong>：</p>
<ul>
<li>服务器选择一组最合适的加密算法和 SSL&#x2F;TLS 版本，并且发送一个“Server Hello”消息给客户端。同时，服务器还会发送它的公钥和证书。</li>
</ul>
</li>
<li><p><strong>验证服务器证书</strong>：</p>
<ul>
<li>客户端验证服务器的 SSL&#x2F;TLS 证书（通常是由第三方证书机构 CA 颁发的）。证书验证包括检查证书是否过期、是否被撤销，以及是否由可信的 CA 签发。</li>
</ul>
</li>
<li><p><strong>客户端响应</strong>：</p>
<ul>
<li>一旦验证了服务器的证书，客户端生成一个随机的对称加密密钥，并使用服务器的公钥加密这个密钥，然后发送给服务器。</li>
</ul>
</li>
<li><p><strong>服务器解密密钥</strong>：</p>
<ul>
<li>服务器使用其私钥解密客户端发送的对称密钥。</li>
</ul>
</li>
<li><p><strong>加密通信</strong>：</p>
<ul>
<li>从这一步开始，客户端和服务器使用对称密钥来加密通信数据，确保数据传输的安全性。</li>
</ul>
</li>
</ol>
<h3 id="3-安全通信"><a href="#3-安全通信" class="headerlink" title="3. 安全通信"></a>3. 安全通信</h3><p>一旦 SSL&#x2F;TLS 握手完成，客户端和服务器之间的通信就会使用对称加密保护。这意味着即使通信被拦截，没有密钥的第三方也无法解读通信内容。</p>
<h3 id="4-会话结束"><a href="#4-会话结束" class="headerlink" title="4. 会话结束"></a>4. 会话结束</h3><p>当通信结束时，会话密钥会被丢弃。如果用户再次访问服务器，将进行新的握手过程和密钥交换。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>HTTPS 通过结合使用对称和非对称加密，以及通过可信的 CA 验证服务器的身份，有效保护了数据传输的安全性。虽然 HTTPS 在性能上有一定的开销，但它显著提升了网络通信的安全性，对于保护敏感数据，如登录凭据、支付信息等，是非常重要的。</p>
<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>在网络通信中，端口的作用主要是区分同一台主机上的不同服务或进程。端口是一种数字标记，它与 IP 地址一起使用，以标识主机上运行的特定应用程序或服务的实例。端口位于 OSI 七层模型的传输层（第四层），该层还包括定义传输协议，如 TCP（传输控制协议）和 UDP（用户数据报协议）。</p>
<h3 id="端口的作用"><a href="#端口的作用" class="headerlink" title="端口的作用"></a>端口的作用</h3><ol>
<li><p><strong>区分服务</strong>:</p>
<ul>
<li>在一台主机上可能运行着多种网络服务，如 HTTP 服务器、FTP 服务器、邮件服务器等。端口用于区分这些服务，例如，HTTP 默认使用端口 80，而 FTP 默认使用端口 21。</li>
</ul>
</li>
<li><p><strong>通信管理</strong>:</p>
<ul>
<li>端口允许同一物理网络上的多个应用程序同时进行通信，每个应用程序都可以有自己的端口号。</li>
</ul>
</li>
<li><p><strong>连接指定</strong>:</p>
<ul>
<li>在一个网络连接中，一个端口号与一个 IP 地址组合在一起，可以精确地指定通信的发送方和接收方。</li>
</ul>
</li>
</ol>
<h2 id="ESLint-Prettier-Husky-Lint-Staged"><a href="#ESLint-Prettier-Husky-Lint-Staged" class="headerlink" title="ESLint Prettier Husky Lint-Staged"></a>ESLint Prettier Husky Lint-Staged</h2><p>这些工具是现代前端开发中常用的代码质量和风格一致性工具。它们各自扮演着不同的角色：</p>
<h3 id="1-ESLint"><a href="#1-ESLint" class="headerlink" title="1. ESLint"></a>1. ESLint</h3><ul>
<li><strong>用途</strong>：ESLint 是一个静态代码分析工具，用于识别 JavaScript 中的问题。它不仅能找出错误，还能检测出代码风格的问题，如不一致的缩进、未使用的变量等。</li>
<li><strong>特点</strong>：<ul>
<li>可配置性高，可以根据项目需求自定义规则。</li>
<li>可以集成到多数编辑器和构建过程中。</li>
<li>支持 ES6+、React、Vue 等现代 JavaScript 特性。</li>
</ul>
</li>
</ul>
<h3 id="2-Prettier"><a href="#2-Prettier" class="headerlink" title="2. Prettier"></a>2. Prettier</h3><ul>
<li><strong>用途</strong>：Prettier 是一个代码格式化工具，它支持多种语言和文件格式。它强制执行一致的代码风格，确保整个团队的代码看起来和感觉一致。</li>
<li><strong>特点</strong>：<ul>
<li>重点关注代码的外观。</li>
<li>支持 JavaScript、TypeScript、CSS、HTML 等多种语言。</li>
<li>与 ESLint 不同，Prettier 不会检查代码错误。</li>
</ul>
</li>
</ul>
<h3 id="3-Husky"><a href="#3-Husky" class="headerlink" title="3. Husky"></a>3. Husky</h3><ul>
<li><strong>用途</strong>：Husky 是一个用于创建 Git 钩子（hooks）的工具。它可以在执行诸如提交（commit）或推送（push）等 Git 操作时自动运行脚本。</li>
<li><strong>特点</strong>：<ul>
<li>常用于在提交代码前自动运行 Lint 或测试。</li>
<li>防止不符合标准或有问题的代码被提交到仓库。</li>
</ul>
</li>
</ul>
<h3 id="4-Lint-Staged"><a href="#4-Lint-Staged" class="headerlink" title="4. Lint-Staged"></a>4. Lint-Staged</h3><ul>
<li><strong>用途</strong>：Lint-Staged 是一个在 Git 暂存文件（即即将被提交的文件）上运行 Linters 或其他工具的工具。</li>
<li><strong>特点</strong>：<ul>
<li>结合 Husky 使用，只对即将提交的更改执行 Lint 操作，而不是整个项目。</li>
<li>提高了代码质量，确保提交的代码符合预定义的规则。</li>
</ul>
</li>
</ul>
<h3 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h3><p>这些工具常常一起使用，以提高代码质量和提升开发效率：</p>
<ul>
<li>使用 ESLint 来检测代码中的问题和不一致性。</li>
<li>使用 Prettier 来格式化代码，确保一致的风格。</li>
<li>使用 Husky 创建 Git 钩子，在代码提交前自动运行 Lint 和测试。</li>
<li>使用 Lint-Staged 确保只检查和格式化被修改并准备提交的文件，而不是整个代码库。</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>JavaScript 中的迭代器是一个对象，它定义了一个 <code>next()</code> 方法，返回一个包含 <code>done</code> 和 <code>value</code> 属性的对象。当 <code>done</code> 为 <code>true</code> 时，表示迭代器已经遍历完所有元素。</p>
<p>以下是一个简单的迭代器实现示例，它迭代一个数字数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createIterator</span>(<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">next</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> currentIndex &lt; array.<span class="property">length</span> ?</span><br><span class="line">                &#123; <span class="attr">value</span>: array[currentIndex++], <span class="attr">done</span>: <span class="literal">false</span> &#125; :</span><br><span class="line">                &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">const</span> myArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> myIterator = <span class="title function_">createIterator</span>(myArray);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myIterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myIterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myIterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myIterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>createIterator</code> 函数接收一个数组并返回一个迭代器。迭代器的 <code>next</code> 方法在每次被调用时返回数组的下一个元素，直到数组被完全遍历。</p>
<p>请注意，这个迭代器是手动实现的，用于展示迭代器的基本原理。在实际的 JavaScript 开发中，你通常可以使用 ES6 提供的内置迭代器，比如通过 <code>for...of</code> 循环、展开操作符 <code>...</code> 或 <code>Array.prototype.entries()</code> 方法等来遍历可迭代对象。</p>
<h2 id="防抖（Debouncing）"><a href="#防抖（Debouncing）" class="headerlink" title="防抖（Debouncing）"></a>防抖（Debouncing）</h2><p>防抖（Debouncing）是一种优化技术，用于确保一个函数在特定时间内不被频繁调用。它是通过在指定时间内延迟函数的执行来实现的。如果在这段延迟时间内再次触发该函数，那么原来的延迟调用会被取消，并重新开始计算延迟时间。这对于一些需要频繁触发但执行成本较高的操作（如窗口大小调整、输入框内容变化等）非常有用。</p>
<p>下面是一个简单的防抖函数的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">const</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">onResize</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;窗口大小变化了！&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> debouncedResize = <span class="title function_">debounce</span>(onResize, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, debouncedResize);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>debounce</code> 函数接受两个参数：一个要执行的函数 <code>func</code> 和延迟时间 <code>wait</code>。返回的函数会在调用后等待指定的 <code>wait</code> 毫秒数，然后执行 <code>func</code>。如果在这个等待时间内再次被调用，之前的等待就会被清除，并重新开始计时。</p>
<p>这个防抖函数的应用示例是窗口调整大小事件的处理函数 <code>onResize</code>。通过使用 <code>debounce</code>，我们可以确保在窗口调整大小的过程中，<code>onResize</code> 函数不会被频繁调用，而是在调整结束后的 500 毫秒才执行一次。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/wechat.png" alt="moke 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202309041556302.jpg" alt="moke 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>moke
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://csumoke.com/2023/12/07/note-interview/" title="前端实习面试问题准备">https://csumoke.com/2023/12/07/note-interview/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/01/10/software-test-review/" rel="prev" title="软件测试复习">
                  <i class="fa fa-chevron-left"></i> 软件测试复习
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/10/26/vscode-PR/" rel="next" title="VSCode 下的 PR 流程">
                  VSCode 下的 PR 流程 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">moke</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">107k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">6:30</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9taXN0Lw==">NexT.Mist</span> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL2plcnJ5NzY1" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.0/jquery.min.js" integrity="sha256-2Pmvv0kuTBOenSvLm6bvfBSSHrUJ+3A7x6P5Ebd07/g=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>



  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":false,"archive":false,"delay":true,"timeout":3000,"priority":true,"url":"https://csumoke.com/2023/12/07/note-interview/"}</script>
  <script src="/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"csumoke","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

<script>(function (w, d, s, id) {
            if (typeof (w.webpushr) !== 'undefined') return; w.webpushr = w.webpushr || function () { (w.webpushr.q = w.webpushr.q || []).push(arguments) }; var js, fjs = d.getElementsByTagName(s)[0]; js = d.createElement(s); js.id = id; js.async = 1; js.src = "https://cdn.webpushr.com/app.min.js";fjs.parentNode.appendChild(js);}(window, document, 'script', 'webpushr-jssdk'));webpushr('setup', { 'key': 'BAs1f6Lvs7ZICIjDSN6zmGgXIS0HES-FCnkp3hYWJ0mxRWyJ0KbPvK_ggwuXiBcOu2JyKyfTjf5XuSIMCHShK_w' });</script></body>
</html>
