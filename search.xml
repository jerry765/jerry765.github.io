<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>一些建议</title>
    <url>/2023/07/28/advice/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
<p>I know nothing except the fact of my ignorance。<br>我唯一知道的就是我一无所知</p>

</blockquote>

<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>下列建议都出自同一个前提：各位同学对编程0基础</p>
<h3 id="计算机概览"><a href="#计算机概览" class="headerlink" title="计算机概览"></a>计算机概览</h3><p><strong>推荐阅读：</strong><br><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8zMDIwMDI0OC8=">普林斯顿大学计算机公开课<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>理由：</strong><br>通俗易懂，零基础入门，包含绝大部分所需要了解的基础知识</p>
<span id="more"></span>

<h3 id="前端编程入门"><a href="#前端编程入门" class="headerlink" title="前端编程入门"></a>前端编程入门</h3><p><strong>推荐观看：</strong><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXZzNDExTTdhVA==">为初学者准备的：HTML 速成<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWJXNDExUjdoZw==">为初学者准备的：CSS 速成<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMUp0NDExRDdqNg==">为初学者准备的：JavaScript 速成<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>理由：</strong><br>足够精练，两小时通览上手的必备知识。从实践中学习，是软件工程的精髓所在。</p>
<h3 id="后端编程入门"><a href="#后端编程入门" class="headerlink" title="后端编程入门"></a>后端编程入门</h3><p><strong>推荐阅读：</strong><br><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8yNjc5MjUyMS8=">C Primer Plus（第6版）中文版<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>理由：</strong><br>风趣幽默，无需预备知识。无论是浅尝辄止或反复品味都非常推荐。</p>
<h3 id="行业背景"><a href="#行业背景" class="headerlink" title="行业背景"></a>行业背景</h3><p><strong>推荐阅读：</strong><br><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8zMzQ3NDc1MC8=">浪潮之巅（第四版）（上下册）<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>理由：</strong><br>技术决定下限，变革的思想定义上限。</p>
<h2 id="一些小建议"><a href="#一些小建议" class="headerlink" title="一些小建议"></a>一些小建议</h2><ul>
<li>快速学习。网课、书籍、文档各有利弊，智者见智，快速入门后投入实践才是王道。<strong>实践是检验真理的唯一标准。</strong></li>
<li>保持谦逊。<strong>永远不要说自己精通。</strong></li>
<li>大胆提问。不耻上问，但要注意提问的礼仪。</li>
<li>劳逸结合。不做过多评价卷与躺，选择最适合自己的方式度过大学便可。人生有梦，各自精彩，永不要用同一个标杆衡量所有人。<strong>不是每一个人都有你所拥有的条件。</strong></li>
</ul>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>experience</category>
      </categories>
      <tags>
        <tag>university</tag>
        <tag>backend</tag>
        <tag>csu</tag>
        <tag>advice</tag>
        <tag>software engineering</tag>
        <tag>frontend</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构笔记</title>
    <url>/2023/09/27/data-structure-in-c/</url>
    <content><![CDATA[<blockquote>
<p>参考书籍：数据结构与算法分析（C语言描述） 原书第二版</p>
</blockquote>
<span id="more"></span>

<h2 id="第-1-章-引论"><a href="#第-1-章-引论" class="headerlink" title="第 1 章 引论"></a>第 1 章 引论</h2><p>递归的四条基本法则</p>
<ul>
<li><strong>基准情形</strong>：不用递归就能求解</li>
<li><strong>不断推进</strong>：递归调用必须能够朝着产生基本情形的方向推进</li>
<li><strong>设计法则</strong>：假设所有的递归调用都能运行</li>
<li><strong>合成效益法则</strong>（compound interest rule）：在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作</li>
</ul>
<h2 id="第-2-章-算法分析"><a href="#第-2-章-算法分析" class="headerlink" title="第 2 章 算法分析"></a>第 2 章 算法分析</h2><blockquote>
<p>计算任何事情不要超过一次</p>
</blockquote>
<h3 id="最大子序列和"><a href="#最大子序列和" class="headerlink" title="最大子序列和"></a>最大子序列和</h3><h4 id="算法1"><a href="#算法1" class="headerlink" title="算法1"></a>算法1</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MaxSubsequenceSum</span><span class="params">(<span class="type">const</span> <span class="type">int</span> A[], <span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ThisSum, MaxSum, i, j, k;</span><br><span class="line">    </span><br><span class="line">    MaxSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &lt; N; j++) &#123;</span><br><span class="line">            ThisSum = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (k = i; k &lt;= j; k++)&#123;</span><br><span class="line">                ThisSum += A[k];    <span class="comment">/* 过分耗时 */</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(ThisSum &gt; MaxSum) &#123;</span><br><span class="line">                MaxSum = ThisSum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MaxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度为<code>O(N*3)</code></p>
<h4 id="算法2"><a href="#算法2" class="headerlink" title="算法2"></a>算法2</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MaxSubSequenceSum</span><span class="params">(<span class="type">const</span> <span class="type">int</span> A[], <span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ThisSum, MaxSum, i, j;</span><br><span class="line"></span><br><span class="line">    MaxSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        ThisSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(j = i; j &lt; N; j++) &#123;</span><br><span class="line">            ThisSum += A[j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ThisSum &gt; MaxSum) &#123;</span><br><span class="line">                MaxSum = ThisSum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MaxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度为<code>O(N*2)</code></p>
<h4 id="算法3"><a href="#算法3" class="headerlink" title="算法3"></a>算法3</h4><p>分析知最大子序列和可能在三处出现，或者整个出现在输入数据的左半部，或者整个出现在右半部，或者跨越输入数据的中部从而占据左右两半部分。前两种情况可以递归求解，第三种情况的最大和可以通过求出前半部分的最大和（包括前半部分的最后一个元素）以及后半部分的最大和（包括后半部分的第一个元素）而得到。</p>
<p><strong>递归调用的一般形式是通过传递输入的数组以及左（Left）边界和右（Right）边界，它们界定了数组待处理的部分。单行驱动程序通过传递数组以及边界 0 和 N-1 以启动该过程。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">MaxSubSum</span><span class="params">(<span class="type">const</span> <span class="type">int</span> A[], <span class="type">int</span> Left, <span class="type">int</span> Right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> MaxLeftSum, MaxRightSum;</span><br><span class="line">    <span class="type">int</span> MaxLeftBorderSum, MaxRightBorderSum;</span><br><span class="line">    <span class="type">int</span> LeftBorderSum, RightBorderSum;</span><br><span class="line">    <span class="type">int</span> Center, i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Base Case</span></span><br><span class="line">    <span class="keyword">if</span>(Left == Right) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[Left] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> A[Left];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Center = (Left + Right)/<span class="number">2</span>;  <span class="comment">// assume N is even</span></span><br><span class="line">    MaxLeftSum = MaxSubSum(A, Left, Center);</span><br><span class="line">    MaxRightSum = MaxSubSum(A, Center + <span class="number">1</span>; right);</span><br><span class="line"></span><br><span class="line">    MaxLeftBorderSum = <span class="number">0</span>; LeftBorderSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = Center; i &gt;= Left; i--) &#123;</span><br><span class="line">        LeftBorderSum += A[i];</span><br><span class="line">        <span class="keyword">if</span>(LeftBorderSum &gt; MaxLeftBorderSum) &#123;</span><br><span class="line">            MaxLeftBorderSum = LeftBorderSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MaxRightBorderSum = <span class="number">0</span>; RightBorderSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = Center + <span class="number">1</span>; i &lt;= Right; i++) &#123;</span><br><span class="line">        RightBorderSum += A[i];</span><br><span class="line">        <span class="keyword">if</span>(RightBorderSum &gt; MaxRightBorderSum) &#123;</span><br><span class="line">            MaxRightBorderSum = RightBorderSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Max3(MaxLeftSum, MaxRightSum, MaxLeftBorderSum, MaxRightBorderSum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">MaxSubsequenceSum</span><span class="params">(<span class="type">const</span> <span class="type">int</span> A[], <span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MaxSubSum(A, <span class="number">0</span>, N - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度为<code>O(N)</code></p>
<h4 id="算法4"><a href="#算法4" class="headerlink" title="算法4"></a>算法4</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MaxSubsequenceSum</span><span class="params">(<span class="type">const</span> <span class="type">int</span> A[], <span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ThisSum, MaxSum, j;</span><br><span class="line"></span><br><span class="line">    ThisSum = MaxSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">        ThisSum += A[j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ThisSum &gt; MaxSum) &#123;</span><br><span class="line">            MaxSum = ThisSum;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ThisSum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ThisSum = <span class="number">0</span>;    <span class="comment">// clear ThisSum when negative</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MaxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在任意时刻，算法都能对它已经读入的数据给出子序列问题的正确答案，具有这种特性的算法叫做<strong>联机算法</strong>（on-line algorithm）。仅需要常量空间并以线性时间运行的联机算法几乎是完美的算法。</p>
<h2 id="第-3-章-表、栈和队列"><a href="#第-3-章-表、栈和队列" class="headerlink" title="第 3 章 表、栈和队列"></a>第 3 章 表、栈和队列</h2><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _List_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> PtrToNode List;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode Position;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"></span><br><span class="line">List <span class="title function_">MakeEmpty</span><span class="params">(List L)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmpty</span><span class="params">(List L)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">IsLast</span><span class="params">(Position P, List L)</span>;</span><br><span class="line">Position <span class="title function_">Find</span><span class="params">(ElementType X, List L)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Delete</span><span class="params">(ElementType X, List L)</span>;</span><br><span class="line">Position <span class="title function_">FindPrevious</span><span class="params">(ElementType X, List L)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">(ElementType X, List L, Position P)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DeleteList</span><span class="params">(List L)</span>;</span><br><span class="line">Position <span class="title function_">Header</span><span class="params">(List L)</span>;</span><br><span class="line">Position <span class="title function_">First</span><span class="params">(List L)</span>;</span><br><span class="line">Position <span class="title function_">Advance</span><span class="params">(Position P)</span>;</span><br><span class="line">ElementType <span class="title function_">Retrieve</span><span class="params">(Position P)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">/* _List_H */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Place in the implementation file</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Element;</span><br><span class="line">    Position Next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return true if L is empty</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmpty</span><span class="params">(List L)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> L-&gt;Next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return true if P is the last position in list L</span></span><br><span class="line"><span class="comment">// Parameter L is unused in this implementation</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsLast</span><span class="params">(Position P, List L)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> P-&gt;Next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return Position of X in L; NULL if not found</span></span><br><span class="line">Position <span class="title function_">Find</span><span class="params">(ElementType X, List L)</span> &#123;</span><br><span class="line">    Position P;</span><br><span class="line"></span><br><span class="line">    P = L-&gt;Next;</span><br><span class="line">    <span class="keyword">while</span>(P != <span class="literal">NULL</span> &amp;&amp; P-&gt;Element != X) &#123;</span><br><span class="line">        P = P-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete first occurrence of X from a list</span></span><br><span class="line"><span class="comment">// Assume use of a header node</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delete</span><span class="params">(ElementType X, List L)</span> &#123;</span><br><span class="line">    Position P, TempCell;</span><br><span class="line"></span><br><span class="line">    P = FindPrevious(X, L);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!IsLast(P, L)) &#123;</span><br><span class="line">        <span class="comment">// Assumption of header use</span></span><br><span class="line">        <span class="comment">// X is found, delete it</span></span><br><span class="line">        TempCell = P-&gt;Next;</span><br><span class="line">        P-&gt;Next = TempCell-&gt;Next; <span class="comment">// Bypass deleted cell</span></span><br><span class="line">        <span class="built_in">free</span>(TempCell);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If X is not found, then next field of returned</span></span><br><span class="line"><span class="comment">// Position is NULL</span></span><br><span class="line"><span class="comment">// Assumes a header</span></span><br><span class="line">Position <span class="title function_">FindPrevious</span><span class="params">(ElementType X, List L)</span> &#123;</span><br><span class="line">    Position P;</span><br><span class="line"></span><br><span class="line">    P = L;</span><br><span class="line">    <span class="keyword">while</span>(P-&gt;Next != <span class="literal">NULL</span> &amp;&amp; P-&gt;Next-&gt;Element != X) &#123;</span><br><span class="line">        P = P-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert (after legal position P)</span></span><br><span class="line"><span class="comment">// Header implementation assumed</span></span><br><span class="line"><span class="comment">// Parameter L is unused in this implementation</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">(ElementType X, List L, Position P)</span> &#123;</span><br><span class="line">    Position TmpCell;</span><br><span class="line"></span><br><span class="line">    TmpCell = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    <span class="keyword">if</span>(TmpCell == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        FatalError(<span class="string">&quot;Out of space!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TmpCell-&gt;Element = X;</span><br><span class="line">    TmpCell-&gt;Next = P-&gt;Next;</span><br><span class="line">    P-&gt;Next = TmpCell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeleteList</span><span class="params">(List L)</span> &#123;</span><br><span class="line">    Position P, Tmp;</span><br><span class="line"></span><br><span class="line">    P = L-&gt;Next;    <span class="comment">// Header assumed</span></span><br><span class="line">    L-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (P != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Tmp = P-&gt;Next;</span><br><span class="line">        <span class="built_in">free</span>(P);</span><br><span class="line">        P = Tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第-4-章-树"><a href="#第-4-章-树" class="headerlink" title="第 4 章 树"></a>第 4 章 树</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树的一个性质是<strong>平均二叉树的深度要比 N 小的多</strong>，这个平均深度为**O(根号 N)<strong>；对于二叉查找树（binary search tree），深度的平均值为</strong>O(log N)**。</p>
<h4 id="平均情形分析"><a href="#平均情形分析" class="headerlink" title="平均情形分析"></a>平均情形分析</h4><p>假设所有树出现的机会均等，则树的所有节点的平均深度为**O(log N)**。</p>
<ul>
<li>平衡条件：任何节点的深度均不得过深</li>
<li>放弃平衡条件，允许树有任意的深度，但是在每次操作之后要使用一个规则进行调整，使得后面的操作效率更高。<strong>自调查（self-adjusting）类结构</strong>。</li>
</ul>
<h3 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h3><p>一颗 AVL 树是其每个节点的左子树和右子树的高度最多差 1 的二叉查找树。（空树的高度定义为-1。）在高度为 h 的 AVL 树中，最少节点数 S(h) 由 S(h)&#x3D;S(h-1)+S(h-2)+1 给出。</p>
<p>插入一个节点可能破坏 AVL 树的特性，通过旋转进行修正。高度不平衡时，必须重新平衡的节点的两棵子树的高度差 2 。</p>
<h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p>把树形象地看成柔软灵活的，重力作用。<br>除旋转引起的局部变化外，树的其余部分必须知晓该变化。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>递归地将 X 插入到了 T 的相应的子树中。如果子树的高度不变，那么插入完成。否则，如果 T 中出现了高度不平衡，那么我们根据 X 以及 T 和子树中的关键字做适当的单旋转或双旋转，更新这些高度（并解决好与树的其余部分的连接），从而完成插入。</p>
<!-- TODO：寻找满意的旋转图 -->

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">ifdef</span> _AVLTree_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AvlNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AvlNode</span> *<span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AvlNode</span> *<span class="title">AvlTree</span>;</span>    <span class="comment">// AVL树</span></span><br><span class="line"></span><br><span class="line">AvlTree <span class="title function_">MakeEmpty</span><span class="params">(AvlTree T)</span>;</span><br><span class="line">Position <span class="title function_">Find</span><span class="params">(ElementType X, AvlTree T)</span>;</span><br><span class="line">Position <span class="title function_">FindMin</span><span class="params">(AvlTree T)</span>;</span><br><span class="line">Position <span class="title function_">FindMax</span><span class="params">(AvlTree T)</span>;</span><br><span class="line">AvlTree <span class="title function_">Insert</span><span class="params">(ElementType X, AvlTree T)</span>;</span><br><span class="line">AvlTree <span class="title function_">Delete</span><span class="params">(ElementType X, AvlTree T)</span>;</span><br><span class="line">ElementType <span class="title function_">Retrieve</span><span class="params">(Position P)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> <span class="comment">/* _AVLTree_H */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Place in the implementation file</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AvlNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Element;</span><br><span class="line">    AvlTree Left;</span><br><span class="line">    AvlTree Right;</span><br><span class="line">    <span class="type">int</span> Height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">Height</span><span class="params">(Position P)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (P == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> P-&gt;Height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AvlTree <span class="title function_">Insert</span><span class="params">(ElementType X, AvlTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Create and return a one-node tree</span></span><br><span class="line">        T = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> AvlNode));</span><br><span class="line">        <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">            FatalError(<span class="string">&quot;Out of space!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            T-&gt;Element = X;</span><br><span class="line">            T-&gt;Height = <span class="number">0</span>;</span><br><span class="line">            T-&gt;Left = T-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &lt; T-&gt;Element)</span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;Left = Insert(X, T-&gt;Left);</span><br><span class="line">        <span class="keyword">if</span> (Height(T-&gt;Left) - Height(T-&gt;Right) == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> (X &lt; T-&gt;Left-&gt;Element)</span><br><span class="line">                T = SingleRotateWithLeft(T);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T = DoubleRotateWithLeft(T);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &gt; T-&gt;Element)</span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;Right = Insert(X, T-&gt;Right);</span><br><span class="line">        <span class="keyword">if</span> (Height(T-&gt;Right) - Height(T-&gt;Left) == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> (X &gt; T-&gt;Right-&gt;Element)</span><br><span class="line">                T = SingleRotateWithRight(T);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T = DoubleRotateWithRight(T);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Else X is in the tree already; we&#x27;ll do nothing</span></span><br><span class="line"></span><br><span class="line">    T-&gt;Height = Max(Height(T-&gt;Left), Height(T-&gt;Right)) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Position <span class="title function_">SingleRotateWithLeft</span><span class="params">(Position K2)</span></span><br><span class="line">&#123;</span><br><span class="line">    Position K1;</span><br><span class="line"></span><br><span class="line">    K1 = K2-&gt;Left;</span><br><span class="line">    K2-&gt;Left = K1-&gt;Right;</span><br><span class="line">    K1-&gt;Right = K2;</span><br><span class="line"></span><br><span class="line">    K2-&gt;Height = Max(Height(K2-&gt;Left), Height(K2-&gt;Right)) + <span class="number">1</span>;</span><br><span class="line">    K1-&gt;Height = Max(Height(K1-&gt;Left), K2-&gt;Height) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> K1;  <span class="comment">// New root</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Position <span class="title function_">SingleRotateWithRight</span><span class="params">(Position K1)</span></span><br><span class="line">&#123;</span><br><span class="line">    Position K2;</span><br><span class="line"></span><br><span class="line">    K2 = K1-&gt;Right;</span><br><span class="line">    K1-&gt;Right = K2-&gt;Left;</span><br><span class="line">    K2-&gt;Left = K1;</span><br><span class="line"></span><br><span class="line">    K1-&gt;Height = Max(Height(K1-&gt;Left), Height(K1-&gt;Right)) + <span class="number">1</span>;</span><br><span class="line">    K2-&gt;Height = Max(Height(K2-&gt;Right), K1-&gt;Height) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> K2;  <span class="comment">// New root</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Position <span class="title function_">DoubleRotateWithLeft</span><span class="params">(Position K3)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Rotate between K1 and K2</span></span><br><span class="line">    K3-&gt;Left = SingleRotateWithRight(K3-&gt;Left);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rotate between K3 and K2</span></span><br><span class="line">    <span class="keyword">return</span> SingleRotateWithLeft(K3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Position <span class="title function_">DoubleRotateWithRight</span><span class="params">(Position K1)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Rotate between K3 and K2</span></span><br><span class="line">    K1-&gt;Right = SingleRotateWithLeft(K1-&gt;Right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rotate between K1 and K2</span></span><br><span class="line">    <span class="keyword">return</span> SingleRotateWithRight(K1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="伸展树"><a href="#伸展树" class="headerlink" title="伸展树"></a>伸展树</h3><p>伸展树（splay tree）保证从空树开始连续 M 次对树的操作最多花费<code>O(M log N)</code>时间，并不保证任意一次操作花费 O（N） 时间的可能。<em>不存在坏的输入序列</em>。<br><em>当 M 次操作的序列总的最坏情形运行时间为 O(MF(N)) 时，我们就说它的摊还（amortized）运行时间为 O(F(N))。</em>一颗伸展树每次操作的摊还代价为 <code>O(log N)</code>。<br>伸展树是基于这样的事实：对于二叉查找树来说，每次操作最坏情形时间 O(N) 并不坏，只要它相对不常发生就行。累积的运行时间很重要。<br><em>只要有一个节点被访问，它就必须被移动。当一个节点被访问后，它就要经过一系列的 AVL 树的旋转后放到根上。</em></p>
<p>伸展树不要求保留高度或平衡信息，因此它在某种程度上节省空间并简化代码。</p>
]]></content>
      <categories>
        <category>GEE</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>前端实习面试问题准备</title>
    <url>/2023/12/07/note-interview/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="视频播放器进度条"><a href="#视频播放器进度条" class="headerlink" title="视频播放器进度条"></a>视频播放器进度条</h2><p>视频播放器的进度条是一种用户界面组件，它显示了视频播放的当前位置和总时长，并允许用户通过拖动或点击进度条来跳转到视频的不同位置。实现这一功能通常涉及以下几个关键步骤：</p>
<ol>
<li><p><strong>HTML结构</strong>: 使用HTML创建进度条的基本结构。通常包括一个容器（如<code>div</code>元素），内部可能有用于显示进度的子元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;progress-bar-container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;progress-bar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>CSS样式</strong>: 通过CSS对进度条进行样式设计，如宽度、高度、颜色等。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#progress-bar-container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: grey;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#progress-bar</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0%</span>; <span class="comment">/* 初始宽度 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>JavaScript交互</strong>:</p>
<ul>
<li><p><strong>播放进度更新</strong>: 使用JavaScript监听视频播放器的<code>timeupdate</code>事件。当事件触发时，根据视频的<code>currentTime</code>和<code>duration</code>属性计算进度，并更新进度条的宽度。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> video = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;my-video&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> progressBar = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;progress-bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line">video.<span class="title function_">addEventListener</span>(<span class="string">&#x27;timeupdate&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> progress = (video.<span class="property">currentTime</span> / video.<span class="property">duration</span>) * <span class="number">100</span>;</span><br><span class="line">    progressBar.<span class="property">style</span>.<span class="property">width</span> = progress + <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>用户交互处理</strong>: 允许用户通过点击或拖动进度条来跳转视频。这通常涉及监听进度条的点击事件，计算点击位置相对于进度条的百分比，然后将视频的<code>currentTime</code>设置为<code>duration</code>乘以这个百分比。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> progressBarContainer = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;progress-bar-container&#x27;</span>);</span><br><span class="line"></span><br><span class="line">progressBarContainer.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> percent = e.<span class="property">offsetX</span> / progressBarContainer.<span class="property">offsetWidth</span>;</span><br><span class="line">    video.<span class="property">currentTime</span> = percent * video.<span class="property">duration</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>这些步骤展示了一个基本的视频播放器进度条的实现方式。当然，实际应用中可能需要更复杂的处理，比如考虑缓冲状态的显示、拖动操作的优化等。</p>
<span id="more"></span>

<h2 id="Node-js-单线程如何保证线程不中断？"><a href="#Node-js-单线程如何保证线程不中断？" class="headerlink" title="Node.js 单线程如何保证线程不中断？"></a>Node.js 单线程如何保证线程不中断？</h2><p>Node.js 被广泛认为是单线程的，但这个说法需要更准确的解释。Node.js 的主执行线程是单线程的，它运行在 V8 JavaScript 引擎上。然而，Node.js 使用多线程来处理 I&#x2F;O 密集型任务，这是通过其底层的 libuv 库实现的。以下是 Node.js 保证其单线程不中断的几个关键方面：</p>
<ol>
<li><p><strong>异步非阻塞 I&#x2F;O</strong>:</p>
<ul>
<li>Node.js 主要依靠事件循环和回调函数来处理 I&#x2F;O 操作（如文件读写、网络请求等），这些操作是异步和非阻塞的。</li>
<li>当一个 I&#x2F;O 操作开始时，它会被发送到事件循环，并继续执行后续的代码，而不是等待 I&#x2F;O 操作完成。当 I&#x2F;O 操作完成时，相应的回调函数会被放入事件队列中，等待主线程空闲时执行。</li>
</ul>
</li>
<li><p><strong>事件驱动架构</strong>:</p>
<ul>
<li>Node.js 使用事件驱动模型来处理各种异步操作。每当有事件发生时（如数据到达、超时、处理完成），相应的回调函数会被触发。</li>
<li>这种模型使得 Node.js 能够在不被阻塞的情况下高效地处理大量的并发请求。</li>
</ul>
</li>
<li><p><strong>libuv 库</strong>:</p>
<ul>
<li>尽管 JavaScript 代码在单个主线程上运行，Node.js 使用 libuv 库在背后管理一个线程池。</li>
<li>对于一些复杂的操作（如文件系统操作、某些加密操作），libuv 会在后台的多个线程上执行这些任务，而主线程继续执行 JavaScript 代码。</li>
</ul>
</li>
<li><p><strong>错误处理机制</strong>:</p>
<ul>
<li>Node.js 提供了异常处理机制，比如 <code>try-catch</code> 块和全局的 <code>uncaughtException</code> 事件，来处理同步和异步代码中的错误。</li>
<li>正确的错误处理能够防止异常导致主线程崩溃。</li>
</ul>
</li>
<li><p><strong>进程管理</strong>:</p>
<ul>
<li>对于 CPU 密集型任务，可以使用 Node.js 的 <code>child_process</code> 模块来创建子进程，分担主线程的负载。</li>
<li>还可以使用集群（Cluster）模块来创建多个进程，每个进程都有自己的事件循环和 V8 实例，可以更好地利用多核 CPU。</li>
</ul>
</li>
</ol>
<p>通过这些机制，Node.js 能够确保即使是在单个主线程上运行，也能高效地处理大量的并发 I&#x2F;O 操作，同时避免线程中断和阻塞。</p>
<h2 id="websocket-建立连接的过程"><a href="#websocket-建立连接的过程" class="headerlink" title="websocket 建立连接的过程"></a>websocket 建立连接的过程</h2><p>WebSocket 建立连接的过程是一个升级自 HTTP 协议的握手过程。WebSocket 允许在用户的浏览器和服务器之间建立一个持久的连接，使得数据可以双向传输。下面是 WebSocket 建立连接的详细步骤：</p>
<ol>
<li><p><strong>客户端发送握手请求</strong>:</p>
<ul>
<li>首先，客户端（通常是一个网页的 JavaScript）通过发送一个 HTTP 请求来初始化 WebSocket 连接。这个请求被称为”握手请求”。</li>
<li>这个请求使用普通的 HTTP GET 方法，但在请求头中包含特定的头部字段，指示这是一个 WebSocket 连接请求。主要的头部字段包括：<ul>
<li><code>Upgrade: websocket</code>：告诉服务器，客户端希望将 HTTP 连接升级到 WebSocket。</li>
<li><code>Connection: Upgrade</code>：同样表示这是一个升级请求。</li>
<li><code>Sec-WebSocket-Key</code>：一个 Base64 编码的随机值，服务器将用它来构建一个响应密钥，验证连接。</li>
<li><code>Sec-WebSocket-Version</code>：标示客户端支持的 WebSocket 版本。</li>
<li><code>Origin</code>（可选）：指示请求来自哪个源，用于服务器的跨源策略。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>服务器响应握手</strong>:</p>
<ul>
<li>服务器解析这个握手请求，如果接受升级请求，则会发送一个 HTTP 101 Switching Protocols 响应。</li>
<li>服务器的响应也包含几个特定的头部字段：<ul>
<li><code>Upgrade: websocket</code> 和 <code>Connection: Upgrade</code>：确认升级到 WebSocket。</li>
<li><code>Sec-WebSocket-Accept</code>：这是对客户端 <code>Sec-WebSocket-Key</code> 的响应，由服务器生成，客户端会验证这个值以确认连接的有效性。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>连接建立</strong>:</p>
<ul>
<li>客户端收到服务器的 101 响应后，WebSocket 连接被视为已经建立，客户端和服务器就可以开始通过这个连接双向传输数据了。</li>
<li>此时，连接从 HTTP 协议升级为 WebSocket 协议。</li>
</ul>
</li>
<li><p><strong>数据传输</strong>:</p>
<ul>
<li>一旦连接建立，客户端和服务器就可以开始发送和接收消息。</li>
<li>WebSocket 协议支持文本和二进制数据的传输。</li>
</ul>
</li>
<li><p><strong>保持连接</strong>:</p>
<ul>
<li>WebSocket 连接会保持活跃状态，直到客户端或服务器决定关闭连接。</li>
<li>连接保持活跃使得双方可以随时发送数据，无需重新建立连接。</li>
</ul>
</li>
</ol>
<p>这个握手过程的设计允许 WebSocket 连接轻松地穿过大多数防火墙，因为它们在初始阶段模仿标准的 HTTP 连接。这种方法还使得在不支持 WebSocket 的环境中回退到其他协议（如长轮询）变得更加容易。</p>
<h2 id="websocket和长轮询的区别"><a href="#websocket和长轮询的区别" class="headerlink" title="websocket和长轮询的区别"></a>websocket和长轮询的区别</h2><p>WebSocket 和长轮询（Long Polling）是两种在客户端和服务器之间实现实时数据通信的技术，但它们在工作原理和效率方面有显著区别。下面是 WebSocket 和长轮询之间的主要区别：</p>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><ol>
<li><p><strong>持久连接</strong>:</p>
<ul>
<li>WebSocket 协议建立的是一个持久的、全双工的连接。一旦连接建立，客户端和服务器可以随时互相发送数据，直到任一方主动关闭连接。</li>
</ul>
</li>
<li><p><strong>协议升级</strong>:</p>
<ul>
<li>WebSocket 通过一次 HTTP 握手升级到 WebSocket 协议。握手完成后，协议从 HTTP 切换到 WebSocket，这个连接将保持打开状态，不再是 HTTP 协议。</li>
</ul>
</li>
<li><p><strong>高效率</strong>:</p>
<ul>
<li>因为连接是持久的，所以不存在为了每次数据交换而建立和终止连接的额外开销。这使得 WebSocket 在数据实时性和网络效率方面优于长轮询。</li>
</ul>
</li>
<li><p><strong>双向通信</strong>:</p>
<ul>
<li>WebSocket 支持全双工通信，即客户端和服务器可以同时发送和接收数据。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>:</p>
<ul>
<li>适合需要高频率、实时性强的应用场景，例如在线游戏、实时聊天、实时数据更新等。</li>
</ul>
</li>
</ol>
<h3 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h3><ol>
<li><p><strong>基于 HTTP 请求</strong>:</p>
<ul>
<li>长轮询是在标准的 HTTP 协议上工作的。客户端发送一个 HTTP 请求到服务器，服务器保持这个请求开放直到有数据可发送。</li>
</ul>
</li>
<li><p><strong>非持久连接</strong>:</p>
<ul>
<li>每次服务器向客户端发送响应后，连接被关闭。对于新的数据，客户端需要发起新的 HTTP 请求。</li>
</ul>
</li>
<li><p><strong>效率较低</strong>:</p>
<ul>
<li>长轮询需要频繁地建立和关闭 HTTP 连接，这在某些场景下可能导致较高的网络开销和延迟。</li>
</ul>
</li>
<li><p><strong>单向请求模式</strong>:</p>
<ul>
<li>尽管长轮询可以较快地将服务器的更新推送到客户端，但它本质上仍然是一种单向请求模式，即服务器不能主动向客户端发送消息，除非客户端首先发送请求。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>:</p>
<ul>
<li>适合对实时性要求不是特别高的应用，或是在不支持 WebSocket 的环境中作为替代方案使用。</li>
</ul>
</li>
</ol>
<p>总结来说，WebSocket 提供了更高效、更适合实时通信的双向连接，而长轮询是一种更简单、在旧浏览器上更容易实现的替代方案。WebSocket 是实现实时应用的首选技术，但在某些场景下，长轮询可能因其简单性和兼容性而被选择。</p>
<h2 id="tcp-如何保证可靠性"><a href="#tcp-如何保证可靠性" class="headerlink" title="tcp 如何保证可靠性"></a>tcp 如何保证可靠性</h2><p>TCP（传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。它通过一系列机制来保证数据传输的可靠性，包括：</p>
<ol>
<li><p><strong>三次握手建立连接</strong>:</p>
<ul>
<li>在传输数据之前，TCP 使用一种被称为“三次握手”的过程来建立连接。这确保了双方都准备好接收和发送数据，并防止了初始化连接时的一些常见的问题。</li>
</ul>
</li>
<li><p><strong>序列号和确认应答</strong>:</p>
<ul>
<li>TCP 给发送的每个数据包分配一个序列号，并要求接收方对每个接收到的数据包发送确认（ACK）。</li>
<li>如果发送方在预定的超时时间内没有收到对特定数据包的确认，它会重新发送该数据包。</li>
</ul>
</li>
<li><p><strong>数据校验和</strong>:</p>
<ul>
<li>每个 TCP 数据包包含一个校验和，以确保数据在传输过程中没有被破坏或更改。</li>
<li>如果接收方检测到数据包损坏（校验和不匹配），它将丢弃该数据包并不发送确认，导致发送方重新发送数据。</li>
</ul>
</li>
<li><p><strong>流量控制</strong>:</p>
<ul>
<li>TCP 使用窗口大小控制来进行流量控制，以避免发送方过快发送数据，导致接收方来不及处理。</li>
<li>接收方通过在确认应答中指定一个“窗口大小”来告诉发送方它还能接收多少数据，从而控制发送方的数据发送速率。</li>
</ul>
</li>
<li><p><strong>拥塞控制</strong>:</p>
<ul>
<li>TCP 还实现了拥塞控制机制，以避免网络中过多的数据包导致网络拥塞。</li>
<li>当网络拥塞时，TCP 会减少其数据传输速率，并在网络状况改善时逐渐增加速率。</li>
</ul>
</li>
<li><p><strong>乱序数据重新排序</strong>:</p>
<ul>
<li>由于网络原因，TCP 数据包可能会乱序到达。TCP 在接收端会根据序列号重新对数据包进行排序，以确保数据的正确顺序。</li>
</ul>
</li>
<li><p><strong>保持活动检测</strong>:</p>
<ul>
<li>TCP 定期发送保持活动包，以检测连接是否仍然有效，防止“死”连接占用资源。</li>
</ul>
</li>
</ol>
<p>通过这些机制，TCP 能够在不可靠的互联网环境中提供可靠的数据传输服务。这些特性使得 TCP 成为了许多需要高可靠性数据传输的应用（如Web页面加载、文件传输、电子邮件等）的理想选择。</p>
<h2 id="拥塞算法"><a href="#拥塞算法" class="headerlink" title="拥塞算法"></a>拥塞算法</h2><p>TCP拥塞控制算法是为了解决和避免网络拥塞问题而设计的一组算法。当多个网络设备尝试同时发送过多数据时，网络拥塞可能发生，导致网络性能下降和数据包丢失。TCP拥塞控制算法的目的是确保每个网络连接获得公平的带宽使用，并减少数据包丢失。下面是一些主要的TCP拥塞控制算法：</p>
<ol>
<li><p><strong>慢启动（Slow Start）</strong>:</p>
<ul>
<li>在TCP连接开始时，慢启动算法被用来探测网络的载荷能力。</li>
<li>慢启动通过逐渐增加拥塞窗口（Congestion Window, cwnd）的大小来增加网络中的数据量，开始时cwnd从一个或几个数据包开始，每收到一个确认响应，cwnd就增加一倍，呈指数增长。</li>
<li>当cwnd达到一个阈值（ssthresh）时，切换到拥塞避免算法。</li>
</ul>
</li>
<li><p><strong>拥塞避免（Congestion Avoidance）</strong>:</p>
<ul>
<li>在拥塞避免阶段，每经过一个往返时间（Round-Trip Time, RTT），cwnd线性增加一个数据包，而不是指数增长。</li>
<li>这个阶段旨在维持网络载荷在一个相对稳定的水平。</li>
</ul>
</li>
<li><p><strong>快重传（Fast Retransmit）</strong>:</p>
<ul>
<li>快重传是指在接收方连续收到三个相同的确认（Triple Duplicate ACKs）时，立即重传丢失的数据包，而不是等待重传计时器到期。</li>
<li>这种机制可以更快地纠正丢包的情况。</li>
</ul>
</li>
<li><p><strong>快恢复（Fast Recovery）</strong>:</p>
<ul>
<li>快恢复算法与快重传一起工作，当检测到丢包（通过三个重复的 ACK ）时，它会减少 cwnd 的大小而不是像慢启动时那样将其减至1，通常将 cwnd 设置为 ssthresh 的一半。</li>
<li>在快恢复阶段，对于每个接收到的重复 ACK ， cwnd 逐渐增加，直到收到新的数据确认。</li>
</ul>
</li>
<li><p><strong>TCP Tahoe 和 Reno</strong>:</p>
<ul>
<li>TCP Tahoe 和 Reno 是两种实现了上述拥塞控制算法的TCP变体。</li>
<li>Tahoe 使用慢启动、拥塞避免和快重传，但在检测到丢包时，它会将cwnd重置为1。</li>
<li>Reno 则引入了快恢复算法，它在丢包时减少cwnd而不是重置。</li>
</ul>
</li>
<li><p><strong>其他算法</strong>:</p>
<ul>
<li>随着网络技术的发展，出现了更多的拥塞控制算法，如TCP Vegas, TCP BBR（Bottleneck Bandwidth and RTT）等，它们在不同的网络环境和场景中提供了改进的性能。</li>
</ul>
</li>
</ol>
<p>TCP拥塞控制算法的设计旨在使TCP连接能够自适应网络状况的变化，优化网络资源的使用，同时保证网络的稳定性和公平性。随着网络条件的不断变化，这些算法也在不断地进化和优化。</p>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>TCP（传输控制协议）的三次握手（Three-Way Handshake）过程是用于在两个网络实体之间建立一个可靠的连接的关键机制。这个过程不仅用于协商和初始化连接参数，还用于确保双方准备好进行数据传输。下面是三次握手的详细介绍：</p>
<h3 id="第一次握手：SYN"><a href="#第一次握手：SYN" class="headerlink" title="第一次握手：SYN"></a>第一次握手：SYN</h3><ol>
<li><p><strong>发起方发送SYN包</strong>:</p>
<ul>
<li>连接的发起方（客户端）开始握手过程，发送一个包含 SYN（同步序列编号）标志的数据包到接收方（服务器）。</li>
<li>在这个数据包中，发起方选择一个随机的序列号（Seq &#x3D; X），这个序列号在后续数据传输中用于保证数据的有序和完整性。</li>
</ul>
</li>
<li><p><strong>目的</strong>:</p>
<ul>
<li>主要是向接收方表明发起方希望建立连接。</li>
</ul>
</li>
</ol>
<h3 id="第二次握手：SYN-ACK"><a href="#第二次握手：SYN-ACK" class="headerlink" title="第二次握手：SYN-ACK"></a>第二次握手：SYN-ACK</h3><ol>
<li><p><strong>接收方响应SYN-ACK包</strong>:</p>
<ul>
<li>接收方收到 SYN 包后，需要确认这个请求。它发送一个包含 SYN 和 ACK（确认响应）标志的数据包。</li>
<li>这个数据包中的确认号（Ack &#x3D; X + 1）是对发起方 SYN 包中序列号的确认，同时接收方也选择自己的一个随机序列号（Seq &#x3D; Y）。</li>
</ul>
</li>
<li><p><strong>目的</strong>:</p>
<ul>
<li>确认发起方的 SYN，并且通知发起方接收方也准备好建立连接。</li>
</ul>
</li>
</ol>
<h3 id="第三次握手：ACK"><a href="#第三次握手：ACK" class="headerlink" title="第三次握手：ACK"></a>第三次握手：ACK</h3><ol>
<li><p><strong>发起方发送ACK包</strong>:</p>
<ul>
<li>发起方收到 SYN-ACK 包后，发送一个包含 ACK 标志的数据包，这个包的确认号被设置为接收方的序列号加一（Ack &#x3D; Y + 1）。</li>
<li>这一步完成了对接收方初始序列号的确认。</li>
</ul>
</li>
<li><p><strong>连接建立</strong>:</p>
<ul>
<li>一旦接收方收到这个 ACK 包，连接就被认为是建立了。现在，双方都已确认彼此的初始序列号，并且都准备好进行数据传输。</li>
</ul>
</li>
</ol>
<h3 id="为什么需要三次握手？"><a href="#为什么需要三次握手？" class="headerlink" title="为什么需要三次握手？"></a>为什么需要三次握手？</h3><p>三次握手的设计是为了确保双方都能确认对方的接收和发送能力。它主要解决了以下几个问题：</p>
<ul>
<li>确保双方都知道对方准备好发送和接收数据。</li>
<li>避免旧的延迟连接初始化请求突然建立连接。</li>
<li>确保在连接开始时双方的序列号被正确初始化和同步。</li>
</ul>
<p>这个过程是建立一个可靠的 TCP 连接的基础，确保了数据传输的可靠性和顺序性。</p>
<h2 id="http-和-tcp-的-keep-alive-区别"><a href="#http-和-tcp-的-keep-alive-区别" class="headerlink" title="http 和 tcp 的 keep-alive 区别"></a>http 和 tcp 的 keep-alive 区别</h2><p>HTTP Keep-Alive 和 TCP Keep-Alive 是两种不同层次上的保持连接活跃的机制，它们的目的和实现方式有所不同：</p>
<h3 id="HTTP-Keep-Alive"><a href="#HTTP-Keep-Alive" class="headerlink" title="HTTP Keep-Alive"></a>HTTP Keep-Alive</h3><ol>
<li><p><strong>层次</strong>:</p>
<ul>
<li>HTTP Keep-Alive 工作在应用层，是 HTTP 协议的一部分。</li>
</ul>
</li>
<li><p><strong>目的</strong>:</p>
<ul>
<li>HTTP Keep-Alive 的主要目的是减少建立和关闭连接的频繁操作，提高 HTTP 传输效率。</li>
<li>它允许在一个 TCP 连接上发送和接收多个 HTTP 请求&#x2F;响应，而不需要为每个请求&#x2F;响应对重新建立新的 TCP 连接。</li>
</ul>
</li>
<li><p><strong>实现</strong>:</p>
<ul>
<li>在 HTTP 1.1 中，默认开启 Keep-Alive。</li>
<li>客户端和服务器在 HTTP 头部信息中通过 <code>Connection: keep-alive</code> 来通告对方它们希望保持连接打开。</li>
<li>连接会保持活跃直到客户端或服务器决定关闭，或者超过预定的超时时间。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>:</p>
<ul>
<li>HTTP Keep-Alive 特别适用于需要多个连续的 HTTP 请求&#x2F;响应的场景，如网页加载中包含多个资源（CSS、JavaScript、图片等）的情况。</li>
</ul>
</li>
</ol>
<h3 id="TCP-Keep-Alive"><a href="#TCP-Keep-Alive" class="headerlink" title="TCP Keep-Alive"></a>TCP Keep-Alive</h3><ol>
<li><p><strong>层次</strong>:</p>
<ul>
<li>TCP Keep-Alive 工作在传输层，是 TCP 协议的一部分。</li>
</ul>
</li>
<li><p><strong>目的</strong>:</p>
<ul>
<li>TCP Keep-Alive 的目的是检测死亡连接（即长时间无数据交换的连接），确保连接的双方仍然可达。</li>
<li>它用于维护和监控 TCP 连接的状态。</li>
</ul>
</li>
<li><p><strong>实现</strong>:</p>
<ul>
<li>TCP Keep-Alive 通过定期发送探测数据包来实现。如果在一定次数的探测后仍然没有收到响应，则认为连接已经断开，并关闭连接。</li>
<li>这个机制在某些操作系统中默认关闭，并且探测间隔和次数可以配置。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>:</p>
<ul>
<li>TCP Keep-Alive 适用于任何基于 TCP 的网络服务，特别是那些可能长时间空闲但需要保持连接的场景，如数据库连接。</li>
</ul>
</li>
</ol>
<h3 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h3><ul>
<li><strong>层次不同</strong>：HTTP Keep-Alive 是应用层协议，TCP Keep-Alive 是传输层协议。</li>
<li><strong>目的不同</strong>：HTTP Keep-Alive 用于提高 HTTP 效率，减少连接重建的开销；而 TCP Keep-Alive 用于检测和维护连接的活跃状态。</li>
<li><strong>适用范围</strong>：HTTP Keep-Alive 仅用于 HTTP 协议，而 TCP Keep-Alive 适用于所有基于 TCP 的通信。</li>
<li><strong>工作方式</strong>：HTTP Keep-Alive 通过重用连接进行多个请求&#x2F;响应交换，TCP Keep-Alive 通过发送探测数据包来检测连接状态。</li>
</ul>
<h2 id="js-闭包、原型、事件循环"><a href="#js-闭包、原型、事件循环" class="headerlink" title="js 闭包、原型、事件循环"></a>js 闭包、原型、事件循环</h2><h3 id="闭包（Closure）"><a href="#闭包（Closure）" class="headerlink" title="闭包（Closure）"></a>闭包（Closure）</h3><p>闭包是 JavaScript 中一个非常重要的特性，它允许一个函数访问并操作该函数外部的变量。</p>
<ol>
<li><p><strong>定义</strong>: 在 JavaScript 中，当一个函数嵌套在另一个函数内，并引用外层函数的变量时，就形成了闭包。</p>
</li>
<li><p><strong>作用</strong>:</p>
<ul>
<li><strong>访问外部函数的变量</strong>: 内部函数可以访问定义在外部函数中的变量，即使外部函数已经执行完毕。</li>
<li><strong>数据封装和私有性</strong>: 闭包可以用来创建私有变量，提供类似于面向对象编程中的封装和隐藏数据的功能。</li>
</ul>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> secret = <span class="string">&quot;I&#x27;m a secret!&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">innerFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(secret);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getSecret = <span class="title function_">outerFunction</span>();</span><br><span class="line"><span class="title function_">getSecret</span>(); <span class="comment">// 输出 &quot;I&#x27;m a secret!&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="原型（Prototype）"><a href="#原型（Prototype）" class="headerlink" title="原型（Prototype）"></a>原型（Prototype）</h3><p>原型是 JavaScript 中实现继承和共享属性或方法的一种机制。</p>
<ol>
<li><p><strong>原型对象</strong>: 每个 JavaScript 对象都有一个原型对象（<code>prototype</code>），对象从其原型继承属性和方法。</p>
</li>
<li><p><strong>原型链</strong>: 当访问一个对象的属性或方法时，如果该对象自身不包含这个属性或方法，JavaScript 会沿着原型链向上查找，直到找到或到达原型链的顶端（<code>Object.prototype</code>）。</p>
</li>
<li><p><strong>使用</strong>:</p>
<ul>
<li>常用于创建具有相似属性和方法的多个对象，提高代码复用性。</li>
<li>原型链是 JavaScript 中实现继承的基础。</li>
</ul>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">person1.<span class="title function_">sayHello</span>(); <span class="comment">// 输出 &quot;Hello, my name is Alice&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="事件循环（Event-Loop）"><a href="#事件循环（Event-Loop）" class="headerlink" title="事件循环（Event Loop）"></a>事件循环（Event Loop）</h3><p>事件循环是 JavaScript 中处理异步操作和保持单线程运行的机制。</p>
<ol>
<li><p><strong>单线程和异步</strong>: JavaScript 是单线程语言，但支持异步编程（例如，通过回调函数、Promises、async&#x2F;await）。</p>
</li>
<li><p><strong>任务类型</strong>:</p>
<ul>
<li><strong>宏任务（Macro Task）</strong>: 如 <code>setTimeout</code>, <code>setInterval</code>, I&#x2F;O 操作。</li>
<li><strong>微任务（Micro Task）</strong>: 如 Promise 回调、<code>process.nextTick</code>（在 Node.js 中）。</li>
</ul>
</li>
<li><p><strong>工作机制</strong>:</p>
<ul>
<li>事件循环不断检查是否有待执行的任务。</li>
<li>如果执行栈为空，事件循环会查看任务队列。如果队列中有宏任务，从队列中取出一个执行。</li>
<li>在每个宏任务执行之后，事件循环会处理所有的微任务队列，之后再执行下一个宏任务。</li>
<li>这个循环持续进行，直到所有任务完成。</li>
</ul>
</li>
<li><p><strong>示例</strong>:</p>
<ul>
<li>异步操作（如通过 <code>setTimeout</code> 设置的定时器）不会立即执行，而是被加入队列，在当前和其他微任务执行完毕后再执行。</li>
</ul>
</li>
</ol>
<h2 id="webpack-与-vite"><a href="#webpack-与-vite" class="headerlink" title="webpack 与 vite"></a>webpack 与 vite</h2><p>Webpack 和 Vite 是两种流行的前端构建工具，它们用于优化开发和生产环境下的前端项目。虽然两者的目标相似，但它们在实现方式和性能上有明显的区别：</p>
<h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><ol>
<li><p><strong>概念</strong>:</p>
<ul>
<li>Webpack 是一个模块打包器（bundler），主要用于 JavaScript 和相关资源文件（如 CSS、图片）的模块化构建和打包。</li>
</ul>
</li>
<li><p><strong>工作原理</strong>:</p>
<ul>
<li>Webpack 通过一个入口点开始，分析项目中的模块和资源依赖，将这些资源转换和打包成少数几个文件，通常用于生产环境。</li>
</ul>
</li>
<li><p><strong>特点</strong>:</p>
<ul>
<li><strong>灵活性和配置性</strong>：Webpack 提供了广泛的插件系统和配置选项，适用于复杂的项目需求。</li>
<li><strong>热模块替换（HMR）</strong>：在开发环境中，Webpack 支持热模块替换，允许应用在运行时更新模块而无需完全刷新。</li>
<li><strong>慢启动</strong>：由于需要分析整个项目的依赖和资源，Webpack 的启动和热更新可能比较慢。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>:</p>
<ul>
<li>适用于需要复杂配置和高度定制化构建流程的大型项目。</li>
</ul>
</li>
</ol>
<h3 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h3><ol>
<li><p><strong>概念</strong>:</p>
<ul>
<li>Vite 是一个更现代的前端构建工具，利用了最新的前端技术，如原生 ES 模块加载。</li>
</ul>
</li>
<li><p><strong>工作原理</strong>:</p>
<ul>
<li>在开发环境中，Vite 作为一个服务器运行，它利用浏览器原生的 ES 模块导入功能来服务模块请求。</li>
<li>在生产环境中，Vite 使用 Rollup 进行高效的打包。</li>
</ul>
</li>
<li><p><strong>特点</strong>:</p>
<ul>
<li><strong>快速启动</strong>：由于使用了原生 ES 模块，Vite 在开发环境中可以快速启动，无需等待打包过程。</li>
<li><strong>按需编译</strong>：Vite 只编译当前请求的模块，而不是整个应用，这使得热更新非常快。</li>
<li><strong>简化配置</strong>：Vite 设计理念倾向于减少配置，提供更简洁的开发体验。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>:</p>
<ul>
<li>适用于新项目，尤其是在追求快速开发和简化构建配置的场景下。</li>
</ul>
</li>
</ol>
<h3 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h3><ul>
<li><strong>启动速度</strong>：Vite 在开发环境中的启动速度通常比 Webpack 快，因为它不需要预先打包整个应用。</li>
<li><strong>热更新速度</strong>：Vite 的热更新通常比 Webpack 快，因为它只编译变更的模块。</li>
<li><strong>构建原理</strong>：Webpack 是一个传统的模块打包器，而 Vite 利用了现代浏览器的原生 ES 模块特性。</li>
<li><strong>兼容性</strong>：Webpack 支持更广泛的模块格式和浏览器兼容性，而 Vite 主要针对现代浏览器。</li>
<li><strong>配置复杂性</strong>：Webpack 的配置通常更复杂，而 Vite 旨在提供更简洁的配置。</li>
</ul>
<h2 id="vue2-和-vue3"><a href="#vue2-和-vue3" class="headerlink" title="vue2 和 vue3"></a>vue2 和 vue3</h2><p>Vue.js 是一个流行的 JavaScript 框架，用于构建用户界面和单页应用程序。Vue 3 是 Vue.js 的最新主要版本，相比于 Vue 2，它引入了许多新特性和改进。以下是 Vue 2 和 Vue 3 之间的主要区别：</p>
<h3 id="性能改进"><a href="#性能改进" class="headerlink" title="性能改进"></a>性能改进</h3><ol>
<li><p><strong>更快的虚拟 DOM</strong>:</p>
<ul>
<li>Vue 3 引入了一个全新的虚拟 DOM 实现，优化了渲染速度和内存消耗。</li>
</ul>
</li>
<li><p><strong>编译优化</strong>:</p>
<ul>
<li>Vue 3 的编译器进行了重写，提供了更好的编译优化，减少了运行时的开销。</li>
</ul>
</li>
<li><p><strong>树摇动（Tree-shaking）</strong>:</p>
<ul>
<li>Vue 3 支持树摇动，意味着在最终打包时可以去除未使用的代码，减小应用体积。</li>
</ul>
</li>
</ol>
<h3 id="组合式-API"><a href="#组合式-API" class="headerlink" title="组合式 API"></a>组合式 API</h3><p>Vue 3 引入了 Composition API（组合式 API），这是 Vue 3 最显著的新特性之一。</p>
<ol>
<li><p><strong>更好的逻辑复用和组织</strong>:</p>
<ul>
<li>Composition API 允许开发者更灵活地组织组件逻辑，特别是在处理复杂组件时。</li>
<li>使用 <code>setup</code> 函数和一系列新的 API（如 <code>ref</code>, <code>reactive</code>, <code>computed</code>, <code>watch</code> 等），可以更好地封装和重用逻辑。</li>
</ul>
</li>
<li><p><strong>与 Options API 的共存</strong>:</p>
<ul>
<li>Vue 3 依然支持 Vue 2 中的 Options API，两种风格可以共存。</li>
</ul>
</li>
</ol>
<h3 id="更好的-TypeScript-支持"><a href="#更好的-TypeScript-支持" class="headerlink" title="更好的 TypeScript 支持"></a>更好的 TypeScript 支持</h3><ul>
<li>Vue 3 从一开始就考虑到了 TypeScript 的支持，其代码基于 TypeScript 编写，提供了更好的类型推断和集成。</li>
</ul>
<h3 id="其他新特性和改进"><a href="#其他新特性和改进" class="headerlink" title="其他新特性和改进"></a>其他新特性和改进</h3><ol>
<li><p><strong>组合式 API</strong>:</p>
<ul>
<li>引入了更灵活的组合式 API，为组件逻辑提供了更强的组织能力。</li>
</ul>
</li>
<li><p><strong>更小的体积</strong>:</p>
<ul>
<li>Vue 3 的体积比 Vue 2 更小，主要得益于树摇动。</li>
</ul>
</li>
<li><p><strong>多根节点组件</strong>:</p>
<ul>
<li>Vue 3 允许组件有多个根节点，而 Vue 2 中每个组件只能有一个根节点。</li>
</ul>
</li>
<li><p><strong>响应式系统的重写</strong>:</p>
<ul>
<li>Vue 3 的响应式系统基于 Proxy API 重写，提供了更好的性能和兼容性。</li>
</ul>
</li>
<li><p><strong>全新的生命周期钩子</strong>:</p>
<ul>
<li>引入了新的生命周期钩子，如 <code>onMounted</code>, <code>onUpdated</code> 等。</li>
</ul>
</li>
<li><p><strong>Fragment, Teleport, Suspense</strong>:</p>
<ul>
<li>引入了新的内置组件，如 Fragment（允许多个根节点），Teleport（允许将子节点传送到 DOM 树的其他位置），Suspense（用于异步组件的数据获取和渲染）。</li>
</ul>
</li>
</ol>
<h3 id="兼容性和迁移"><a href="#兼容性和迁移" class="headerlink" title="兼容性和迁移"></a>兼容性和迁移</h3><ul>
<li>Vue 3 考虑到了向后兼容性，提供了从 Vue 2 迁移到 Vue 3 的工具和指南。</li>
</ul>
<h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><ol>
<li><p><strong>事件循环</strong>:</p>
<ul>
<li>Node.js 运行时基于事件循环。事件循环负责处理异步回调，如 I&#x2F;O 操作、计时器、网络请求等。</li>
</ul>
</li>
<li><p><strong>微任务队列</strong>:</p>
<ul>
<li><code>process.nextTick</code> 将回调函数放入微任务队列。这个队列在事件循环的每个阶段之间执行，甚至在事件循环的当前阶段完成之前。</li>
</ul>
</li>
<li><p><strong>优先级</strong>:</p>
<ul>
<li>通过 <code>process.nextTick</code> 调度的任务比通过 <code>setImmediate</code> 或 <code>setTimeout</code>、<code>setInterval</code> 调度的任务优先级更高。这意味着 <code>nextTick</code> 回调在任何 I&#x2F;O 事件（包括定时器）之前执行。</li>
</ul>
</li>
</ol>
<h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><ul>
<li>当调用 <code>process.nextTick</code> 时，传入的回调函数不会立即执行。而是在当前操作完成后、事件循环继续进行之前执行。</li>
<li>这意味着即使在 I&#x2F;O 操作或定时器触发之前，所有通过 <code>nextTick</code> 排队的回调都会首先执行。</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><p><strong>错误处理</strong>:</p>
<ul>
<li><code>process.nextTick</code> 经常用于异步 API 中的错误处理。这是因为它允许在堆栈被解构之前抛出异常，从而可以捕获和处理错误。</li>
</ul>
</li>
<li><p><strong>确保异步性</strong>:</p>
<ul>
<li>有时候，你可能需要确保代码总是以异步方式运行，即使是在同步代码块中。<code>process.nextTick</code> 可以用于确保回调总是异步调用，从而避免了同步操作和异步操作之间的潜在问题。</li>
</ul>
</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始&#x27;</span>);</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextTick 回调&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;计划的 nextTick&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，输出将会是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开始</span><br><span class="line">计划的 nextTick</span><br><span class="line">nextTick 回调</span><br></pre></td></tr></table></figure>

<p>即使 <code>process.nextTick</code> 的回调是在最后一行调用的，它仍然在当前事件循环的末尾执行，即在任何其他的 I&#x2F;O 事件或计时器之前执行。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>使用 <code>process.nextTick</code> 可能导致 I&#x2F;O 饿死，因为如果不断地添加 <code>nextTick</code> 回调，那么 I&#x2F;O 事件可能永远无法被处理。因此，适当地使用 <code>nextTick</code> 是非常重要的。</li>
<li>对于绝大多数场景，<code>setImmediate</code> 是处理异步操作的更好选择，因为它更加公平地对待事件循环中的所有类型的事件。</li>
</ul>
<h2 id="javascript-和-typescript"><a href="#javascript-和-typescript" class="headerlink" title="javascript 和 typescript"></a>javascript 和 typescript</h2><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><ol>
<li><p><strong>定义</strong>:</p>
<ul>
<li>JavaScript 是一种高级的、解释型的编程语言。它是 Web 的核心语言，几乎所有的现代网页都使用 JavaScript 来增加交互性。</li>
</ul>
</li>
<li><p><strong>特点</strong>:</p>
<ul>
<li><strong>动态类型</strong>: JavaScript 是一种动态类型语言，这意味着变量的类型是在运行时确定的。</li>
<li><strong>解释执行</strong>: 作为一种解释型语言，JavaScript 代码在运行时由浏览器或 Node.js 的解释器直接执行。</li>
<li><strong>灵活性</strong>: 它是一种非常灵活的语言，支持面向对象、命令式和函数式编程风格。</li>
</ul>
</li>
<li><p><strong>应用范围</strong>:</p>
<ul>
<li>用于浏览器端的脚本编写，也被广泛用于服务器端（Node.js），以及移动应用和桌面应用开发。</li>
</ul>
</li>
</ol>
<h3 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h3><ol>
<li><p><strong>定义</strong>:</p>
<ul>
<li>TypeScript 是 JavaScript 的一个超集，由 Microsoft 开发和维护。它在 JavaScript 的基础上添加了静态类型系统。</li>
</ul>
</li>
<li><p><strong>特点</strong>:</p>
<ul>
<li><strong>静态类型</strong>: TypeScript 提供了静态类型检查，这意味着类型错误可以在编译阶段被捕获，而不是在运行时。</li>
<li><strong>编译为 JavaScript</strong>: TypeScript 代码需要被编译成 JavaScript 代码，这样浏览器和 Node.js 才能执行。</li>
<li><strong>面向对象特性</strong>: TypeScript 支持更先进的面向对象编程特性，如类、接口、继承和泛型。</li>
</ul>
</li>
<li><p><strong>优势</strong>:</p>
<ul>
<li>提高了大型项目的可维护性和开发效率。</li>
<li>提供了编译时类型检查，有助于及早发现错误。</li>
<li>改善了代码质量和可读性。</li>
</ul>
</li>
<li><p><strong>应用范围</strong>:</p>
<ul>
<li>TypeScript 适用于需要高度维护性和可扩展性的大型项目，特别是在团队开发环境中。</li>
</ul>
</li>
</ol>
<h3 id="主要区别-1"><a href="#主要区别-1" class="headerlink" title="主要区别"></a>主要区别</h3><ul>
<li><strong>类型系统</strong>: TypeScript 的最大特点是它的静态类型系统，而 JavaScript 是动态类型的。</li>
<li><strong>错误检测</strong>: TypeScript 能够在编译期间检测到类型错误，而 JavaScript 中的类型错误通常在运行时出现。</li>
<li><strong>工具支持</strong>: TypeScript 由于其类型系统，提供了更好的自动完成、重构和接口文档。</li>
<li><strong>学习曲线</strong>: TypeScript 的学习曲线相对于 JavaScript 来说稍微陡峭一些，特别是对于不熟悉类型系统的开发者。</li>
</ul>
<p>总的来说，TypeScript 提供了更强大的工具和特性来帮助开发大型和复杂的应用，而 JavaScript 由于其广泛的应用和灵活性，仍然是最流行的前端开发语言之一。开发者可以根据项目的具体需求和团队的熟悉程度来选择使用 JavaScript 还是 TypeScript。</p>
<h2 id="Vue-双向绑定"><a href="#Vue-双向绑定" class="headerlink" title="Vue 双向绑定"></a>Vue 双向绑定</h2><p>Vue.js 中的双向绑定是一种机制，允许数据和 UI 界面之间建立一个响应式连接，使得数据的变化能够自动反映到 UI 上，同时用户对 UI 的操作也能自动更新到数据上。Vue 实现双向绑定主要依靠两个核心概念：响应式系统和 <code>v-model</code> 指令。</p>
<h3 id="响应式系统"><a href="#响应式系统" class="headerlink" title="响应式系统"></a>响应式系统</h3><ol>
<li><p><strong>观察者模式</strong>:</p>
<ul>
<li>Vue 使用观察者模式来跟踪数据的变化。当你把一个普通的 JavaScript 对象传入 Vue 实例作为 <code>data</code> 选项，Vue 会遍历它的所有属性，并使用 <code>Object.defineProperty</code> 把这些属性全部转为 getter&#x2F;setter。这是 Vue 响应式系统的核心。</li>
</ul>
</li>
<li><p><strong>依赖收集</strong>:</p>
<ul>
<li>当渲染函数被首次执行时，Vue 能够追踪到哪些属性被访问了，从而知道在哪些属性发生变化时需要重新渲染。</li>
</ul>
</li>
<li><p><strong>派发更新</strong>:</p>
<ul>
<li>当属性的 setter 被调用时（即属性值发生变化时），Vue 会通知那些依赖于这个属性的组件重新渲染。</li>
</ul>
</li>
</ol>
<h3 id="v-model-指令"><a href="#v-model-指令" class="headerlink" title="v-model 指令"></a><code>v-model</code> 指令</h3><ol>
<li><p><strong>基本用途</strong>:</p>
<ul>
<li><code>v-model</code> 在表单元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。</li>
</ul>
</li>
<li><p><strong>工作原理</strong>:</p>
<ul>
<li>对于输入框（<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>）和选择框（<code>&lt;select&gt;</code>），<code>v-model</code> 绑定的值通常是 <code>input</code> 事件中的 <code>value</code>。</li>
<li>在内部，<code>v-model</code> 实际上是一个语法糖，它相当于同时绑定了 <code>value</code> 属性和监听 <code>input</code> 事件，当控件的输入值变化时，更新数据。</li>
</ul>
</li>
</ol>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>假设有如下 Vue 实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;Hello Vue!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>和如下模板：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>&lt;input&gt;</code> 元素和 <code>message</code> 数据之间建立了双向绑定。用户在输入框中输入文本时，<code>message</code> 数据会实时更新，同时 <code>message</code> 数据的变化也会实时反映到输入框的值中。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>虽然 <code>v-model</code> 提供了方便的双向绑定，但它也可能导致数据流难以理解和追踪，特别是在复杂的应用中。因此，在一些场景下，推荐使用单向数据流（即数据的单向绑定和显式的事件处理）来保持数据流的清晰和可控。</li>
<li>在 Vue 3 中，响应式系统从 <code>Object.defineProperty</code> 改为了基于 ES6 的 Proxy，这使得 Vue 的响应式系统更加强大和高效，同时消除了一些 Vue 2 中存在的限制。</li>
</ul>
<h2 id="Cookie-Session-localStorage"><a href="#Cookie-Session-localStorage" class="headerlink" title="Cookie Session localStorage"></a>Cookie Session localStorage</h2><p><code>Cookie</code>、<code>Session</code> 和 <code>localStorage</code> 是用于存储和管理网站数据的三种不同技术，每种技术都有其特定的用途和限制。</p>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><ol>
<li><p><strong>定义</strong>:</p>
<ul>
<li>Cookie 是小段的数据，由服务器发送到用户浏览器，然后浏览器会将其存储，并在随后的每个请求中将其发送回服务器。</li>
</ul>
</li>
<li><p><strong>特点</strong>:</p>
<ul>
<li>体积小（通常限制为4KB）。</li>
<li>每次 HTTP 请求都会携带，包括静态资源请求，这可能影响性能。</li>
<li>可以设置过期时间。</li>
<li>支持同源策略。</li>
</ul>
</li>
<li><p><strong>用途</strong>:</p>
<ul>
<li>用户认证。</li>
<li>会话跟踪。</li>
<li>个性化设置。</li>
</ul>
</li>
<li><p><strong>安全性</strong>:</p>
<ul>
<li>支持设置为 HttpOnly（无法通过 JS 访问）和 Secure（只在 HTTPS 下传输）。</li>
</ul>
</li>
</ol>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><ol>
<li><p><strong>定义</strong>:</p>
<ul>
<li>Session 是服务器端用来存储用户信息的一种机制，通常用于识别用户和存储用户特定的数据。</li>
</ul>
</li>
<li><p><strong>特点</strong>:</p>
<ul>
<li>存储在服务器端，对客户端是透明的。</li>
<li>可以存储较大量的数据。</li>
<li>生命周期通常取决于用户的会话（浏览器关闭，Session 结束）。</li>
</ul>
</li>
<li><p><strong>用途</strong>:</p>
<ul>
<li>管理用户会话（如登录状态）。</li>
<li>存储用户相关的敏感信息。</li>
</ul>
</li>
<li><p><strong>安全性</strong>:</p>
<ul>
<li>相比于 Cookie，Session 更安全，因为数据存储在服务器端。</li>
</ul>
</li>
</ol>
<h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><ol>
<li><p><strong>定义</strong>:</p>
<ul>
<li>localStorage 是 HTML5 提供的一种在客户端存储数据的方式。</li>
</ul>
</li>
<li><p><strong>特点</strong>:</p>
<ul>
<li>存储容量较大（最多 5MB）。</li>
<li>仅在客户端存储，不随 HTTP 请求发送。</li>
<li>没有过期时间，数据永久保存，直到手动清除。</li>
</ul>
</li>
<li><p><strong>用途</strong>:</p>
<ul>
<li>存储不经常变化的大量数据。</li>
<li>保存用户偏好设置。</li>
<li>缓存应用程序数据以提高性能。</li>
</ul>
</li>
<li><p><strong>安全性</strong>:</p>
<ul>
<li>由于存储在客户端，可能受到跨站脚本攻击（XSS）。</li>
</ul>
</li>
</ol>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ul>
<li><p><strong>存储位置</strong>:</p>
<ul>
<li>Cookie 和 localStorage 存储在客户端。</li>
<li>Session 存储在服务器端。</li>
</ul>
</li>
<li><p><strong>安全性</strong>:</p>
<ul>
<li>Session 比 Cookie 更安全。</li>
<li>localStorage 适用于非敏感数据的存储。</li>
</ul>
</li>
<li><p><strong>生命周期</strong>:</p>
<ul>
<li>Cookie 可以设置过期时间。</li>
<li>Session 通常与用户会话绑定。</li>
<li>localStorage 永久存储，直到被清除。</li>
</ul>
</li>
<li><p><strong>容量</strong>:</p>
<ul>
<li>Cookie 容量最小。</li>
<li>localStorage 提供最大的存储空间。</li>
</ul>
</li>
<li><p><strong>性能</strong>:</p>
<ul>
<li>Cookie 每次请求都会发送，可能影响性能。</li>
<li>Session 和 localStorage 不影响网络性能。</li>
</ul>
</li>
</ul>
<h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><p>跨域是 Web 开发中常见的安全问题之一，它是由浏览器的同源策略引起的。同源策略是浏览器的一种安全措施，它限制了一个域的脚本与另一个域的资源进行交互。如果协议、端口（如果有指定）或主机对于两个页面不同，则这两个页面具有不同的源。</p>
<h3 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h3><p>当一个网页尝试请求另一个与自己域名、端口号或协议不同的网页的资源时，就会发生跨域。例如，由 <code>http://example.com</code> 发起的 AJAX 请求尝试访问 <code>https://api.anotherdomain.com</code> 的资源，由于协议和域名不同，这将是一个跨域请求。</p>
<h3 id="常见的解决方法"><a href="#常见的解决方法" class="headerlink" title="常见的解决方法"></a>常见的解决方法</h3><ol>
<li><p><strong>CORS（跨源资源共享）</strong>:</p>
<ul>
<li>最常用的解决跨域问题的方法是在服务器端设置 CORS。这种方法通过在服务器的响应头中添加 <code>Access-Control-Allow-Origin</code> 来允许特定的外部域访问资源。</li>
<li>例如，<code>Access-Control-Allow-Origin: *</code> 允许所有域名访问资源，而 <code>Access-Control-Allow-Origin: http://example.com</code> 只允许 <code>http://example.com</code> 访问资源。</li>
</ul>
</li>
<li><p><strong>JSONP（JSON with Padding）</strong>:</p>
<ul>
<li>早期解决跨域问题的一种技术，主要用于 GET 请求。</li>
<li>它通过动态创建 <code>&lt;script&gt;</code> 标签来向不同源的服务器请求数据。服务器端返回的数据被包装在一个函数调用中。</li>
<li>JSONP 的缺点是它只支持 GET 请求，并且安全性较低。</li>
</ul>
</li>
<li><p><strong>代理服务器</strong>:</p>
<ul>
<li>使用代理服务器进行跨域请求。在这种情况下，浏览器向代理服务器发送请求，代理服务器将请求发送到目标服务器，并将响应返回给浏览器。</li>
<li>这种方法的优点是可以控制和缓存请求，但缺点是增加了服务器端的复杂性和成本。</li>
</ul>
</li>
<li><p><strong>PostMessage</strong>:</p>
<ul>
<li><code>window.postMessage</code> 是 HTML5 引入的一种安全的跨源通信方法。</li>
<li>这种方法允许不同源之间的窗口相互通信，适用于在不同域之间传递信息。</li>
</ul>
</li>
<li><p><strong>服务器端配置</strong>:</p>
<ul>
<li>对于某些服务，如字体或一些 API，可以在服务器配置文件（如 <code>.htaccess</code> 或 Nginx 配置文件）中设置允许跨域。</li>
</ul>
</li>
<li><p><strong>WebSockets</strong>:</p>
<ul>
<li>WebSockets 本身不受同源策略的限制，可以用于跨域通信。</li>
</ul>
</li>
</ol>
<h3 id="选择合适的方法"><a href="#选择合适的方法" class="headerlink" title="选择合适的方法"></a>选择合适的方法</h3><p>在选择解决跨域问题的方法时，需要考虑安全性、易用性和环境兼容性。对于大多数现代 Web 应用程序，推荐使用 CORS，因为它既安全又灵活。JSONP 可以作为旧系统的一种后备方案，但应谨慎使用，因为它容易受到 XSS 攻击。代理服务器在需要控制或缓存请求时非常有效，但会增加复杂性和成本。</p>
<h2 id="XSS-攻击"><a href="#XSS-攻击" class="headerlink" title="XSS 攻击"></a>XSS 攻击</h2><h3 id="XSS-攻击是什么？"><a href="#XSS-攻击是什么？" class="headerlink" title="XSS 攻击是什么？"></a>XSS 攻击是什么？</h3><p>XSS（跨站脚本攻击，Cross-Site Scripting）是一种在网页上执行恶意脚本的攻击方式，主要目标是在用户的浏览器中执行未经授权的代码。它允许攻击者注入可执行的脚本代码到合法的网页中，这些脚本在其他用户的浏览器中运行时，攻击者可以窃取用户的会话令牌、登录凭证，或者对用户进行其他恶意操作。</p>
<p>XSS 攻击通常分为以下几种类型：</p>
<ol>
<li><p><strong>存储型 XSS</strong>:</p>
<ul>
<li>恶意脚本被永久地存储在目标服务器上（如数据库、消息论坛、访客留言等），当用户访问含有恶意脚本的页面时，脚本就会执行。</li>
</ul>
</li>
<li><p><strong>反射型 XSS</strong>:</p>
<ul>
<li>恶意脚本作为请求的一部分发送给服务器，然后服务器将其作为响应的一部分返回，脚本在用户浏览器执行。这通常涉及到欺骗用户点击一个恶意链接。</li>
</ul>
</li>
<li><p><strong>DOM 型 XSS</strong>:</p>
<ul>
<li>通过恶意脚本修改页面的 DOM 结构实现的攻击，这种攻击完全在客户端进行，不涉及到服务器端的数据处理。</li>
</ul>
</li>
</ol>
<h3 id="如何防范-XSS-攻击？"><a href="#如何防范-XSS-攻击？" class="headerlink" title="如何防范 XSS 攻击？"></a>如何防范 XSS 攻击？</h3><ol>
<li><p><strong>转义输入内容</strong>:</p>
<ul>
<li>对用户输入的内容进行适当的转义处理，特别是在插入到 HTML 页面、JavaScript 代码或 URL 中时。例如，转义 HTML 特殊字符（如 <code>&lt;</code> 变为 <code>&amp;lt;</code>、<code>&gt;</code> 变为 <code>&amp;gt;</code>）。</li>
</ul>
</li>
<li><p><strong>使用内容安全策略（CSP）</strong>:</p>
<ul>
<li>实施内容安全策略（CSP）是防止 XSS 的一种有效方法。CSP 允许网站管理员定义哪些内容源是可信的，可以有效阻止恶意脚本的加载和执行。</li>
</ul>
</li>
<li><p><strong>验证和过滤输入</strong>:</p>
<ul>
<li>对所有用户输入进行严格的验证和过滤，确保输入的内容不包含恶意脚本。</li>
</ul>
</li>
<li><p><strong>使用 HTTP 的 Cookie <code>HttpOnly</code> 属性</strong>:</p>
<ul>
<li>将敏感的 cookie 标记为 <code>HttpOnly</code>，可以阻止 JavaScript 访问这些 cookie，从而减少某些类型的 XSS 攻击。</li>
</ul>
</li>
<li><p><strong>避免直接在 JavaScript 中嵌入用户输入</strong>:</p>
<ul>
<li>避免在 JavaScript 代码中直接使用用户输入的数据，特别是在构建动态 HTML 或执行其他动态操作时。</li>
</ul>
</li>
<li><p><strong>框架的内置 XSS 防护</strong>:</p>
<ul>
<li>许多现代的 Web 开发框架提供了自动的 XSS 防护。了解并正确使用这些框架的安全特性是非常重要的。</li>
</ul>
</li>
<li><p><strong>正则表达式过滤</strong>:</p>
<ul>
<li>使用正则表达式或其他方法过滤可能的攻击向量。</li>
</ul>
</li>
</ol>
<h2 id="git-flow"><a href="#git-flow" class="headerlink" title="git flow"></a>git flow</h2><p>Git Flow 是一种基于 Git 的分支管理策略，由 Vincent Driessen 在 2010 年提出。它定义了一组规范化的分支操作，旨在帮助团队更有效地进行版本控制和软件发布。Git Flow 中的主要分支包括：<code>master</code>、<code>develop</code>、<code>feature</code>、<code>release</code> 和 <code>hotfix</code> 分支。</p>
<h3 id="主要分支"><a href="#主要分支" class="headerlink" title="主要分支"></a>主要分支</h3><ol>
<li><p><strong>Main 分支</strong>:</p>
<ul>
<li>用于存储正式发布的历史。</li>
<li>每次在 main 分支上进行提交，都应该对应一个版本发布。</li>
</ul>
</li>
<li><p><strong>Develop 分支</strong>:</p>
<ul>
<li>开发分支，是为了开发新功能、改进和日常工作而设置的。</li>
<li>通常所有新功能都会首先合并到这个分支。</li>
</ul>
</li>
</ol>
<h3 id="辅助分支"><a href="#辅助分支" class="headerlink" title="辅助分支"></a>辅助分支</h3><ol>
<li><p><strong>Feature 分支</strong>:</p>
<ul>
<li>从 <code>develop</code> 分支派生出来。</li>
<li>用于开发新功能。</li>
<li>完成开发后，会合并回 <code>develop</code> 分支。</li>
<li>分支命名通常遵循 <code>feature/</code> 的模式。</li>
</ul>
</li>
<li><p><strong>Release 分支</strong>:</p>
<ul>
<li>从 <code>develop</code> 分支派生出来，用于准备即将发布的版本。</li>
<li>允许进行最后的调整（如 bug 修复、文档编写等）。</li>
<li>完成后，应该合并到 <code>main</code> 和 <code>develop</code> 分支。</li>
<li>分支命名通常遵循 <code>release/</code> 的模式。</li>
</ul>
</li>
<li><p><strong>Hotfix 分支</strong>:</p>
<ul>
<li>从 <code>main</code> 分支派生出来，用于修复生产环境中的紧急问题。</li>
<li>修复完成后，应该合并到 <code>main</code> 和 <code>develop</code> 分支。</li>
<li>分支命名通常遵循 <code>hotfix/</code> 的模式。</li>
</ul>
</li>
</ol>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol>
<li><p><strong>新功能开发</strong>:</p>
<ul>
<li>从 <code>develop</code> 分支创建新的 <code>feature</code> 分支。</li>
<li>完成开发后，将 <code>feature</code> 分支合并回 <code>develop</code>。</li>
</ul>
</li>
<li><p><strong>发布准备</strong>:</p>
<ul>
<li>当 <code>develop</code> 分支达到一个稳定点，从中创建一个 <code>release</code> 分支。</li>
<li>在 <code>release</code> 分支上完成最后的测试和修订。</li>
<li>完成后，将 <code>release</code> 分支合并到 <code>main</code> 和 <code>develop</code>。</li>
</ul>
</li>
<li><p><strong>紧急修复</strong>:</p>
<ul>
<li>当在生产版本中发现紧急问题时，从 <code>main</code> 分支创建 <code>hotfix</code> 分支。</li>
<li>完成修复后，将 <code>hotfix</code> 分支合并到 <code>main</code> 和 <code>develop</code>。</li>
</ul>
</li>
<li><p><strong>发布</strong>:</p>
<ul>
<li>在 <code>main</code> 分支上的每次合并都应该对应一个新的版本发布。</li>
</ul>
</li>
</ol>
<h3 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h3><ul>
<li><p><strong>优点</strong>:</p>
<ul>
<li>清晰定义了不同类型的分支和它们的用途。</li>
<li>适合大型项目和需要严格发布管理的场景。</li>
</ul>
</li>
<li><p><strong>缺点</strong>:</p>
<ul>
<li>流程相对复杂，可能不适合小团队或轻量级项目。</li>
<li>需要团队成员理解并遵循规定的流程。</li>
</ul>
</li>
</ul>
<h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p>中间人攻击（Man-in-the-Middle Attack，简称 MITM ）是一种常见的网络安全威胁，其中攻击者秘密地拦截并可能更改通信双方之间的通信。在这种攻击中，攻击者插入自己到受害者之间的通信过程，使受害者认为他们正在直接与预期的通信对象进行通信。</p>
<h3 id="如何进行中间人攻击"><a href="#如何进行中间人攻击" class="headerlink" title="如何进行中间人攻击"></a>如何进行中间人攻击</h3><ol>
<li><p><strong>拦截通信</strong>:</p>
<ul>
<li>攻击者首先需要找到一种方式拦截双方之间的通信。这可以通过多种方式实现，比如在无线网络中拦截 Wi-Fi 信号，或者在网络路由中插入恶意设备。</li>
</ul>
</li>
<li><p><strong>监听和&#x2F;或篡改数据</strong>:</p>
<ul>
<li>一旦通信被拦截，攻击者就能够监听通信内容，并且在必要时更改传输的数据。</li>
</ul>
</li>
<li><p><strong>伪装和欺骗</strong>:</p>
<ul>
<li>攻击者可能会伪装成通信的一方，向另一方发送消息。在受害者看来，这些消息看起来是从他们预期的通信对象发送的。</li>
</ul>
</li>
</ol>
<h3 id="常见的中间人攻击类型"><a href="#常见的中间人攻击类型" class="headerlink" title="常见的中间人攻击类型"></a>常见的中间人攻击类型</h3><ol>
<li><p><strong>电子邮件劫持</strong>:</p>
<ul>
<li>攻击者拦截并更改电子邮件内容。</li>
</ul>
</li>
<li><p><strong>Wi-Fi 欺骗</strong>:</p>
<ul>
<li>在公共 Wi-Fi 中，攻击者可以创建一个假冒的 Wi-Fi 热点，诱使用户连接，并拦截通过该网络的数据。</li>
</ul>
</li>
<li><p><strong>HTTPS 欺骗</strong>:</p>
<ul>
<li>攻击者通过伪造证书来拦截和解密 HTTPS 加密的通信。</li>
</ul>
</li>
<li><p><strong>DNS 劫持</strong>:</p>
<ul>
<li>攻击者篡改 DNS 服务器的响应，将用户重定向到恶意网站。</li>
</ul>
</li>
<li><p><strong>会话劫持</strong>:</p>
<ul>
<li>攻击者窃取用户的会话令牌，以获取对用户账户的访问权限。</li>
</ul>
</li>
</ol>
<h3 id="如何防范中间人攻击"><a href="#如何防范中间人攻击" class="headerlink" title="如何防范中间人攻击"></a>如何防范中间人攻击</h3><ol>
<li><p><strong>使用加密协议</strong>:</p>
<ul>
<li>使用 HTTPS、SSL&#x2F;TLS 等加密协议可以保护数据传输的安全。</li>
</ul>
</li>
<li><p><strong>验证证书</strong>:</p>
<ul>
<li>确保网站的证书是有效的，并且由可信的证书颁发机构签发。</li>
</ul>
</li>
<li><p><strong>VPN 使用</strong>:</p>
<ul>
<li>使用虚拟私人网络（VPN）可以在公共网络上提供加密的通信通道。</li>
</ul>
</li>
<li><p><strong>强化 Wi-Fi 安全</strong>:</p>
<ul>
<li>使用强密码和最新的 Wi-Fi 安全协议（如 WPA3）。</li>
</ul>
</li>
</ol>
<h2 id="单点登录-SSO"><a href="#单点登录-SSO" class="headerlink" title="单点登录 SSO"></a>单点登录 SSO</h2><h3 id="单点登录（SSO）的理解"><a href="#单点登录（SSO）的理解" class="headerlink" title="单点登录（SSO）的理解"></a>单点登录（SSO）的理解</h3><p>单点登录（Single Sign-On，简称 SSO）是一种身份验证服务，它允许用户使用一组登录凭证（例如用户名和密码）来访问多个应用程序。目的是通过减少用户需要记住的密码数量和登录次数，来提高用户体验和安全性。</p>
<h3 id="SSO-的工作原理"><a href="#SSO-的工作原理" class="headerlink" title="SSO 的工作原理"></a>SSO 的工作原理</h3><ol>
<li><p><strong>中央认证</strong>:</p>
<ul>
<li>在 SSO 系统中，存在一个中央认证服务器。用户首次尝试访问应用时，会被重定向到这个认证服务器。</li>
</ul>
</li>
<li><p><strong>身份验证</strong>:</p>
<ul>
<li>用户在认证服务器上输入登录凭证（如用户名和密码）。如果凭证有效，认证服务器会创建一个认证令牌（通常是一个临时的、加密的令牌）。</li>
</ul>
</li>
<li><p><strong>令牌颁发</strong>:</p>
<ul>
<li>认证服务器将令牌发放给用户，令牌表明用户已被验证。</li>
</ul>
</li>
<li><p><strong>访问应用</strong>:</p>
<ul>
<li>用户再次尝试访问原来的应用或其他应用时，会携带这个令牌。应用会向认证服务器验证令牌的有效性。</li>
</ul>
</li>
<li><p><strong>授权访问</strong>:</p>
<ul>
<li>如果认证服务器确认令牌有效，用户将被授权访问应用。这一过程对用户来说是透明的，无需再次输入登录凭证。</li>
</ul>
</li>
<li><p><strong>会话创建</strong>:</p>
<ul>
<li>每个应用会为用户创建一个会话，允许用户在不再输入凭证的情况下访问。</li>
</ul>
</li>
</ol>
<h3 id="SSO-的流程"><a href="#SSO-的流程" class="headerlink" title="SSO 的流程"></a>SSO 的流程</h3><ol>
<li><p><strong>登录请求</strong>:</p>
<ul>
<li>用户首次访问某个应用时，会被重定向到 SSO 的认证服务器。</li>
</ul>
</li>
<li><p><strong>输入凭证</strong>:</p>
<ul>
<li>用户在认证服务器上输入登录凭证。</li>
</ul>
</li>
<li><p><strong>身份验证</strong>:</p>
<ul>
<li>认证服务器验证用户凭证。如果验证成功，则生成认证令牌。</li>
</ul>
</li>
<li><p><strong>重定向回应用</strong>:</p>
<ul>
<li>用户携带令牌返回应用。</li>
</ul>
</li>
<li><p><strong>令牌验证</strong>:</p>
<ul>
<li>应用向认证服务器验证令牌的有效性。</li>
</ul>
</li>
<li><p><strong>授权与访问</strong>:</p>
<ul>
<li>一旦令牌被确认有效，应用将允许用户访问，用户无需再次登录。</li>
</ul>
</li>
<li><p><strong>访问其他应用</strong>:</p>
<ul>
<li>当用户访问其他集成了 SSO 的应用时，只需重复令牌验证步骤，无需再次登录。</li>
</ul>
</li>
</ol>
<h3 id="SSO-的优势和挑战"><a href="#SSO-的优势和挑战" class="headerlink" title="SSO 的优势和挑战"></a>SSO 的优势和挑战</h3><ul>
<li><p><strong>优势</strong>:</p>
<ul>
<li>提高用户体验：用户只需记住一套凭证。</li>
<li>增加安全性：减少密码泄露的风险，便于集中管理。</li>
<li>减少管理工作：为管理员提供集中的用户管理和审计。</li>
</ul>
</li>
<li><p><strong>挑战</strong>:</p>
<ul>
<li>集成复杂性：对现有系统进行 SSO 集成可能复杂。</li>
<li>单点故障：认证服务器出现问题可能导致所有应用不可用。</li>
<li>安全风险：如果认证服务器被攻破，所有关联应用都可能受到影响。</li>
</ul>
</li>
</ul>
<h2 id="TypeScript-interface-type"><a href="#TypeScript-interface-type" class="headerlink" title="TypeScript interface type"></a>TypeScript interface type</h2><h3 id="语法和功能"><a href="#语法和功能" class="headerlink" title="语法和功能"></a>语法和功能</h3><ol>
<li><p><strong>扩展方式</strong>:</p>
<ul>
<li><code>interface</code> 可以被扩展和实现（extends 和 implements）。这使得它们非常适合定义对象的形状或类的契约。</li>
<li><code>type</code> 可以通过交集（<code>&amp;</code>）来组合现有类型，但不能使用 <code>extends</code> 或 <code>implements</code>。这使得 <code>type</code> 更适合联合类型或特定函数的签名。</li>
</ul>
</li>
<li><p><strong>声明合并</strong>:</p>
<ul>
<li><code>interface</code> 支持声明合并，即同名的 <code>interface</code> 会被自动合并为一个。</li>
<li><code>type</code> 不支持声明合并。</li>
</ul>
</li>
</ol>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li><p><strong>Interface</strong>:</p>
<ul>
<li>当定义对象的结构或类的契约时，推荐使用 <code>interface</code>。尤其是在定义库的类型或外部 API 的类型定义时，<code>interface</code> 由于其可扩展性，更加合适。</li>
<li>示例：<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Employee</span> <span class="keyword">extends</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">salary</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>Type</strong>:</p>
<ul>
<li>当需要使用联合类型或元组类型时，或者你的类型不适合通过一个简单的接口来表示时，应该使用 <code>type</code>。</li>
<li>示例：<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Operation</span> = <span class="string">&#x27;add&#x27;</span> | <span class="string">&#x27;subtract&#x27;</span> | <span class="string">&#x27;multiply&#x27;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = [<span class="built_in">boolean</span>, <span class="built_in">string</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="性能考虑"><a href="#性能考虑" class="headerlink" title="性能考虑"></a>性能考虑</h3><ul>
<li>在大多数情况下，<code>interface</code> 和 <code>type</code> 在性能上没有显著差异。</li>
<li>但在某些大型项目中，<code>interface</code> 由于其声明合并的特性，可能会稍微提高编译速度。</li>
</ul>
<h3 id="兼容性和扩展性"><a href="#兼容性和扩展性" class="headerlink" title="兼容性和扩展性"></a>兼容性和扩展性</h3><ul>
<li><code>interface</code> 更适合在声明 API 或库的类型定义时使用，因为它们更容易在不同的代码库中被扩展和维护。</li>
<li><code>type</code> 由于其能够表达更复杂的类型组合，提供了更多的灵活性。</li>
</ul>
<h2 id="函数入参实现类型映射"><a href="#函数入参实现类型映射" class="headerlink" title="函数入参实现类型映射"></a>函数入参实现类型映射</h2><p>在 TypeScript 中，你可以使用高级类型特性来实现函数入参的类型映射。这主要涉及到泛型和条件类型的使用。以下是一些实现类型映射的方法：</p>
<h3 id="1-使用泛型"><a href="#1-使用泛型" class="headerlink" title="1. 使用泛型"></a>1. 使用泛型</h3><p>泛型允许你定义一个函数，它可以适用于多种类型而不仅仅是一个。你可以在函数定义时声明一个泛型类型参数，然后在函数体内或作为参数类型使用它。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> output = identity&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;myString&quot;</span>);  <span class="comment">// 输出类型为 &#x27;string&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>T</code> 是一个泛型类型变量，它捕获传递给 <code>identity</code> 的参数类型。这样，你就可以使用这个类型来保证函数的输入和输出类型是一致的。</p>
<h3 id="2-条件类型"><a href="#2-条件类型" class="headerlink" title="2. 条件类型"></a>2. 条件类型</h3><p>条件类型（Conditional Types）允许你根据类型关系创建更复杂的类型表达式。它们在类型映射中非常有用，特别是当你想根据输入类型生成不同的输出类型时。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TypeName</span>&lt;T&gt; =</span><br><span class="line">    T <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="string">&quot;string&quot;</span> :</span><br><span class="line">    T <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="string">&quot;number&quot;</span> :</span><br><span class="line">    T <span class="keyword">extends</span> <span class="built_in">boolean</span> ? <span class="string">&quot;boolean&quot;</span> :</span><br><span class="line">    T <span class="keyword">extends</span> <span class="literal">undefined</span> ? <span class="string">&quot;undefined&quot;</span> :</span><br><span class="line">    T <span class="keyword">extends</span> <span class="title class_">Function</span> ? <span class="string">&quot;function&quot;</span> :</span><br><span class="line">    <span class="string">&quot;object&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> typeOf&lt;T&gt;(<span class="attr">arg</span>: T): <span class="title class_">TypeName</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> arg <span class="keyword">as</span> <span class="title class_">TypeName</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="title function_">typeOf</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// str 类型为 &quot;string&quot;</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="title function_">typeOf</span>(<span class="number">123</span>);     <span class="comment">// num 类型为 &quot;number&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>TypeName</code> 是一个条件类型，它根据传入的类型 <code>T</code> 返回不同的字符串字面量类型。</p>
<h3 id="3-映射类型"><a href="#3-映射类型" class="headerlink" title="3. 映射类型"></a>3. 映射类型</h3><p>映射类型（Mapped Types）允许你根据旧类型创建新类型。它们通过对一个已知的类型的每个属性应用某种变换来工作。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ReadOnly</span>&lt;T&gt; = &#123; <span class="keyword">readonly</span> [K <span class="keyword">in</span> keyof T]: T[K] &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> freeze&lt;T&gt;(<span class="attr">obj</span>: T): <span class="title class_">ReadOnly</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">freeze</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> original = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> frozen = <span class="title function_">freeze</span>(original); <span class="comment">// frozen 类型为 ReadOnly&lt;&#123; a: number; b: number; &#125;&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>ReadOnly</code> 是一个映射类型，它将 <code>T</code> 的所有属性标记为 <code>readonly</code>。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>根据你的具体需求，你可以选择使用泛型、条件类型或映射类型来实现函数参数的类型映射。这些高级类型特性提供了强大的工具，可以帮助你创建灵活且类型安全的代码。</p>
<h2 id="HTTPS-工作原理"><a href="#HTTPS-工作原理" class="headerlink" title="HTTPS 工作原理"></a>HTTPS 工作原理</h2><p>HTTPS（全称为 Hyper Text Transfer Protocol Secure）是 HTTP 的安全版本。它主要通过 SSL&#x2F;TLS 协议来提供身份验证和加密通信，以保护数据在互联网上的传输。以下是 HTTPS 的主要工作原理：</p>
<h3 id="1-加密"><a href="#1-加密" class="headerlink" title="1. 加密"></a>1. 加密</h3><p>HTTPS 使用对称加密和非对称加密相结合的方式来保护数据传输的安全：</p>
<ul>
<li><strong>非对称加密</strong>：在建立连接阶段使用，用于安全地交换对称密钥。</li>
<li><strong>对称加密</strong>：在交换密钥之后，对传输的数据进行加密。</li>
</ul>
<h3 id="2-SSL-x2F-TLS-握手"><a href="#2-SSL-x2F-TLS-握手" class="headerlink" title="2. SSL&#x2F;TLS 握手"></a>2. SSL&#x2F;TLS 握手</h3><p>当你的浏览器连接到一个 HTTPS 网站时，会发生一个叫做 SSL&#x2F;TLS 握手的过程，它包括以下步骤：</p>
<ol>
<li><p><strong>客户端发送加密偏好</strong>：</p>
<ul>
<li>浏览器（客户端）向服务器发送一个“Client Hello”消息，其中包含支持的 SSL&#x2F;TLS 版本、加密算法选项等。</li>
</ul>
</li>
<li><p><strong>服务器响应</strong>：</p>
<ul>
<li>服务器选择一组最合适的加密算法和 SSL&#x2F;TLS 版本，并且发送一个“Server Hello”消息给客户端。同时，服务器还会发送它的公钥和证书。</li>
</ul>
</li>
<li><p><strong>验证服务器证书</strong>：</p>
<ul>
<li>客户端验证服务器的 SSL&#x2F;TLS 证书（通常是由第三方证书机构 CA 颁发的）。证书验证包括检查证书是否过期、是否被撤销，以及是否由可信的 CA 签发。</li>
</ul>
</li>
<li><p><strong>客户端响应</strong>：</p>
<ul>
<li>一旦验证了服务器的证书，客户端生成一个随机的对称加密密钥，并使用服务器的公钥加密这个密钥，然后发送给服务器。</li>
</ul>
</li>
<li><p><strong>服务器解密密钥</strong>：</p>
<ul>
<li>服务器使用其私钥解密客户端发送的对称密钥。</li>
</ul>
</li>
<li><p><strong>加密通信</strong>：</p>
<ul>
<li>从这一步开始，客户端和服务器使用对称密钥来加密通信数据，确保数据传输的安全性。</li>
</ul>
</li>
</ol>
<h3 id="3-安全通信"><a href="#3-安全通信" class="headerlink" title="3. 安全通信"></a>3. 安全通信</h3><p>一旦 SSL&#x2F;TLS 握手完成，客户端和服务器之间的通信就会使用对称加密保护。这意味着即使通信被拦截，没有密钥的第三方也无法解读通信内容。</p>
<h3 id="4-会话结束"><a href="#4-会话结束" class="headerlink" title="4. 会话结束"></a>4. 会话结束</h3><p>当通信结束时，会话密钥会被丢弃。如果用户再次访问服务器，将进行新的握手过程和密钥交换。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>HTTPS 通过结合使用对称和非对称加密，以及通过可信的 CA 验证服务器的身份，有效保护了数据传输的安全性。虽然 HTTPS 在性能上有一定的开销，但它显著提升了网络通信的安全性，对于保护敏感数据，如登录凭据、支付信息等，是非常重要的。</p>
<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>在网络通信中，端口的作用主要是区分同一台主机上的不同服务或进程。端口是一种数字标记，它与 IP 地址一起使用，以标识主机上运行的特定应用程序或服务的实例。端口位于 OSI 七层模型的传输层（第四层），该层还包括定义传输协议，如 TCP（传输控制协议）和 UDP（用户数据报协议）。</p>
<h3 id="端口的作用"><a href="#端口的作用" class="headerlink" title="端口的作用"></a>端口的作用</h3><ol>
<li><p><strong>区分服务</strong>:</p>
<ul>
<li>在一台主机上可能运行着多种网络服务，如 HTTP 服务器、FTP 服务器、邮件服务器等。端口用于区分这些服务，例如，HTTP 默认使用端口 80，而 FTP 默认使用端口 21。</li>
</ul>
</li>
<li><p><strong>通信管理</strong>:</p>
<ul>
<li>端口允许同一物理网络上的多个应用程序同时进行通信，每个应用程序都可以有自己的端口号。</li>
</ul>
</li>
<li><p><strong>连接指定</strong>:</p>
<ul>
<li>在一个网络连接中，一个端口号与一个 IP 地址组合在一起，可以精确地指定通信的发送方和接收方。</li>
</ul>
</li>
</ol>
<h2 id="ESLint-Prettier-Husky-Lint-Staged"><a href="#ESLint-Prettier-Husky-Lint-Staged" class="headerlink" title="ESLint Prettier Husky Lint-Staged"></a>ESLint Prettier Husky Lint-Staged</h2><p>这些工具是现代前端开发中常用的代码质量和风格一致性工具。它们各自扮演着不同的角色：</p>
<h3 id="1-ESLint"><a href="#1-ESLint" class="headerlink" title="1. ESLint"></a>1. ESLint</h3><ul>
<li><strong>用途</strong>：ESLint 是一个静态代码分析工具，用于识别 JavaScript 中的问题。它不仅能找出错误，还能检测出代码风格的问题，如不一致的缩进、未使用的变量等。</li>
<li><strong>特点</strong>：<ul>
<li>可配置性高，可以根据项目需求自定义规则。</li>
<li>可以集成到多数编辑器和构建过程中。</li>
<li>支持 ES6+、React、Vue 等现代 JavaScript 特性。</li>
</ul>
</li>
</ul>
<h3 id="2-Prettier"><a href="#2-Prettier" class="headerlink" title="2. Prettier"></a>2. Prettier</h3><ul>
<li><strong>用途</strong>：Prettier 是一个代码格式化工具，它支持多种语言和文件格式。它强制执行一致的代码风格，确保整个团队的代码看起来和感觉一致。</li>
<li><strong>特点</strong>：<ul>
<li>重点关注代码的外观。</li>
<li>支持 JavaScript、TypeScript、CSS、HTML 等多种语言。</li>
<li>与 ESLint 不同，Prettier 不会检查代码错误。</li>
</ul>
</li>
</ul>
<h3 id="3-Husky"><a href="#3-Husky" class="headerlink" title="3. Husky"></a>3. Husky</h3><ul>
<li><strong>用途</strong>：Husky 是一个用于创建 Git 钩子（hooks）的工具。它可以在执行诸如提交（commit）或推送（push）等 Git 操作时自动运行脚本。</li>
<li><strong>特点</strong>：<ul>
<li>常用于在提交代码前自动运行 Lint 或测试。</li>
<li>防止不符合标准或有问题的代码被提交到仓库。</li>
</ul>
</li>
</ul>
<h3 id="4-Lint-Staged"><a href="#4-Lint-Staged" class="headerlink" title="4. Lint-Staged"></a>4. Lint-Staged</h3><ul>
<li><strong>用途</strong>：Lint-Staged 是一个在 Git 暂存文件（即即将被提交的文件）上运行 Linters 或其他工具的工具。</li>
<li><strong>特点</strong>：<ul>
<li>结合 Husky 使用，只对即将提交的更改执行 Lint 操作，而不是整个项目。</li>
<li>提高了代码质量，确保提交的代码符合预定义的规则。</li>
</ul>
</li>
</ul>
<h3 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h3><p>这些工具常常一起使用，以提高代码质量和提升开发效率：</p>
<ul>
<li>使用 ESLint 来检测代码中的问题和不一致性。</li>
<li>使用 Prettier 来格式化代码，确保一致的风格。</li>
<li>使用 Husky 创建 Git 钩子，在代码提交前自动运行 Lint 和测试。</li>
<li>使用 Lint-Staged 确保只检查和格式化被修改并准备提交的文件，而不是整个代码库。</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>JavaScript 中的迭代器是一个对象，它定义了一个 <code>next()</code> 方法，返回一个包含 <code>done</code> 和 <code>value</code> 属性的对象。当 <code>done</code> 为 <code>true</code> 时，表示迭代器已经遍历完所有元素。</p>
<p>以下是一个简单的迭代器实现示例，它迭代一个数字数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createIterator</span>(<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">next</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> currentIndex &lt; array.<span class="property">length</span> ?</span><br><span class="line">                &#123; <span class="attr">value</span>: array[currentIndex++], <span class="attr">done</span>: <span class="literal">false</span> &#125; :</span><br><span class="line">                &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">const</span> myArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> myIterator = <span class="title function_">createIterator</span>(myArray);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myIterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myIterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myIterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myIterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>createIterator</code> 函数接收一个数组并返回一个迭代器。迭代器的 <code>next</code> 方法在每次被调用时返回数组的下一个元素，直到数组被完全遍历。</p>
<p>请注意，这个迭代器是手动实现的，用于展示迭代器的基本原理。在实际的 JavaScript 开发中，你通常可以使用 ES6 提供的内置迭代器，比如通过 <code>for...of</code> 循环、展开操作符 <code>...</code> 或 <code>Array.prototype.entries()</code> 方法等来遍历可迭代对象。</p>
<h2 id="防抖（Debouncing）"><a href="#防抖（Debouncing）" class="headerlink" title="防抖（Debouncing）"></a>防抖（Debouncing）</h2><p>防抖（Debouncing）是一种优化技术，用于确保一个函数在特定时间内不被频繁调用。它是通过在指定时间内延迟函数的执行来实现的。如果在这段延迟时间内再次触发该函数，那么原来的延迟调用会被取消，并重新开始计算延迟时间。这对于一些需要频繁触发但执行成本较高的操作（如窗口大小调整、输入框内容变化等）非常有用。</p>
<p>下面是一个简单的防抖函数的实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">const</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">onResize</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;窗口大小变化了！&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> debouncedResize = <span class="title function_">debounce</span>(onResize, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, debouncedResize);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>debounce</code> 函数接受两个参数：一个要执行的函数 <code>func</code> 和延迟时间 <code>wait</code>。返回的函数会在调用后等待指定的 <code>wait</code> 毫秒数，然后执行 <code>func</code>。如果在这个等待时间内再次被调用，之前的等待就会被清除，并重新开始计时。</p>
<p>这个防抖函数的应用示例是窗口调整大小事件的处理函数 <code>onResize</code>。通过使用 <code>debounce</code>，我们可以确保在窗口调整大小的过程中，<code>onResize</code> 函数不会被频繁调用，而是在调整结束后的 500 毫秒才执行一次。</p>
]]></content>
      <categories>
        <category>note</category>
      </categories>
  </entry>
  <entry>
    <title>npm install 的不同方式</title>
    <url>/2023/08/05/npm-install-ways/</url>
    <content><![CDATA[<h2 id="npm-install-g-–save"><a href="#npm-install-g-–save" class="headerlink" title="npm install -g –save ?"></a>npm install -g –save ?</h2><span id="more"></span>

<ul>
<li><code>npm install</code>（在包目录中）<br>根据<code>package.json</code>文件，将依赖安装到包目录中<code>node_modules</code>文件夹</li>
<li><code>npm install &quot;module-name&quot;</code><br>安装特定依赖到包目录下</li>
<li><code>npm install -g &quot;module-name&quot;</code><br><code>-g</code>表明将模块安装到全局，将包安装到<code>prefix</code>文件夹而不是当前工作目录，<code>&#123;prefix&#125;/lib/node_modules</code><br>可通过以下命令查看 npm 相关配置：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>
<img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308051125123.png"></li>
<li><code>npm install --save &quot;module-name&quot;</code><br><code>--save</code>表明模块安装并写入<code>package.json</code>的<code>dependencies</code>节点。<code>--save</code>等同于<code>-S</code>。</li>
<li><ul>
<li><code>npm install --save-prod &quot;module-name&quot;</code><br>包将出现在<code>dependencies</code>中，这是默认值</li>
</ul>
</li>
<li><ul>
<li><code>npm install --save-dev &quot;module-name&quot;</code><br>包将出现在<code>devDependencies</code>中，运行<code>npm install --production</code>或<code>NODE_ENV</code>值为<code>production</code>时<strong>不会</strong>自动下载模块。<code>--save-dev</code>等同于<code>-D</code>。</li>
</ul>
</li>
</ul>
<p><code>npm uninstall &quot;module_name&quot;</code>删除依赖同理。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>devDependencies</code>节点下模块是开发时需要使用的，如辅助开发的压缩，部署后不需要，所以使用<code>--save-dev</code>形式安装。<br><code>dependencies</code>节点下模块是运行时必备的，故采用<code>--save</code>（等同于<code>--save-prod</code>）安装。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly9ucG0ubm9kZWpzLmNuL2NsaS92OS9jb21tYW5kcy9ucG0taW5zdGFsbA==">npm中文网——npm-install<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbGltaXRjb2RlL3AvNzkwNjQ0Ny5odG1s">NPM install -save 和 -save-dev 傻傻分不清<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>frontend</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>soa-review-key</title>
    <url>/2024/01/12/soa-review-key/</url>
    <content><![CDATA[<h1 id="SOA复习大纲"><a href="#SOA复习大纲" class="headerlink" title="SOA复习大纲"></a>SOA复习大纲</h1><h2 id="SOA技术简述"><a href="#SOA技术简述" class="headerlink" title="SOA技术简述"></a>SOA技术简述</h2><h3 id="为什么要引入SOA、SOA要解决的问题"><a href="#为什么要引入SOA、SOA要解决的问题" class="headerlink" title="为什么要引入SOA、SOA要解决的问题"></a>为什么要引入SOA、SOA要解决的问题</h3><p>为什么要引入SOA：需求拉动、技术推动</p>
<ol>
<li><strong>Internet环境下的企业交互</strong>：现代企业已经不再是封闭的企业，市场分工的日益专业化使得<strong>企业之间可能存在大量频繁的交互行为</strong>，以发挥各自的竞争优势。这种业务上的交互体现为<strong>企业业务流程的交互&#x2F;互操作</strong>，同时一定需要企业信息系统的支持，因此体现为<strong>软件系统之间的集成与互操作</strong></li>
<li><strong>异构系统的集成与互操作</strong>：技术平台不同、软件体系结构不同、数据格式不同</li>
<li><strong>频繁变化的互操作与集成需求</strong>：企业的业务是频繁变化的，IT应用系统要能够快速支持这种变化的需求，需要迅速、敏捷、高效的调整业务应用系统</li>
</ol>
<p>SOA要解决的问题：</p>
<ol>
<li>分布式企业间业务的协同</li>
<li>通过Internet连接在一起的异构企业应用软件系统的集成、交互与互操作</li>
<li>当业务(Business)发生变化时，IT系统能够快速响应</li>
</ol>
<span id="more"></span>

<h3 id="什么是SOA、核心要素及其理解"><a href="#什么是SOA、核心要素及其理解" class="headerlink" title="什么是SOA、核心要素及其理解"></a>什么是SOA、核心要素及其理解</h3><p><strong>SOA&#x3D;Service(服务)+体系结构(Architecture)</strong></p>
<ul>
<li>业务模型：企业向其客户暴露的一系列<strong>业务</strong>——服务</li>
<li>体系结构：一组<strong>体系结构设计原则与模式</strong>，强调模块化、封装、松散耦合、分离关注点、可复用、可组合性、接口与实现分离等特性</li>
<li>软件实现方式：一种<strong>编程模式</strong>，包括一系列的标准、开发工具、开发过程指南、运行时基础架构</li>
</ul>
<p><strong>SOA三要素：标准化封装、复用、松耦合可编排</strong><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401121738410.png"></p>
<h3 id="SOA的典型优势"><a href="#SOA的典型优势" class="headerlink" title="SOA的典型优势"></a>SOA的典型优势</h3><ol>
<li><strong>分布式异构系统的集成与互操作</strong></li>
<li><strong>完全的松散耦合</strong><ul>
<li>位置透明</li>
<li>与具体的实现细节无关(通过接口调用)</li>
<li>标准化的通讯协议（XML-Based）</li>
</ul>
</li>
<li><strong>大数据量低频率访问</strong></li>
<li><strong>基于文本的消息传递</strong>：基于文本的消息本身不包含任何处理逻辑和数据类型，因此服务间只传递文本，双方不存在兼容性问题</li>
<li><strong>上下文无关</strong>：在SOA中，在设计阶段，服务不需要了解它们将来可能被复用的环境，即独立于服务使用者的上下文</li>
<li><strong>大粒度复用</strong>：更多的关注诸如业务过程&#x2F;业务活动级别的复用，复用效率更高</li>
</ol>
<h3 id="SOA适合应用的场景"><a href="#SOA适合应用的场景" class="headerlink" title="SOA适合应用的场景"></a>SOA适合应用的场景</h3><p><strong>协同—交互—异构—分布式环境—可能频繁变化</strong></p>
<h3 id="10种SOA应用场景及相应体系结构模式"><a href="#10种SOA应用场景及相应体系结构模式" class="headerlink" title="10种SOA应用场景及相应体系结构模式"></a>10种SOA应用场景及相应体系结构模式</h3><ul>
<li><strong>硬连线(Hard-wired)</strong></li>
<li><strong>点对点的服务发布与调用(P2P)</strong></li>
<li><ul>
<li>发布(Publish)：为了使服务可访问，需要发布服务描述以使服务使用者可以发现它。</li>
</ul>
</li>
<li><ul>
<li>发现(Find)：服务请求者定位服务，方法是查询服务注册中心来找到满足其标准的服务。</li>
</ul>
</li>
<li><ul>
<li>绑定(Bind)和调用(invoke)：在检索到服务描述之后，服务使用者继续根据服务描述中的信息来调用服务。</li>
</ul>
</li>
<li><strong>服务适配器(Service adaptor)</strong></li>
<li><ul>
<li>企业中存在若干遗留系统(legacy system)采用较传统的技术开发，无法提供清晰的接口(interface)，但其他系统仍然需要访问这些遗留系统的功能。通过构造**适配器(adaptor)**，将遗留系统中的功能进行二次包装，从而开放出接口供其他系统使用。</li>
</ul>
</li>
<li><strong>服务代理(Service proxy)</strong><ol>
<li>客户端直接绑定服务接口(WSDL&#x2F;URI)</li>
<li>客户端通过“service registry”来访问服务，当希望访问其他服务时，只要手工修改该registry即可——相当于一个配置文件</li>
<li>客户端通过“service broker”来动态决定需访问那个服务。完全动态的服务选择，很困难，需要用到服务语义的相关技术</li>
</ol>
</li>
<li><strong>远程服务策略(Remote service strategy)</strong></li>
<li><strong>单点访问(Single point of access)</strong></li>
<li><strong>虚拟服务提供者(Virtual provider)</strong></li>
<li><strong>服务集成器(Service integrator)</strong><ol>
<li>将remote service strategy的思想进一步发挥，客户端不去逐一调用服务，而是首先将这些被调用的服务按逻辑关系集成起来，形成一个集成的、大粒度的服务</li>
<li>客户端只需调用这一个服务即可</li>
<li>当该服务执行时，集成器(integrator)依靠配置信息来分别调用一个个小粒度的服务</li>
<li>对这些配置信息进行修改，即可方便的做到变更</li>
</ol>
</li>
<li><strong>企业服务总线(Enterprise service bus)</strong></li>
<li><ul>
<li><strong>路由</strong>服务间的消息</li>
</ul>
</li>
<li><ul>
<li><strong>转化</strong>请求者和服务之间的传输协议</li>
</ul>
</li>
<li><ul>
<li><strong>转换</strong>请求者和服务之间的消息格式</li>
</ul>
</li>
<li><ul>
<li><strong>处理</strong>分离资源间的业务事件</li>
</ul>
</li>
<li><strong>集成化的服务生态系统(Integrated service ecosystem)</strong></li>
</ul>
<h2 id="Web服务基础"><a href="#Web服务基础" class="headerlink" title="Web服务基础"></a>Web服务基础</h2><h3 id="Web服务概念"><a href="#Web服务概念" class="headerlink" title="Web服务概念"></a>Web服务概念</h3><p>传统上，我们把<strong>计算机后台程序提供的功能</strong>，称为“服务”（service）。通俗地说，“服务”就是计算机可以提供的某一种功能。</p>
<ul>
<li><p>本地服务：使用同一台机器提供的服务，不需要网络。</p>
</li>
<li><p>网络服务：使用另一台计算机提供的服务，必须通过网络才能完成</p>
</li>
<li><p>Web服务是一种面向服务的架构的技术，通过<strong>标准的Web协议</strong>提供服务，目的是保<strong>证不同平台的应用服务可以互操作</strong></p>
</li>
<li><p>根据W3C的定义，<strong>Web服务应当是一个软件系统，用以支持网络间不同机器的互动操作。网络服务通常是许多应用程序接口（API）所组成的，它们透过网络，例如国际互联网（Internet）的远程服务器端，执行客户所提交服务的请求</strong></p>
</li>
<li><p>Web Service架构的基本思想，就是尽量把非核心功能交给其他人去做，自己全力开发核心功能。</p>
</li>
</ul>
<p>简单来说，Web Service就是一个<strong>向外界暴露出接口的能够通过网络进行远程调用</strong>的应用程序。更准确地说：</p>
<ul>
<li>一方面<strong>Web Service是一种部署在Web上的对象</strong></li>
<li>另一方面<strong>Web Service是建立在以XML为主的、开放的Web标准协议规范的基础上的分布式应用新平台</strong></li>
</ul>
<p>Web Services（Web服务）定义：</p>
<ul>
<li>Web Service是一种<strong>新的 Web 应用程序分支</strong>，它们是自包含、自描述、模块化的应用，可以在网络(通常为 Web)中被描述、发布、查找以及通过 Web 来调用</li>
<li>使用标准的互联网协议，像超文本传输协议 HTTP 和 XML</li>
<li>Web service平台是一套标准，它定义了应用程序如何在Web上实现互操作性。你可以用任何你喜欢的语言，在任何你喜欢的平台上写Web service</li>
</ul>
<h3 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h3><p>什么是SOAP？</p>
<ul>
<li>SOAP 指<strong>简易对象访问协议(Simple Object Access Protocol)</strong></li>
<li>SOAP 是一种<strong>通信协议</strong></li>
<li>SOAP 用于<strong>应用程序之间</strong>的通信</li>
<li>SOAP 是一种用于<strong>发送消息</strong>的格式</li>
<li>SOAP 被设计用来<strong>通过因特网</strong>进行通信</li>
<li>SOAP <strong>独立于平台</strong></li>
<li>SOAP <strong>独立于语言</strong></li>
<li>SOAP <strong>基于 XML</strong></li>
<li>SOAP <strong>很简单并可扩展</strong></li>
<li>SOAP 允许您<strong>绕过防火墙</strong></li>
<li>SOAP 将被作为 <strong>W3C 标准</strong>来发展</li>
</ul>
<p>SOAP(Simple Object Access Protocol)：</p>
<ul>
<li><strong>基于XML实现了一种消息格式以交换请求和使用</strong>，使用XML作为SOAP消息的基础使得任何实现基本的网络通信服务的系统都能处理和传送这类消息</li>
<li>SOAP的整个消息结构非常简单。除了消息结构外，SOAP没有定义额外的表述结构标准，没有定义自己的编码标准，没有定义自己的传输协议</li>
<li>SOAP可以使用任意的模式定义方式来定义内部传输内容的结构（编码方式一般使用XML Schema），可以与任意的网络传输方式来完成传</li>
</ul>
<p>一条 SOAP 消息就是一个普通的 XML 文档，包含下列元素：</p>
<ul>
<li>必需的 Envelope 元素，可把此 XML 文档标识为一条 SOAP 消息</li>
<li>可选的 Header 元素，包含头部信息</li>
<li>必需的 Body 元素，包含所有的调用和响应信息</li>
<li>可选的 Fault 元素，提供有关在处理此消息所发生错误的信息</li>
</ul>
<p>SOAP消息基本结构</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">soap:Envelope</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:soap</span>=<span class="string">&quot;http://www.w3.org/2001/12/soap-envelope&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">soap:encodingStyle</span>=<span class="string">&quot;http://www.w3.org/2001/12/soap-encoding&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">soap:Header</span>&gt;</span></span><br><span class="line"> ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Header</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">soap:Body</span>&gt;</span></span><br><span class="line"> ...</span><br><span class="line"> <span class="tag">&lt;<span class="name">soap:Fault</span>&gt;</span></span><br><span class="line"> ...</span><br><span class="line"> <span class="tag">&lt;/<span class="name">soap:Fault</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>SOAP Envelop 元素：必需的 SOAP 的 Envelope 元素是 SOAP 消息的根元素。它可把 XML 文档定义为 SOAP 消息</li>
<li><ul>
<li>xmlns:soap 命名空间：SOAP 消息必须拥有与命名空间 “<span class="exturl" data-url="aHR0cDovL3d3dy53My5vcmcvMjAwMS8xMi9zb2FwLWVudmVsb3Bl">http://www.w3.org/2001/12/soap-envelope<i class="fa fa-external-link-alt"></i></span>“ 相关联的一个 Envelope 元素</li>
</ul>
</li>
<li><ul>
<li>encodingStyle 属性：定义在文档中使用的数据类型</li>
</ul>
</li>
<li>SOAP Header 元素：可选的 SOAP Header 元素可包含有关 SOAP 消息的应用程序专用信息（比如认证、支付等）。如果 Header 元素被提供，则它必须是 Envelope 元素的第一个子元素</li>
<li>SOAP Body 元素：必需的 SOAP Body 元素可包含打算传送到消息最终端点的实际 SOAP 消息</li>
<li>SOAP Fault 元素：SOAP Fault 元素用于存留 SOAP 消息的错误和状态信息。如果已提供了 Fault 元素，则它必须是 Body 元素的子元素。在一条 SOAP 消息中，Fault 元素只能出现一次</li>
</ul>
<p><strong>HTTP请求方法：</strong></p>
<ul>
<li>GET 请求获取Request-URI所标识的资源</li>
<li>POST 在Request-URI所标识的资源后附加新的数据</li>
<li>HEAD 请求获取由Request-URI所标识的资源的响应消息报头</li>
<li>PUT 请求服务器存储一个资源，并用Request-URI作为其标识</li>
<li>DELETE 请求服务器删除Request-URI所标识的资源</li>
<li>TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断</li>
<li>CONNECT 保留将来使用</li>
<li>OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求</li>
</ul>
<p>HTTP 在 TCP&#x2F;IP 之上进行通信。HTTP 客户机使用 TCP 连接到 HTTP 服务器。在<br>建立连接之后，客户机可向服务器发送 HTTP 请求消息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /item HTTP/1.1</span><br><span class="line">Host: 189.123.345.239</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 200</span><br></pre></td></tr></table></figure>
<p>随后服务器会处理此请求，然后向客户机发送一个 HTTP 响应。此响应包含了可指示请求状态的状态代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">200 OK</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 200</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，服务器返回了一个 200 的状态代码。这是 HTTP<br>的标准成功代码。假如服务器无法对请求进行解码，它可能会返回<br>类似这样的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">400 Bad Request</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure>

<p>SOAP 方法指的是遵守 SOAP 编码规则的 HTTP 请求&#x2F;响应（<strong>HTTP + XML &#x3D; SOAP</strong><br>）。SOAP 请求可能是 HTTP POST 或 HTTP GET 请求。HTTP POST 请求规定至少两个 HTTP 头：Content-Type 和 Content-Length。</p>
<ul>
<li>Content-Type：SOAP 的请求和响应的 Content-Type 头可定义消息的 MIME 类型，以及用于请<br>求或响应的 XML 主体的字符编码（可选）。</li>
<li>Content-Length：SOAP 的请求和响应的 Content-Length 头规定请求或响应主体的字节数。</li>
</ul>
<p>SOAP请求：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">POST /InStock HTTP/1.1</span><br><span class="line">Host: www.example.org</span><br><span class="line">Content-Type: application/soap+xml; charset=utf-8</span><br><span class="line">Content-Length: nnn</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">soap:Envelope</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:soap</span>=<span class="string">&quot;http://www.w3.org/2001/12/soap-envelope&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">soap:encodingStyle</span>=<span class="string">&quot;http://www.w3.org/2001/12/soap-encoding&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> <span class="tag">&lt;<span class="name">soap:Body</span> <span class="attr">xmlns:m</span>=<span class="string">&quot;http://www.example.org/stock&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">m:GetStockPrice</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">m:StockName</span>&gt;</span>IBM<span class="tag">&lt;/<span class="name">m:StockName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">m:GetStockPrice</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">soap:Body</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>SOAP 响应：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/soap+xml; charset=utf-8</span><br><span class="line">Content-Length: nnn</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">soap:Envelope</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:soap</span>=<span class="string">&quot;http://www.w3.org/2001/12/soap-envelope&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">soap:encodingStyle</span>=<span class="string">&quot;http://www.w3.org/2001/12/soap-encoding&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">soap:Body</span> <span class="attr">xmlns:m</span>=<span class="string">&quot;http://www.example.org/stock&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">m:GetStockPriceResponse</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">m:Price</span>&gt;</span>34.5<span class="tag">&lt;/<span class="name">m:Price</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">m:GetStockPriceResponse</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">soap:Body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>客户发送请求时，不管客户是什么平台，首先把请求<strong>转换成XML格式</strong>，<strong>SOAP网关</strong>可自动执行这个转换。为了保证传送时参数、方法名、返回值的唯一性，SOAP协议使用了一个私有标记表，从而服务器的SOAP网关可以正确地解析；<strong>而使用XML作为编码表现形式，提供了更高层次上的抽象，从而实现与平台和环境的无关</strong><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401121639930.png"></p>
<h3 id="WSDL"><a href="#WSDL" class="headerlink" title="WSDL"></a>WSDL</h3><p>什么是WSDL：</p>
<ul>
<li>WSDL 指<strong>网络服务描述语言(Web Service Description Language)</strong></li>
<li>WSDL 使用 XML 编写</li>
<li>WSDL 是一种 XML 文档</li>
<li>WSDL 用于<strong>描述网络服务</strong></li>
<li>WSDL 也可用于<strong>定位网络服务</strong></li>
<li><strong>这种文档可描述某个 Web service，它可规定服务的位置，以及此服务提供的操作（或方法）</strong></li>
</ul>
<p><strong>WSDL(Web Service Description Language)定义了一套基于XML的语法，将Web服务描述为能够进行消息交换的服务访问点的集合。是Web服务的接口描述语言</strong>，包含以下内容：</p>
<ul>
<li>What：<strong>Web服务做什么</strong>——所提供的操作</li>
<li>Where：<strong>Web服务位于哪里</strong>——协议相关的地址，如URL</li>
<li>How：<strong>怎样调用</strong>——和服务交互的数据格式以及必要协议</li>
</ul>
<p>WSDL主要元素：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401121642188.png"></p>
<p>WSDL文档实例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="meta">&lt;definitions name=<span class="string">&quot;urn:AddressFetcher2&quot;</span> ...&gt;</span></span><br><span class="line"><span class="meta">    &lt;types&gt;</span></span><br><span class="line"><span class="meta">        //定义服务使用的任何复杂数据类型</span></span><br><span class="line"><span class="meta">    &lt;/types&gt;</span></span><br><span class="line"><span class="meta">    &lt;message name=<span class="string">&quot; GetLastTradePriceInput &quot;</span>&gt;</span></span><br><span class="line"><span class="meta">        //调用者和服务之间传递的一条消息，要用到前面定义的数据类型</span></span><br><span class="line"><span class="meta">    &lt;/message&gt;</span></span><br><span class="line"><span class="meta">    &lt;portType name=<span class="string">&quot; StockQuotePortType &quot;</span>&gt;</span></span><br><span class="line"><span class="meta">        //定义服务提供什么操作，要用到前面定义的消息</span></span><br><span class="line"><span class="meta">    &lt;/portType&gt;</span></span><br><span class="line"><span class="meta">    &lt;binding name=<span class="string">&quot;StockQuoteSoapBinding &quot;</span></span></span><br><span class="line"><span class="meta">        //定义服务如何被调用</span></span><br><span class="line"><span class="meta">    &lt;/binding&gt;</span></span><br><span class="line"><span class="meta">    &lt;service name=<span class="string">&quot;StockQuoteService &quot;</span>&gt;</span></span><br><span class="line"><span class="meta">        //描述服务位于哪里</span></span><br><span class="line"><span class="meta">    &lt;/service&gt;</span></span><br><span class="line"><span class="meta">&lt;/definitions&gt;</span></span><br></pre></td></tr></table></figure>

<p>WSDL概念模型：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401121645549.png"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401121645307.png"></p>
<h3 id="UDDI"><a href="#UDDI" class="headerlink" title="UDDI"></a>UDDI</h3><p>什么是UDDI：</p>
<ul>
<li>UDDI 是一个独立于平台的框架，用于通过使用 Internet 来描述服务，发现企业，并对企业服务进行集成。</li>
<li>UDDI 指的是通用描述、发现与集成服务</li>
<li>UDDI 是一种用于存储有关 web services 的信息的目录。</li>
<li>UDDI 是一种由 WSDL 描述的 web services 界面的目录。</li>
<li>UDDI 经由 SOAP 进行通信</li>
<li>UDDI 被构建入了微软的 .NET 平台</li>
</ul>
<p><strong>UDDI是统一描述、发现和集成（Universal Description, Discovery, and Integration）的缩写。它是一个基于XML的跨平台的描述规范，可以使世界范围内的企业在网络上发布自己所提供的服务。</strong><br><strong>UDDI计划是一个广泛的，开放的行业计划</strong>，它使得商业实体能够：</p>
<ul>
<li>彼此发现</li>
<li>定义他们怎样在internet上互相作用，并在一个全球的注册体系架构中共享信息</li>
</ul>
<p>UDDI数据表类型：</p>
<ul>
<li>白页：包含了基本的企业信息</li>
<li>黄页：按分类法对企业信息进行分类</li>
<li>绿页：包含了如何与企业进行电子交互的信息</li>
</ul>
<p>UDDI的信息模型：</p>
<ol>
<li>businessEntity元素：支持对UDDI商业注册的商业信息发布和发现的核心XML元素都包含在该结构中，这个结构是商业实体专属信息集的最高层的数据容器，位于整个信息结构的最上层</li>
<li>businessService元素：将一系列有关商业流程或分类目录的Web服务的描述组合到一起。businessService和下面要提到的bindingTemplate一起构成了”绿页”信息</li>
<li>bindingTemplate元素：对于每一个businessService，存在一个或多个Web服务的技术描述bindingTemplate</li>
<li>tModel元素：是一个技术规范的超类，tModel能够描述商业标示符数据库、分类方法、技术规范、网络协议等各类的技术规范，是UDDI Web服务元数据管理的基础</li>
</ol>
<p>UDDI的工作原理：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401121653066.png"></p>
<h2 id="Web服务实现【实验1指导书及任务】"><a href="#Web服务实现【实验1指导书及任务】" class="headerlink" title="Web服务实现【实验1指导书及任务】"></a>Web服务实现【实验1指导书及任务】</h2><h3 id="如何开发自己的Web服务-Java平台为例"><a href="#如何开发自己的Web服务-Java平台为例" class="headerlink" title="如何开发自己的Web服务(Java平台为例)"></a>如何开发自己的Web服务(Java平台为例)</h3><h3 id="如何访问调用已有的Web服务（生成代理类）"><a href="#如何访问调用已有的Web服务（生成代理类）" class="headerlink" title="如何访问调用已有的Web服务（生成代理类）"></a>如何访问调用已有的Web服务（生成代理类）</h3><h2 id="REST基础"><a href="#REST基础" class="headerlink" title="REST基础"></a>REST基础</h2><h3 id="REST是什么、有何关键特性、如何理解、无状态性的设计方式及优缺点"><a href="#REST是什么、有何关键特性、如何理解、无状态性的设计方式及优缺点" class="headerlink" title="REST是什么、有何关键特性、如何理解、无状态性的设计方式及优缺点"></a>REST是什么、有何关键特性、如何理解、无状态性的设计方式及优缺点</h3><p>REST是英文<strong>REpresentational State Transfer</strong>的缩写，<strong>表象化状态转变</strong>，或者<strong>表述性状态转移</strong></p>
<p>REST架构风格以<strong>资源</strong>为核心进行设计，从资源的角度来观察整个网络。网络上的所有事物都是资源，分布在各处的资源由URI确定，而客户端的应用通过URI来获取资源的表述。</p>
<ul>
<li>资源（Resources）：任何寄宿于Web可供操作的“事物”均可视为资源</li>
<li>表现层（Representation）：把”资源”具体呈现出来的形式，叫做它的”表现层”</li>
<li>状态转化（State Transfer）：互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”</li>
</ul>
<p>三者关联</p>
<ul>
<li>每一个URI代表一种资源</li>
<li>客户端和服务器之间，传递这种资源的某种表现层</li>
<li>客户端通过四个HTTP动词，对服务器端资源进行操作，实现“表现层状态转化”</li>
</ul>
<p><strong>REST的关键特性</strong>：</p>
<ul>
<li><strong>采用URL标识资源</strong>：标志性、可读性、可寻址性（Addressability）</li>
<li><strong>使用统一的接口</strong>：是针对不同资源的Web API定义一致性的操作来操作它们</li>
<li><strong>使用标准的HTTP方法</strong>：Web API分别针对CRUD的操作只能接受具有对应HTTP方法的请求</li>
<li><strong>支持多种资源表示方式</strong>：我们一般利用请求的Content-Type报头携带的媒体类型来判断其采用的表示类型</li>
<li><ul>
<li>让请求URI包含资源表示类型</li>
</ul>
</li>
<li><ul>
<li>采用“内容协商（Content Negotiation）”根据请求相关报头来判断它所希望的资源表示类型，比如“Accept”和“Accept-language”报头可以体现请求可以接受的响应媒体类型和语言</li>
</ul>
</li>
</ul>
<p>REST架构六个特点：客户端——服务器的、无状态的、可缓存的、统一接口、分层系统、按需编码</p>
<p>RESTful无状态性：</p>
<ol>
<li><strong>客户端-服务器通信中的每个请求必须包含所有必要信息</strong>：服务器不会存储关于客户端状态的信息（如会话信息）。这意味着每个请求都应当独立，服务器通过请求中的信息来理解并处理该请求。</li>
<li><strong>服务器不保存任何客户端请求的历史记录</strong>：每个请求都是独立的，服务器不依赖之前的请求或响应来处理当前的请求。</li>
<li><strong>认证和授权数据随每次请求发送</strong>：由于服务器不保存会话状态，所以每次请求都需要包含认证信息（如果需要的话），比如令牌或API密钥。</li>
</ol>
<ul>
<li>优点：简化服务器设计、提高可伸缩性、改善可靠性和可用性、便于缓存处理</li>
<li>缺点：可能增加网络负担、客户端复杂性增加、性能开销、安全风险</li>
</ul>
<h3 id="Why-REST"><a href="#Why-REST" class="headerlink" title="Why REST"></a>Why REST</h3><p>为什么要基于API开发：</p>
<ul>
<li>API让web，手机客户端，桌面多种操作成为可能，程序员分工更加明确，切降低了开发成本</li>
<li>软件开发依赖解耦</li>
<li>让编程语言发挥各自的优势</li>
</ul>
<p>REST优势：</p>
<ul>
<li>将用户界面和数据存储分离，提高用户界面跨多个服务平台</li>
<li>一个好的架构应该可以很轻松的为不同的请求返回不同格式的数据</li>
<li>使用REST的最佳的场景是对外提供公开的服务，也就是所谓的OpenAPI，也有的人认为REST更适合资源导向的网站，像youtube这样的网站</li>
<li>REST 的真正价值在于 Web Services，而不是通过浏览器操作的应用程序</li>
</ul>
<ol>
<li><strong>轻量级、HTTP</strong></li>
<li><strong>无状态请求可以由任何可用服务器回答，分布式、缓存、云计算</strong></li>
<li><strong>资源唯一URL、标准接口</strong></li>
<li><strong>基于成熟HTTP的安全模型</strong></li>
<li>简单、人类友好…</li>
</ol>
<h3 id="REST与MVC的关联对比、与RPC的对比"><a href="#REST与MVC的关联对比、与RPC的对比" class="headerlink" title="REST与MVC的关联对比、与RPC的对比"></a>REST与MVC的关联对比、与RPC的对比</h3><p>REST与MVC：</p>
<ul>
<li>MVC风格将模型、视图、控制解耦，其结构整洁、逻辑清晰，易于扩展和增强。MVC偏重于解决服务器端的逻辑分层问题，以及客户端是逻辑分层的延伸问题。但是MVC很难实现跨语言解耦。</li>
<li>REST风格偏重于统一接口，具体实现可以跨平台和跨语言。REST使用纯HTML作为客户端，没有服务器端和客户端的耦合。</li>
<li>MVC和REST并不是互斥的，如Spring的MVC模块已经开始支持REST式的开发，Jersery也实现了MVC的功能。</li>
</ul>
<p>REST与RPC：</p>
<ul>
<li>REST服务是一种ROA（Resource Oriented Architecture）应用，其主要特点是方法信息存在于HTTP协议的方法中，作用域存在于URI中，风格更轻量和快速。</li>
<li>从方法信息角度，REST采用标准的HTTP方法，RPC请求都是HTTP协议的POST方法，其方法信息包含于SOAP协议包或HTTP协议包中，方法名称不具有通用性。</li>
<li>从作用域角度看，REST采用URI显示定义作用域，而RPC这一信息同样包含于协议包中，不能直观呈现。</li>
<li>RPC风格的开发关注于服务器-客户端之间的方法调用，是面向方法调用过程的，而REST是面向资源状态的。</li>
<li>备注：PRC风格的两个代表是XML-RPC和SOAP Service</li>
</ul>
<h2 id="REST-API设计"><a href="#REST-API设计" class="headerlink" title="REST API设计"></a>REST API设计</h2><h3 id="统一接口、安全性幂等性"><a href="#统一接口、安全性幂等性" class="headerlink" title="统一接口、安全性幂等性"></a>统一接口、安全性幂等性</h3><p>HTTP方法基本特性：安全性、幂等性</p>
<ul>
<li><p><strong>安全性</strong>是指<strong>外系统对该接口的访问，不会使服务器资源的状态发生改变</strong></p>
</li>
<li><p><strong>幂等性（Idempotent）</strong>是一个数学上的概念，在这里是指<strong>外系统对同一REST接口的多次访问，得到的资源状态是相同的</strong>。在网速不够快的情况下，客户端发送一个请求后不能立即得到响应，由于不能确定是否请求是否被成功提交，所以它有可能会再次发送另一个相同的请求，幂等性决定了第二个请求是否有效。</p>
</li>
<li><p>GET：HTTP的GET方法用于读取资源。GET方法是幂等的，因为读取同一个资源，总是得到相同的数据。GET方法也是安全的，因为读取资源不会对其状态做改动。JAX-RS2.0指出了@GET注释对资源方法的定义，使得该方法用于处理GET请求。</p>
</li>
<li><p>PUT：PUT方法是幂等的，即多次或者更新统一份数据，在服务器端对资源状态所产生的改变是相同的。<strong>PUT方法不是安全的</strong>，有写动作的HTTP方法都不是安全的。</p>
</li>
<li><p>DELETE：方法是幂等的，即多次删除同一份数据（通常请求中传递的参数是数据的主键值），在服务端产生的改变是相同的。JAX-RS 2.0定义了 @DELETE注释来定义相关资源方法。</p>
</li>
<li><p>POST：定义为POST的REST接口用于写数据。POST方法的特性是<strong>既不幂等也不安全</strong>。因为请求会改变服务器端资源的状态，因此不是安全的；每次请求对服务器资源状态的改变并不是相同的，因此不是幂等的</p>
</li>
</ul>
<h3 id="资源定位、资源路径设计"><a href="#资源定位、资源路径设计" class="headerlink" title="资源定位、资源路径设计"></a>资源定位、资源路径设计</h3><p><strong>对外提供REST式的Web服务的接口就是公布一系列的URI及其参数</strong></p>
<p>资源地址的设计过程是面向资源的，<strong>资源名称应是准确描述该资源的名词，资源地址应具有直观的描述性</strong>。比如一个班级的资源地址可以是：学校&#x2F;学院&#x2F;年级&#x2F;班级。值得注意的是，一个URI资源地址唯一对应一个资源，但是一个资源可以拥有多个URI资源地址。比如Jersey最新版本的文档地址和Jersey2.9版本的文档地址指向同一个资源。</p>
<p>资源路径概览：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401121944651.png"><br>注意：资源地址相同，但HTTP方法不同的两个方法是两个不同的REST接口。HTTP方法和资源地址结合在一起才可以完成对资源的定位。</p>
<p>@RequestMapping：</p>
<ul>
<li>用来处理请求地址映射，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</li>
<li>默认请求方法是GET</li>
<li><ul>
<li>@GetMapping 等同于 @RequestMapping(method &#x3D;</li>
</ul>
</li>
<li><ul>
<li>RequestMethod.GET)</li>
</ul>
</li>
<li><ul>
<li>@PostMapping 等同于 @RequestMapping(method &#x3D;</li>
</ul>
</li>
<li><ul>
<li>RequestMethod.POST)</li>
</ul>
</li>
<li><ul>
<li>@PutMapping 等同于 @RequestMapping(method &#x3D;</li>
</ul>
</li>
<li><ul>
<li>RequestMethod.PUT)</li>
</ul>
</li>
<li><ul>
<li>@DeleteMapping 等同于 @RequestMapping(method &#x3D;<br>RequestMethod.DELETE)</li>
</ul>
</li>
</ul>
<p>@PathVariable：</p>
<ul>
<li>获取url中的数据</li>
<li>通过@PathVariable注解来获取URL中的参数时的前提条件是我们知道url的格式时怎么样的。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 url=localhost:8080/hello/id/name 中的id、name值</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/hello/&#123;id&#125;/&#123;name&#125;&quot;,method= RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id,<span class="meta">@PathVariable(&quot;name&quot;)</span> String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;id:&quot;</span>+id+<span class="string">&quot; name:&quot;</span>+name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>@RequestParam：获取请求参数的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 url=localhost:8080/hello?id=98 中的id值</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/hello&quot;,method= RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(<span class="meta">@RequestParam(&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;id:&quot;</span>+id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Controller请求与URL重构</strong>：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401121952190.png"></p>
<h3 id="【实验2指导书和任务】：如何开发和调用Restful-API-services"><a href="#【实验2指导书和任务】：如何开发和调用Restful-API-services" class="headerlink" title="【实验2指导书和任务】：如何开发和调用Restful API services"></a>【实验2指导书和任务】：如何开发和调用Restful API services</h3><h2 id="服务组合技术"><a href="#服务组合技术" class="headerlink" title="服务组合技术"></a>服务组合技术</h2><h3 id="服务编排"><a href="#服务编排" class="headerlink" title="服务编排"></a>服务编排</h3><p><strong>服务编排（Orchestration）：将多个小粒度的Web服务按照特定的业务逻辑规则构造为一个可执行的业务过程，同时又可以看作是一个大粒度的复合Web服务。</strong></p>
<ul>
<li>执行时需要有中心控制机制</li>
<li>由一个组织所拥有</li>
<li>侧重点：<strong>如何使用已有的服务来构造新的服务</strong><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401121958499.png"></li>
</ul>
<p>BPEL能够实现基于WSDL的Web Services之间的流程编排和服务协同，它提供了一种XML注释和语义，用于指定对Web Services进行编排并确定Web服务之间的业务流程，实现Web Services之间的协同。</p>
<ul>
<li><strong>过程中的基本功能单元：活动<activity></strong></li>
<li>活动之间的次序关系：</li>
<li><ul>
<li>先后次序<sequence></li>
</ul>
</li>
<li><ul>
<li>多分支<switch></li>
</ul>
</li>
<li><ul>
<li>循环<while></li>
</ul>
</li>
<li><ul>
<li>并发与同步<flow></li>
</ul>
</li>
<li><ul>
<li>非确定性选择<pick></li>
</ul>
</li>
<li><strong>过程的相关数据：容器<container></strong></li>
<li><strong>错误处理机制：<catching>、<handling faults></strong></li>
<li><strong>补偿机制：<compensation handler></strong></li>
</ul>
<p>运行模式：</p>
<ul>
<li>集中式的执行引擎<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401122003992.png"></li>
<li>基于Hub的分布式引擎<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401122003950.png"></li>
<li>无Hub的分布式引擎<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401122003359.png"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401122003864.png"></li>
</ul>
<h3 id="服务协同"><a href="#服务协同" class="headerlink" title="服务协同"></a>服务协同</h3><p><strong>服务协同（Choreography）：将多个零散的、分别由多方提供的服务&#x2F;业务流程按照彼此之间的协同关系组织起来，支持多方的交互行为。</strong></p>
<ul>
<li>侧重于不同服务之间的消息传递的次序与规则，以保证期望的协同行为。</li>
<li>无需中心控制；</li>
<li>无需完全由一个组织所拥有；<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401122006841.png"></li>
</ul>
<p>分类：</p>
<ul>
<li>链式协同模式（Chained）</li>
<li>同步协同模式（Synchronized）</li>
<li>嵌套协同模式（Nested）<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401122007287.png"></li>
<li>复合模式<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401122007745.png"></li>
</ul>
<h3 id="两者比较"><a href="#两者比较" class="headerlink" title="两者比较"></a>两者比较</h3><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401122008981.png"></p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401122008680.png"></p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401122009928.png"></p>
<p>二者在协议栈中的位置（协同位于编排之上）：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401122009651.png"></p>
<h2 id="服务业务流程"><a href="#服务业务流程" class="headerlink" title="服务业务流程"></a>服务业务流程</h2><h3 id="BPEL规范"><a href="#BPEL规范" class="headerlink" title="BPEL规范"></a>BPEL规范</h3><p>业务流程执行语言（Business Process Execution Language, BPEL, 发音为’bipple’或’bee-pell’），也叫业务过程执行语言，是一种基于XML的，用来描写业务流程的编程语言，被描写的业务流程的每个单一步骤则由Web服务来实现。</p>
<ul>
<li>BPEL是基于Web服务的，并且依赖于WSDL。</li>
<li>一个BPEL流程可以发布为一个WSDL定义的服务，并像其它Web服务一样被调用。而且，BPEL希望一个Web服务合成所包含的全部外部Web服务，都是用WSDL服务契约定义的，这令BPEL流程可以调用其它BPEL流程，甚至可以递归的调用自己。</li>
<li>值得注意的是BPEL不直接支持人机对话，BPEL所描写的过程仅与Web服务通信，而这些Web服务却可以提供与用户的信息交换，但它们不是用户本身。</li>
<li>用BPEL编写的流程可以在任何支持BPEL规范的平台或产品上运行。</li>
</ul>
<p>协议基础：</p>
<ul>
<li>WS—BPEL是基于XML定义的流程描述语言，它位于几个XML规范之上：WSDLl.1、XML Schemal.0和XPathl.0。</li>
<li>其中WSDL消息和XML Schema类型定义提供了BPEL流程所用的数据模型;XPath为数据处理提供支持;所有的外部资源和伙伴被表示成WSDL服务。</li>
</ul>
<p>BPEL包含的范围：</p>
<ul>
<li>处理活动的顺序，特别是网络服务互操作。</li>
<li>消息和处理实例之间的关系。</li>
<li>在发生错误和例外情况下的恢复行为。</li>
<li>处理角色之间的基于网络服务关系的双面性</li>
</ul>
<p>BPEL引入元素：</p>
<ol>
<li><strong>伙伴链接</strong></li>
</ol>
<ul>
<li>BPEL把与流程交互的其他服务称为伙伴。一个流程可以调用其他服务，也可以响应来自客户端的请求。一个流程既可以作为服务的请求者，也可以扮演服务的提供者。在异步通信环境中，流程与伙伴之间的会话可能是双向的，它们会扮演不同的角色。因此，为了消除在通信过程中的多义性，我们需要明确服务和流程所扮演的角色</li>
<li>伙伴链接用于实现Web服务长期稳定的交互，描述伙伴之间的关联。这种动态伙伴关系为流程带来了极大的灵活性，也增强了流程的可复用性</li>
<li>伙伴链接类型<strong>声明了两个或多个服务之间的关系</strong></li>
<li>伙伴链接类型定义了一组角色，其中每个角色指明一组Port Type，即明确了该角色所提供的服务接口，一边接收会话的上下文消息。 如果partnerLinkType仅有一个角色，那么将根据需要省略其中一个属性</li>
</ul>
<ol start="2">
<li><strong>变量</strong></li>
</ol>
<ul>
<li>在BPEL中，可以使用变量来保存和传递流程的状态信息。它们通常是从合作伙伴那里接收到消息，或者是被发送给合作伙伴的消息。同时，它们还有可能是与流程有关的状态消息，这些消息并不与合作伙伴进行交换</li>
<li>由WSDL文件所定义的消息类型(message type)，表示允许变量包含WSDL定义的整个信息；由XML Schema所定义的简单类型(simple type)，表示一个XSD元素结构;由XML Schema所定义的元素(element)，表示一个XSD简单结构，比如：string ,integer</li>
<li>变量是有作用域的。属于全局流程作用域的变量称为全局变量；属于流程作用域的变量称为局部变量</li>
</ul>
<ol start="3">
<li>活动</li>
</ol>
<ul>
<li>BPEL是由一系列步骤组成，这些步骤称为活动</li>
<li><strong>基本活动</strong>描述了<strong>流程内的一个具体步骤</strong>，如接受请求、调用伙伴服务、变量赋值等，是与外界进行交互最简单的形式，活动内不会嵌套其它活动。它们是无序的个别步骤，与服务进行交互、操作、传输数据或者处理异常等</li>
<li><strong>结构化活动</strong>描述了如何组织和管理流程的控制流，规定了<strong>一组活动发生的顺序</strong>。他们描述了业务流程是怎样通过把它执行的基本活动组成结构而被创建的，这些结构表达了涉及业务协议的流程实例间的控制形式、数据流程、故障和外部事件的处理以及消息交换的协调。结构化的活动可以被任意地嵌套和组合</li>
<li>关联集合</li>
<li>事件处理程序</li>
<li>BPEL事务与补偿机制</li>
<li>BPEL异常管理</li>
</ul>
<p>部分元素之间关系：</p>
<ul>
<li>流程是由一系列的活动组成的；</li>
<li>流程通过伙伴链接来定义与流程交互的其他服务；</li>
<li>服务中可以定义一些变量；</li>
<li>流程可以是有状态的长时间运行过程，流程引擎可以通过关联集合将一条消息关联到特定的流程实现。</li>
</ul>
<h3 id="BPEL引擎"><a href="#BPEL引擎" class="headerlink" title="BPEL引擎"></a>BPEL引擎</h3><p>活动详解：Receive(接收)&#x2F;Reply(回答)</p>
<p><Receive>活动从流程的外部伙伴那获得数据，并将其保存到流程变量。</p>
<ul>
<li>通常一个Receive是一个流程的初始点，它会阻塞执行直到匹配的消息的到达。</li>
<li>在异步信息交换时，receive也可以接收回收信息。</li>
</ul>
<p><receive>元素有5个属性：</p>
<ul>
<li>partnerLink:在通信过程中识别伙伴</li>
<li>portType:从伙伴方接收请求消息的接口</li>
<li>operation:接收请求消息</li>
<li>variable:用来存储接收到的请求消息</li>
<li>createInstance:当该属性设置为”yes”时，它指明了当前流程接收到匹配消息是会创建新的流程实例来处理该请求</li>
</ul>
<p><Reply>活动发送消息给伙伴来应答通过Receive活动所接收到的消息。</p>
<ul>
<li>Receive和Reply的组合对应着WSDL portType上定义的一个请求—响应操作。</li>
<li>如果receive活动对应着一个单向操作，则不能在流程中定义对应的reply活动。</li>
</ul>
<p><Reply>元素也有5个属性：</p>
<ul>
<li>其中，partnerLink，portType和operation含义同receive元素的属性含义相同。</li>
<li>variable:用来存储从伙伴返回的消息</li>
<li>messageExchange：这是一个WS-BPEL2.0新增加的可选的属性。它使得reply元素可以精确的关联到一个能够接收信息的活动（比如 receive元素）</li>
</ul>
<p>包含receive&#x2F;reply活动的片段：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receive</span> <span class="attr">name</span>=<span class="string">&quot;receiveInput&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">partnerLink</span>=<span class="string">&quot;client&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">portType</span>=<span class="string">&quot;tns:TimesheetSubmissionInterface&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">operation</span>=<span class="string">&quot;Submit&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">variable</span>=<span class="string">&quot;ClientSubmission&quot;</span> <span class="attr">createInstance</span>=<span class="string">&quot;yes&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">reply</span> <span class="attr">partnerLink</span>=<span class="string">&quot;client&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">portType</span>=<span class="string">&quot;tns:TimesheetSubmissionInterface&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">operation</span>=<span class="string">&quot;Submit&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">variable</span>=<span class="string">&quot;TimesheetSubmissionResponse&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li>在实例4中：receive和reply活动中都是通过partnerLink来引导预定义伙伴关系的，而且需要设置portType和operation属性来声明流程实现的WSDL portType和操作</li>
<li>如果将receive活动作为流程的起始点，则需要将receive活动的createInstance属性设置为”yes”，它指明了当前流程接收到匹配消息是会创建系的流程实例来处理该请求</li>
</ol>
<h3 id="【实验3-4指导书及任务】编排微服务及运行监控实例流程"><a href="#【实验3-4指导书及任务】编排微服务及运行监控实例流程" class="headerlink" title="【实验3-4指导书及任务】编排微服务及运行监控实例流程"></a>【实验3-4指导书及任务】编排微服务及运行监控实例流程</h3>]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>soa</tag>
        <tag>university</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络笔记</title>
    <url>/2023/10/08/computer-network/</url>
    <content><![CDATA[<blockquote>
<p> 参考书籍：计算机网络——自顶向下方法（原书第 8 版）</p>
</blockquote>
<span id="more"></span>

<h2 id="第-1-章-计算机网络和因特网"><a href="#第-1-章-计算机网络和因特网" class="headerlink" title="第 1 章 计算机网络和因特网"></a>第 1 章 计算机网络和因特网</h2><p>端系统（end system）通过通信链路（communication link）和分组交换机（packet switch）的网络连接到一起。</p>
<p>端系统通过因特网服务提供商（Internet Service Provider，ISP）接入因特网。每一个 ISP 网络都是独立管理的。</p>
<ul>
<li>TCP（Transmission Control Protocol，传输控制协议）</li>
<li>IP（Internet Protoc，网络协议）</li>
</ul>
<p>分布式应用（distributed application）：涉及多个相互交换数据的端系统。</p>
<p>与因特网相连的端系统提供了一个套接字接口（socket interface），因特网套接字接口是一套发送程序必须遵循的规则集合。</p>
<p>为了完成一项工作，要求两个（或多个）通信实体运行相同的协议。<br>&#x2F;&#x2F; TODO：附图计算机网络协议 P5</p>
<p><strong>向一个 Web 服务器发出请求（即在 Web 浏览器中键入一个 Web 网页的 URL）所发生的情况</strong>：<br>首先，计算机向该 Web 服务器发送一条连接请求报文，并等待回答。该 Web 服务器最终能接收到连接请求报文，并返回一条连接响应报文。得知请求该 Web 文档正常后，计算机则在一条 GET 报文中发送该网页的名字，而该网页的名字要从这台 Web 服务器上取回。最后，Web 服务器向你的计算机返回该 Web 网页（文件）。</p>
<p>协议（protocol）定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文的发送&#x2F;接收或其他事件所采取的操作。</p>
<p>WiFi：基于 IEEE 802.11 技术的无线 LAN（局域网）接入</p>
<p>为了从源端系统向目的端系统发送一个报文（message），源将长报文划分为较小的数据块，称为分组（packet）。在源和目的地之间，每个分组都通过通信链路（communication link）和分组交换机（packet switch）传送，交换机主要有路由器（router）和链路层交换机（link-layer switch）两类。</p>
<p>存储转发传输（store-and-forward transmission）：交换机在开始向输出链路传输该分组的第一个比特之前，必须接受到整个分组。</p>
<p>分组交换机具有一个输出缓存【output buffer，也称为输出队列（output queue）】，缓存充满时将出现分组丢失（丢包）（packet loss），到达的分组或已经排队的分组之一将被丢弃。</p>
<p>转发表（forwarding table）用于将目的地址（或目的地址的一部分）映射为输出链路。</p>
<p>通过网络链路和交换机移动数据有两种基本方法：电路交换（circuit switching）和分组交换（packet switching）。<br>在电路交换网络中，在端系统间通信会话期间，预留了端系统间沿路径通信所需要的资源（缓存，链路传输速率）。在分组交换网络中，这些数据不是预留的。<br>因特网尽最大努力以及时方式交付分组，但它不做任何保证。</p>
<p><strong>电路交换网络中的复用</strong></p>
<ul>
<li>频分复用（Frequency-Division Multiplexing, FDM）：链路的频谱由跨越链路创建的所有连接共享。特别是，在连接期间为每条连接专设一个频段。该频段的宽度称为带宽（band-width）。</li>
<li>时分复用（Time-Division Multiplexing, TDM）：时间被划分为固定的帧，而且每个帧又被划分为固定数量的时隙。当网络跨越链路创建一条连接时，网络在每个帧中为该连接指定一个时隙。</li>
</ul>
<p>电路交换不够经济：静默期 （silent period）专用电路是空闲的。</p>
<p>端到端电路传输时间与链路数量无关。</p>
<p>对比：</p>
<ol>
<li>分组交换不适合实时服务</li>
<li>比电路交换更好的带宽共享，更简单有效，实现成本更低</li>
</ol>
<p>&#x2F;&#x2F; TODO：ISP 互联图</p>
<p>位于相同等级结构层次的临近的一对 ISP 能够对等（peer），当两个 ISP 对等时，为减少费用通常不进行结算，即任何一个 ISP 都不对其对等付费。<br>因特网交换点（Internet Exchange Point，IXP）是一个汇合点，多个 ISP 能够在这里一起对等。<br>谷歌专用网络通过与较低层 ISP 对等（无结算），尝试“绕过”互联网的较高层。通过创建自己的网络，内容提供商不仅减少了向顶层 ISP 支付的费用，而且对其服务最终如何交付给端用户有了更多的控制。</p>
<p>节点总时延（total nodal delay）：</p>
<ul>
<li>节点处理时延（nodal processing delay）</li>
<li>排队时延（queuing delay）</li>
<li>传输时延（transmission delay）</li>
<li>传播时延（propagation delay）<br>传输时延事路由器推出分组所需要的时间，它是分组长度和链路传输速率的函数，而与两台路由器之间的距离无关。而传播时延是一个比特从一台路由器传播到另一台路由器所需要的时间，它是两台路由器之间的距离的函数，与分组长度或链路传输速率无关。</li>
</ul>
<p>排队时延很大程度取决于流量到达队列的速率、链路的传输速率和到达流量的性质，即流量是周期性到达还是以突发形式到达。</p>
<p>a - 分组到达队列的平均速率（分组&#x2F;秒，pkt&#x2F;s）<br>R - 传输速率，即从队列中推出比特的速率（bps）<br>假设所有分组由 L bit 组成，则比特到达队列的平均速率是<code>La bps</code>，流量强度（traffic intensity）为<code>La/R</code><br><em>sh</em></p>
]]></content>
      <categories>
        <category>GEE</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>computer network</tag>
      </tags>
  </entry>
  <entry>
    <title>中南云麓谷研发部2023招新面试题</title>
    <url>/2023/08/04/recruitment-2023/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>请不要被以下的内容吓走，也许从目前的你看来是太过困难；请放心，只要愿意学习，你会做的比图示更好。</p>
<h2 id="理论学习"><a href="#理论学习" class="headerlink" title="理论学习"></a>理论学习</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="html"><a href="#html" class="headerlink" title="html"></a>html</h4><h5 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h5><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXZzNDExTTdhVA==">为初学者准备的：HTML 速成<i class="fa fa-external-link-alt"></i></span></p>
<h5 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h5><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRNTA==">MDN Web docs<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9odG1sL2h0bWwtdHV0b3JpYWwuaHRtbA==">HTML教程|菜鸟教程<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cudzNzY2hvb2wuY29tLmNuL3RhZ3MvaW5kZXguYXNw">W3school HTML<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>

<h4 id="css"><a href="#css" class="headerlink" title="css"></a>css</h4><h5 id="视频-1"><a href="#视频-1" class="headerlink" title="视频"></a>视频</h5><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWJXNDExUjdoZw==">为初学者准备的：CSS 速成<i class="fa fa-external-link-alt"></i></span></p>
<h5 id="文档-1"><a href="#文档-1" class="headerlink" title="文档"></a>文档</h5><p>与HTML站点相同，不再复述。</p>
<h4 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h4><h5 id="视频-2"><a href="#视频-2" class="headerlink" title="视频"></a>视频</h5><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMUp0NDExRDdqNg==">为初学者准备的：JavaScript 速成<i class="fa fa-external-link-alt"></i></span></p>
<h5 id="文档-2"><a href="#文档-2" class="headerlink" title="文档"></a>文档</h5><p>与HTML站点相同，不再复述。<br><span class="exturl" data-url="aHR0cHM6Ly96aC5qYXZhc2NyaXB0LmluZm8v">现代JavaScript教程<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="提高"><a href="#提高" class="headerlink" title="提高"></a>提高</h3><p><a href="%22https://zhuanlan.zhihu.com/p/260177225%22">HTML5 + CSS3</a></p>
<h2 id="招新作业"><a href="#招新作业" class="headerlink" title="招新作业"></a>招新作业</h2><h3 id="基础题"><a href="#基础题" class="headerlink" title="基础题"></a>基础题</h3><p>请设计并完成如下页面：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308021013086.jpeg"></p>
<h3 id="提高题"><a href="#提高题" class="headerlink" title="提高题"></a>提高题</h3><p>请根据<strong>HTML5和CSS3规范</strong>复现如下页面，其中图片资源在<strong>文末</strong>提供。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308050951824.jpeg"></p>
<h4 id="基础要求"><a href="#基础要求" class="headerlink" title="基础要求"></a>基础要求</h4><p>了解并合理使用<strong>盒子模型</strong>、<strong>flex 布局</strong>以及其他 CSS 知识完成网页布局，各模块布局合理。</p>
<h4 id="提高部分"><a href="#提高部分" class="headerlink" title="提高部分"></a>提高部分</h4><p>在基础要求的基础上，自主完善网页功能，包括但不限于网页间的联动、表单的使用等。请大胆发挥你的创意。</p>
<h3 id="进阶题"><a href="#进阶题" class="headerlink" title="进阶题"></a>进阶题</h3><p>请在以下二题中<mark class="label success">任选其一</mark>完成。</p>
<h4 id="微信小程序（推荐选做）"><a href="#微信小程序（推荐选做）" class="headerlink" title="微信小程序（推荐选做）"></a>微信小程序（推荐选做）</h4><p>利用相关知识完成一个主题为<strong>个人博客</strong>的微信小程序，示例如下（仅作参考）：</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://img1.imgtp.com/2023/08/01/PasamiB3.png"></div><div class="group-picture-column"><img data-src="https://img1.imgtp.com/2023/08/01/rpPMYMzf.png"></div><div class="group-picture-column"><img data-src="https://img1.imgtp.com/2023/08/01/vhRFbkzJ.png"></div></div></div>

<h5 id="基础要求-1"><a href="#基础要求-1" class="headerlink" title="基础要求"></a>基础要求</h5><p>自主完成小程序页面的设计，美观、简洁，且要求符合主题，各元素设置符合<strong>个人博客</strong>的要求。小程序组件功能齐全，可在本地调试环境流畅、正常运行。</p>
<h5 id="提高部分-1"><a href="#提高部分-1" class="headerlink" title="提高部分"></a>提高部分</h5><p>在完成基础要求的前提下，可以选择实现以下功能：</p>
<ol>
<li>完成一篇自己的博客并展示在首页上，并且可以通过主页转跳到对应博客</li>
<li>完成个人签名的编辑与保存功能</li>
<li>完成点赞数、浏览数等的统计功能</li>
<li>实现前后端分离设计</li>
</ol>
<h4 id="个人网站"><a href="#个人网站" class="headerlink" title="个人网站"></a>个人网站</h4><p>利用<span class="exturl" data-url="aHR0cHM6Ly9jbi52dWVqcy5vcmcv">Vue<i class="fa fa-external-link-alt"></i></span>或<span class="exturl" data-url="aHR0cHM6Ly9yZWFjdC5kb2NzY2hpbmEub3JnLw==">React<i class="fa fa-external-link-alt"></i></span>等流行前端框架完成主题为<strong>个人博客</strong>的网站。</p>
<h5 id="基础要求-2"><a href="#基础要求-2" class="headerlink" title="基础要求"></a>基础要求</h5><p>自主完成网页页面的设计，美观、简洁，且要求符合主题，各元素设置符合<strong>个人博客</strong>的要求。网页元素功能齐全，可在本地环境流畅、正常运行。</p>
<h5 id="提高部分-2"><a href="#提高部分-2" class="headerlink" title="提高部分"></a>提高部分</h5><p>与微信小程序提高部分相同。</p>
<h2 id="图片资源"><a href="#图片资源" class="headerlink" title="图片资源"></a>图片资源</h2><p>提高题所需要的图片资源请前往<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2plcnJ5NzY1L3JlY3J1aXRtZW50LWltYWdlcy5naXQ=">github<i class="fa fa-external-link-alt"></i></span>下载，如不能访问请使用<strong>科学上网</strong>方式。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308021036634.png"><br>其余题目所有图片素材自行寻找即可，不做统一规定。</p>
<p>可能用上的素材及工具网站：<br><span class="exturl" data-url="aHR0cHM6Ly93d3cucGV4ZWxzLmNvbS96aC1jbi8=">Pexels<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWNvbmZvbnQuY24v">阿里巴巴矢量图<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWxvdmVpbWcuY29tL3poLWNuL2Nyb3AtaW1hZ2U=">iLoveIMG免费图片裁剪<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="仍有疑问？"><a href="#仍有疑问？" class="headerlink" title="仍有疑问？"></a>仍有疑问？</h2><p>请通过本网站的评论系统（科学上网）提出，后续统一更新在本博客中。保持关注！</p>
]]></content>
      <categories>
        <category>recruitment</category>
      </categories>
      <tags>
        <tag>university</tag>
        <tag>csu</tag>
        <tag>software engineering</tag>
        <tag>frontend</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试复习</title>
    <url>/2024/01/10/software-test-review/</url>
    <content><![CDATA[<h1 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h1><h2 id="第一章-概述及基础"><a href="#第一章-概述及基础" class="headerlink" title="第一章 概述及基础"></a>第一章 概述及基础</h2><h3 id="对软件测试的理解"><a href="#对软件测试的理解" class="headerlink" title="对软件测试的理解"></a>对软件测试的理解</h3><ul>
<li><p>正向思维：以功能验证为导向，证明软件是正确的</p>
</li>
<li><p>逆向思维：以破坏性检测为导向，为了找到软件中的错误（<strong>发现错误</strong>）</p>
</li>
<li><p>软件 &#x3D; 程序 + 文档</p>
</li>
<li><p>软件测试 ≠ 程序测试</p>
</li>
</ul>
<p><strong>软件测试标准定义</strong>：</p>
<ul>
<li>使用人工或自动手段，来运行或测试某个系统的过程。其目的在于检验它是否满足规定的需求或弄清预期结果与实际结果之间的差别</li>
<li>软件测试是以检验是否满足需求为目标</li>
</ul>
<span id="more"></span>

<h3 id="对缺陷的理解"><a href="#对缺陷的理解" class="headerlink" title="对缺陷的理解"></a>对缺陷的理解</h3><p>Bug：Bug是软件中（包括程序和文档）不符合用户需求的问题</p>
<ul>
<li><p>完全没有实现的功能</p>
</li>
<li><p>功能或性能问题或差异</p>
</li>
<li><p>多余的功能</p>
</li>
<li><p>差错Error：计算的、观测的、测量的值或条件与真实的、规定的、理论上正确的值或条件之间的差异。</p>
</li>
<li><ul>
<li>可由系统或组件的内部缺陷（fault）引起。</li>
</ul>
</li>
<li><p>失效Failure：由于缺陷而导致要素（element）或相关项(item)预期功能的终止。</p>
</li>
<li><p>缺陷Fault：可引起要素（element）或相关项(item) 失效（fail）的异常情况。</p>
</li>
<li><ul>
<li>当一个子系统处于差错（error）状态时，可能导致系统缺陷（fault）。<br>缺陷（fault）可能导致差错（error），差错（error）可能导致缺陷（fault）。</li>
</ul>
</li>
</ul>
<h3 id="软件质量保证"><a href="#软件质量保证" class="headerlink" title="软件质量保证"></a>软件质量保证</h3><p><strong>软件质量保证（Software Quality Assurance，SQA）</strong>: 为确保软件开发过程和结果符合预期要求而建立的<strong>一系列规程</strong>，以及依照规程和计划采取的<strong>一系列活动及其结果评价</strong>。</p>
<ul>
<li>SQA：管理工作，预防问题，侧重对流程的评审和监控</li>
<li>ST：技术工作，发现问题，侧重对产品进行评估和验证</li>
<li>ST是SQA重要手段之一</li>
<li>充分的测试不能保障软件产品质量，是高质量的必要非充分条件</li>
</ul>
<h3 id="软件测试的基本原则"><a href="#软件测试的基本原则" class="headerlink" title="软件测试的基本原则"></a><em>软件测试的基本原则</em></h3><p><strong>软件测试工程的目标</strong>：尽可能早地找出软件缺陷，确保其得以修复</p>
<ol>
<li>测试应该尽早启动，尽早介入</li>
<li>测试应该追溯需求</li>
<li>不可能进行穷尽测试</li>
<li>Zero Bug与Good Enough</li>
<li>缺陷存在群集现象</li>
<li>缺陷具有免疫性（杀虫剂悖论）</li>
<li>不存在缺陷的理论（测试无法显示潜伏的软件缺陷）</li>
</ol>
<h3 id="软件测试的分类"><a href="#软件测试的分类" class="headerlink" title="软件测试的分类"></a>软件测试的分类</h3><ul>
<li><p>黑盒测试</p>
</li>
<li><ul>
<li>功能测试</li>
</ul>
</li>
<li><ul>
<li>数据驱动测试</li>
</ul>
</li>
<li><p>白盒测试</p>
</li>
<li><ul>
<li>结构测试</li>
</ul>
</li>
<li><ul>
<li>逻辑驱动测试</li>
</ul>
</li>
<li><p>静态测试：不实际运行被测软件，只是静态地检查程序代码、界面或文档中可能存在错误的过程。</p>
</li>
<li><p>动态测试：通过真正运行程序发现错误，通过观察代码运行过程，来获取系统信息，对系统行为进行验证。</p>
</li>
</ul>
<p>不同测试级别的任务：</p>
<ol>
<li>实现（编码）：调试</li>
<li>组件测试：组件功能、健壮性、效率</li>
<li>集成测试：组件之间的接口</li>
<li>系统测试：系统功能、安全性、健壮性、效率</li>
<li>验收测试：功能及用户界面、安全性、效率、用户的可接受性</li>
</ol>
<ul>
<li>系统非功能性测试：系统非功能性测试是将软件放在整个计算机环境下，包括软硬件平台、某些支持软件、数据和人员等，在实际运行环境下进行一系列的测试。包括恢复测试、安全测试、强度测试、性能测试。</li>
<li>系统功能测试：功能测试一般须在完成集成测试后进行，而且是针对应用系统进行测试。功能测试是基于产品功能说明书，是在已知产品所应具有的功能，从用户角度来进行功能验证，以确认每个功能是否都能正常使用。</li>
</ul>
<h3 id="软件测试的过程模型"><a href="#软件测试的过程模型" class="headerlink" title="软件测试的过程模型"></a>软件测试的过程模型</h3><p>软件生命周期（Systems Development Life Cycle, SDLC）：软件开始研制到最终被废弃不用的整个过程。整个生命周期包括问题<strong>定义及规划、需求分析、系统设计、软件编程、软件测试、软件维护等阶段。</strong></p>
<h4 id="V模型"><a href="#V模型" class="headerlink" title="V模型"></a>V模型</h4><p>与软件开发瀑布模型相对应</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401072029581.png"></p>
<p>局限性：测试是设计及编码之后的一个阶段，需求分析阶段隐藏的问题一直到后期的验收测试才被发现</p>
<ul>
<li>验证 (Verification)：Are we building the product right？</li>
<li><ul>
<li>是否正确地构造了软件？即是否正确地做事，验证开发过程是否遵守已定义好的内容。验证产品满足规格设计说明书的一致性</li>
</ul>
</li>
<li>确认（Validation）： Are we building the right product?</li>
<li><ul>
<li>是否构造了正是用户所需要的软件？即是否正在做正确的事。验证产品所实现的功能是否满足用户的需求</li>
</ul>
</li>
</ul>
<h4 id="W模型"><a href="#W模型" class="headerlink" title="W模型"></a>W模型</h4><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401072350659.png"></p>
<ul>
<li>两个V：开发过程&#x2F;测试过程</li>
<li>测试过程：静态测试&#x2F;动态测试</li>
<li>局限性：与V模型一样，软件开发和测试之间保持一种线性的前后关系，需要严格的质量，无法支持代、自发性以及变更调整。对于很多文档事后补充、或者根本没有文档的做法下，令人困惑。</li>
</ul>
<h4 id="H模型"><a href="#H模型" class="headerlink" title="H模型"></a>H模型</h4><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401072352186.png"></p>
<ul>
<li>软件测试是一个独立的流程，贯穿于产品的整个生命周期，与其他流程并发地进行</li>
<li>软件测试原则“尽早准备，尽早执行”</li>
</ul>
<h4 id="X模型"><a href="#X模型" class="headerlink" title="X模型"></a>X模型</h4><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401072353919.jpg"></p>
<ul>
<li>左边描述的是针对单独程序片段所进行的相互分离的编码和测试单独程序片段再进行频繁交接，通过集成最终合成可执行的程序已通过集成测试的成品可以进行封版并提交给用户</li>
<li>探索性测试：未计划的特殊测试</li>
</ul>
<h3 id="实体产品的测试实例——作业"><a href="#实体产品的测试实例——作业" class="headerlink" title="实体产品的测试实例——作业"></a>实体产品的测试实例——作业</h3><p>矿泉水瓶测试实例:</p>
<ol>
<li>外观界面</li>
</ol>
<ul>
<li>视觉检查：检查矿泉水瓶的外观是否有明显缺陷，如裂痕、变色或异物。</li>
<li>标签信息验证：检查生产日期、有效期、容积标记是否清晰、准确。</li>
</ul>
<ol start="2">
<li>功能测试</li>
</ol>
<ul>
<li>泄漏测试：对瓶子进行倒置、侧放、挤压等动作，观察是否有水滴漏出。</li>
<li>容积验证：用已知容积的容器倒入水进行比对，或者使用测量工具测量瓶身尺寸后计算理论容积。</li>
</ul>
<ol start="3">
<li>性能测试</li>
</ol>
<ul>
<li>耐压测试：使用专业设备或方法对瓶子施加压力，记录变形和破裂点。</li>
<li>耐温测试：将瓶子置于不同温度环境中，观察其物理性能和外观变化。</li>
</ul>
<ol start="4">
<li>安全性测试</li>
</ol>
<ul>
<li>材质检测：送检实验室进行有害物质溶出测试。</li>
<li>边缘处理测试：用手指沿瓶口、瓶盖边缘滑动，感受是否有刮手感。</li>
</ul>
<ol start="5">
<li>易用性测试</li>
</ol>
<ul>
<li>开启闭合测试：多次开启和关闭瓶盖，检查顺畅度和密封性。</li>
<li>手持感测试：不同用户握持瓶子，收集手感反馈。</li>
</ul>
<ol start="6">
<li>兼容性测试</li>
</ol>
<ul>
<li>条码扫描测试：使用不同品牌和型号的扫描器扫描条码，验证识别率。</li>
<li>环境兼容性测试：将瓶子置于高温、低温、高海拔等环境，检查其物理和功能性能。</li>
</ul>
<h2 id="第二章-基础测试过程"><a href="#第二章-基础测试过程" class="headerlink" title="第二章 基础测试过程"></a>第二章 基础测试过程</h2><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401081908929.png"></p>
<ol start="0">
<li>制定测试的目标和依据</li>
<li>测试需求分析</li>
<li>制定测试计划</li>
<li>设计测试用例、开发测试工具或脚本</li>
<li>执行测试</li>
<li>测试结果分析</li>
<li>提交测试报告</li>
</ol>
<h3 id="测试需求分析（软件需求评审）"><a href="#测试需求分析（软件需求评审）" class="headerlink" title="测试需求分析（软件需求评审）"></a>测试需求分析（软件需求评审）</h3><p>测试进入的准则：</p>
<ul>
<li>清楚了解项目的整体计划<strong>框架</strong></li>
<li><strong>完成需求规格说明书评审</strong></li>
<li><ul>
<li>消除歧义、完善细节、达成共识</li>
</ul>
</li>
<li>技术<strong>知识</strong>或业务知识的储备</li>
<li>标准环境技术设计<strong>文档</strong></li>
<li>足够的<strong>资源</strong></li>
<li><strong>人员</strong>组织结构及其责任已确定</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401081911242.png"></p>
<ul>
<li>产品人员：需求文档</li>
<li>开发人员：概要&#x2F;详细设计文档，编码</li>
<li>测试人员：测试计划、测试用例</li>
</ul>
<p>静态测试包括对软件产品的需求和设计规格说明书的<strong>评审</strong>、对程序代码的<strong>审查</strong>以及<strong>静态分析</strong>等。将需求和设计的评审纳入测试的范畴，可看作是广义测试。</p>
<ul>
<li><strong>代码测试</strong>：测试代码是否符合相应的标准和规范</li>
<li><strong>界面测试</strong>：测试软件的实际界面与需求中的说明是否相符合</li>
<li><strong>文档测试</strong>：测试用户手册和需求说明是否真正符合用户的实际需求</li>
</ul>
<p>评审的形式&#x2F;方法：代码检查与走查、互为评审、会议评审</p>
<p>测试人员参与产品需求分析和系统设计，认真阅读有关文档，真正理解客户的需求和技术上的设计，检查需求说明书对产品描述的准确性、一致性等，检查系统设计的合理性和可测试性等。</p>
<p>需求文档测试原则：</p>
<ul>
<li>完整性：每一项需求都必须将所要实现的功能描述清楚，以使开发人员获得设计和实现这些功能所需的所有必要信息。</li>
<li>正确性</li>
<li>一致性</li>
<li>可行性</li>
<li>无二义性</li>
<li>健壮性：需求的说明中是否对可能出现的异常进行了分析，并且对这些异常进行了容错处理。</li>
<li>必要性：“必要性”可以理解为每项需求都是用来授权编写文档的“根源”。要使每项需求都能回溯至某项客户的输入，如Use Case或别的来源。</li>
<li>可测试性：每一项需求都必须将所要实现的功能描述清楚，以使开发人员获得设计和实现这些功能所需的所有必要信息。</li>
<li>可修改性：每一项需求都必须准确地陈述其要开发的功能。</li>
<li>可跟踪性：应能在每项软件需求与它的根源和设计元素、源代码、测试用例之间建立起链接链，这种可跟踪性要求每项需求以一种结构化的，粒度好 (fine-grained)的方式编写并单独标明，而不是大段大段的叙述。</li>
</ul>
<p>测试需求分析是测试设计和开发测试用例的基础：</p>
<ul>
<li>确定测试范围</li>
<li>测试项和测试子项</li>
<li>测试优先级</li>
<li>测试风险</li>
</ul>
<ol>
<li>测试需求主要解决“测什么”的问题，应全部覆盖已定义的业务流程</li>
<li>软件测试需求是设计测试用例的依据，有助于保证测试的质量和进度，是衡量测试覆盖率的重要指标</li>
<li>测试需求分析的主要目的：依据需求文档<strong>提取测试点</strong>，根据测试点来编写测试用例<ul>
<li><strong>单独功能测试</strong>：通过分析需求描述中的输入、输出、处理、限制、约束等，给出对应的验证内容</li>
<li><strong>功能交互测试</strong>：通过分析各个功能模块之间的业务顺序，和各个功能模块之间传递的信息和数据，对存在功能交互的功能项，给出对应的验证内容</li>
<li><strong>界面、易用性、安全性、性能压力</strong></li>
</ul>
</li>
</ol>
<p>测试需求分析项：</p>
<ul>
<li>项目背景</li>
<li><strong>业务（流程、用户角色）</strong>：观察、分析用户的心理、行为和预期</li>
<li><strong>用例、场景</strong></li>
<li>支撑业务的功能</li>
<li>功能优先级</li>
<li>非功能特性：性能需求（清楚而量化），充分的安全性测试、容错性测试和负载测试</li>
</ul>
<p>软件需求的层次：</p>
<ul>
<li><strong>业务需求</strong>反映组织机构或客户对系统、产品的概括性要求，包括所要达到的业务目标，由项目视图与范围文档说明</li>
<li><strong>用户角色需求</strong>描述用户使用系统而要完成的各种任务，由用例（use case）文档或方案脚本说明。<strong>用户角色需求可以扩展到涉众（干系人）需求</strong></li>
<li><strong>功能需求</strong>定义开发人员必须实现的软件功能，它源于用户需求，是软件需求说明书中重要的组成部分</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401081927727.png"></p>
<p><strong>编写测试用例</strong>：</p>
<ul>
<li>测试用例编号：Input_001</li>
<li>测试优先级：中</li>
<li>测试目的：验证业务单据数据的查询正确性</li>
<li>标题：业务单据查询</li>
<li>步骤：<ol>
<li>打开查询界面</li>
<li>输入查询条件</li>
<li>确定并提交查询</li>
<li>查看并验证返回的信息</li>
</ol>
</li>
</ul>
<h3 id="测试计划"><a href="#测试计划" class="headerlink" title="测试计划"></a>测试计划</h3><p>软件测试计划的重点工作：</p>
<ul>
<li>明确测试目标</li>
<li>分析与确定测试范围</li>
<li>识别测试项及其优先级<ul>
<li>以上为测试需求分析阶段</li>
</ul>
</li>
<li>测试阶段出入准则</li>
<li>测试工作量估算</li>
<li>测试资源、进度等安排</li>
<li>识别测试风险，采取相应对策</li>
</ul>
<p>测试目标和准则：确测试目标是测试需求分析和测试计划的前提</p>
<ul>
<li>提供<strong>哪些质量风险</strong>信息</li>
<li>新改动的<strong>业务</strong>是否正确实现，对已有业务是否有负面影响</li>
<li>是否满足<strong>功能性要求和非功能性要求</strong></li>
<li>在测试<strong>覆盖率</strong>、测试<strong>效率</strong>上的具体要求</li>
</ul>
<p>测试资源安排：</p>
<ul>
<li>人力资源、系统资源（硬件和软件资源）以及环境资源</li>
<li>由于每个人的思维存在局限性，每项测试最后安排不少于2个人测试，以便交叉测试</li>
</ul>
<p>测试计划内容：软件测试计划是指导测试过程的纲领性文件，描述测试活动的范围、方法、策略、资源、任务安排和进度等，并确定测试项、哪些功能特性将被测试、哪些功能特性将无需测试，识别测试过程中的风险。</p>
<p>测试范围：</p>
<ul>
<li>新功能</li>
<li>升级测试（兼容性）</li>
<li>已解决的故障再次验证</li>
<li>基本功能（加入新功能之后）</li>
<li>可靠性、性能是否达标</li>
<li>文档的测试验证</li>
</ul>
<p>软件测试<strong>每个阶段</strong>需要控制进入&#x2F;退出标准以保障测试的质量</p>
<ul>
<li>进入准则：对软件测试切入点的确立，即满足什么条件，才启动测试</li>
<li>退出标准：满足某个阶段结束&#x2F;里程碑达到的事先定义的要求</li>
</ul>
<p>测试工作量是根据测试范围、策划任务和开发阶段来确定的，测试范围和测试任务是测试工作量估算的主要依据。<br>测试工作量的估算依赖于测试任务的细化，对每项测试任务进行分解，然后根据分解的子任务进行估算。通常分解粒度越小，估算精度越高。</p>
<p>软件测试总是存在较高的风险，测试风险管理就是设法降低或缓解测试过程中的风险</p>
<ul>
<li>项目计划变更、测试资源不能到位可能产生风险</li>
<li>实际操作时的建议：建立后备机制，让后备测试人员参与项目例会，评审，培训，交流等活动</li>
</ul>
<p>测试计划是一个过程</p>
<ul>
<li>确认测试目标、范围和需求</li>
<li>识别测试风险，制订相应的测试策略</li>
<li>对测试任务和工作量进行估算</li>
<li>确定所需的时间和资源</li>
<li><strong>进度安排和资源分派，包括团队角色、责任和培训</strong></li>
<li>测试阶段划分，包括阶段性任务和成果</li>
<li><strong>计划评审与批准</strong></li>
<li>跟踪和控制机制</li>
</ul>
<h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><p>测试用例：</p>
<ul>
<li>定义：在测试执行之前设计的一套详细的测试方案，包括测试环境、测试步骤、测试数据和预期结果。</li>
<li><ul>
<li>测试用例&#x3D;输入（测试步骤和操作步骤）+输出（期望结果）+ <strong>测试环境</strong>（系统环境设置）</li>
</ul>
</li>
<li>时机：通常在测试设计阶段来写，即在《需求规格说明书》和《测试计划》都已完成之后。</li>
<li>唯一标准：用户的需求，具体参考资料就是《系统需求规格规格说明书》和软件原型。</li>
<li>作用：在已知软件产品功能的基础上：</li>
<li><ul>
<li>便于团队交流</li>
</ul>
</li>
<li><ul>
<li>便于重复测试</li>
</ul>
</li>
<li><ul>
<li>便于跟踪统计</li>
</ul>
</li>
<li><ul>
<li>便于用户自测</li>
</ul>
</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401081939134.png"></p>
<p>现代黑盒测试是从一种从软件外部对软件实施的测试，也称<strong>基于规格说明</strong>的测试。</p>
<ul>
<li>任何程序都可以看作是<strong>从输入定义域到输出值域的映射</strong>，将被测程序看作一个打不开的黑盒，黑盒里面的内容(实现)是完全不知道的，只知道<strong>软件要做什么</strong>。</li>
</ul>
<p>黑盒测试是从用户观点出发的测试，其目的是尽可能发现软件的<strong>外部</strong>行为错误。<br>在已知软件产品功能的基础上，</p>
<ul>
<li>检测软件功能能否按照需求规格说明书的规定正常工作，是否有功能遗漏；</li>
<li>检测是否有人机交互错误，是否有数据结构和外部数据库访问错误，是否能恰当地接收数据并保持外部信息（如数据库或文件）等的完整性；</li>
<li>检测行为、性能等特性是否满足要求等；</li>
<li>检测程序初始化和终止方面的错误等。</li>
</ul>
<p>显著优点：</p>
<ul>
<li>黑盒测试与软件具体实现无关，所以如果软件实现发生了变化，测试用例仍然可以使用；</li>
<li>设计黑盒测试用例可以和软件实现同时进行，因此可以压缩项目总的开发时间。</li>
</ul>
<p>黑盒测试用例设计方法：</p>
<ul>
<li>等价类划分法</li>
<li>边界值分析法</li>
<li>因果图法</li>
<li>判定表法</li>
<li>正交分解法</li>
<li>基本路径分析法</li>
<li>场景设计法</li>
<li>错误推测法</li>
</ul>
<h4 id="等价类划分法"><a href="#等价类划分法" class="headerlink" title="等价类划分法"></a>等价类划分法</h4><p>定义：</p>
<ul>
<li><p>等价类划分法是一种典型的黑盒测试方法，它完全不考虑程序的内部结构，只根据程序规格说明书对输入范围进行划分。</p>
</li>
<li><p>把所有可能的输入数据，即程序输入域划分为若干个互不相交的子集，称为<strong>等价类</strong>，然后从每个等价类中选取少数具有代表性的数据作为测试用例，进行测试</p>
</li>
<li><p>在分析需求规格说明的基础上划分等价类，列出<strong>等价类表</strong>。</p>
</li>
<li><p>等价类是某个输入域的子集，在<strong>该子集中每个输入数据的作用是等效的</strong>。</p>
</li>
<li><p>分为<strong>有效等价类</strong>和<strong>无效等价类</strong></p>
</li>
<li><ul>
<li>对于程序的规格说明来说是合理的、有意义的输入数据构成的集合。利用有效等价类可以检验程序是否实现了规格说明中所规定的功能和性能。</li>
</ul>
</li>
<li><ul>
<li>反之为无效等价类</li>
</ul>
</li>
<li><ul>
<li>设计测试用例时，要同时考虑这两种等价类。因为软件不仅要能接收合理的数据，也要能经受异常数据的考验。经过正反的测试才能确保软件具有更高的可靠性。</li>
</ul>
</li>
</ul>
<p>确定等价类的原则：</p>
<ol>
<li>输入条件规定了<strong>取值范围</strong>或<strong>值的个数</strong>的情况下，则可以确立一个有效等价类和两个无效等价类。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401081944247.png"></li>
<li>在输入条件规定了输入值的集合或者规定了“必须如何”的条件的情况下，可以确立一个有效等价<br>类和一个无效等价类。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401081946137.png"></li>
<li>在输入条件是一个布尔量的情况下，可确定一个有效等价类和一个无效等价类。</li>
<li>在规定了输入数据的一组值(假定n个)，并且程序要对每一个输入值分别处理的情况下，可确立n个有效等价类和一个无效等价类。（<strong>多输入的或关系</strong>）</li>
<li>在规定了输入数据必须遵守的规则的情况下，可确立一个有效等价类(符合规则)和若干个无效等价类(从不同角度违反规则)。（<strong>多输入的且关系</strong>）</li>
<li>在确知已划分的等价类中，各元素在程序处理中的方式不同的情况下，则应再将该等价类进一步地划分为更小的等价类。（<strong>细分等价类</strong>）</li>
</ol>
<p>根据等价类创建测试用例的步骤</p>
<ol>
<li>建立等价类表，列出所有划分出的等价类<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401081949839.png"></li>
<li>为每个等价类规定一个唯一的编号</li>
<li>设计一个新的测试用例，使其<strong>尽可能多地</strong>覆盖<strong>尚未覆盖的有效等价类</strong></li>
<li>重复3，最后使得所有有效等价类均被测试用例所覆盖</li>
<li>设计一个新的测试用例，使其<strong>只覆盖一个无效等价类</strong></li>
<li>重复5使所有无效等价类均被覆盖。</li>
</ol>
<p>规格说明往往<strong>没有定义无效测试用例的期望输出</strong>应该是什么样的。因此，测试人员需要花费大量时间来定义这些测试用例的期望输出。</p>
<ul>
<li>边界值和等价类<strong>密切相关</strong>，输入等价类和输出等价类的边界是要着重测试的边界情况。在等价类的划分过程中就产生了许多等价类边界。边界是最容易出错的地方，所以，从等价类中选取测试数据时应该关注边界值。</li>
<li>在等价类划分基础上进行边界值分析测试的<strong>基本思想</strong>是，选取正好等于、刚刚大于或刚刚小于等价类边界的值作为测试数据，而不是选取等价类中的典型值或任意值做为测试数据。</li>
</ul>
<h4 id="边界值分析法"><a href="#边界值分析法" class="headerlink" title="边界值分析法"></a>边界值分析法</h4><p>大量的软件测试实践表明，故障往往出现在定义域或值域的边界上，而不是在其内部。为检测边界附近的处理专门设计测试用例，通常都会取得很好的测试效果。</p>
<ul>
<li>边界值分析法是一种很实用的黑盒测试用例方法，它具有很强的发现故障的能力。</li>
<li>很多错误发生在<strong>输入或输出范围的边界</strong>上，因此针对各种边界情况设置测试用例，可以更有效地发现缺陷。</li>
<li>边界条件就是软件计划的操作界限所在的边缘条件。</li>
</ul>
<p>边界是指相当于输入等价类和输出等价类而言，稍高于边界值及稍低于其边界值的一些特定情况。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 任意的正常值: 随机选择几个选项</span><br><span class="line"><span class="bullet">-</span> 边界值: 选择所有选项</span><br><span class="line"><span class="bullet">-</span> 边界值: 一个都不选</span><br><span class="line"><span class="bullet">-</span> 边界值: 选择一个选项</span><br></pre></td></tr></table></figure>

<p>次边界条件：</p>
<ul>
<li>普通边界条件最容易找到，在产品说明书中有定义，或者在使用软件的过程中确定。</li>
<li>有些边界在软件的内部，最终用户几乎看不到，但是软件测试仍有必要检查。这种边界条件称为<strong>次边界条件</strong>或者<strong>内部边界条件</strong>。</li>
</ul>
<p>确定边界值的原则：</p>
<ol>
<li>如果输入条件规定了<strong>值的范围</strong>，则应取刚达到这个范围的边界的值，以及刚刚超越这个范围边界的值作为测试输入数据。</li>
<li>如果输入条件规定了<strong>值的个数</strong>，则用最大个数、最小个数、比最小个数少、比最大个数多1的数作为测试数据。</li>
<li>很多如果程序的规格说明给出的<strong>输入域或输出域是有序集合</strong>，则应选取集合的第一个元素和最后一个元素作为测试用例。</li>
<li>如果程序中使用了一个<strong>内部数据结构</strong>，则应当选择这个内部数据结构的边界上的值作为测试用例。</li>
</ol>
<ul>
<li>加法器边界测试用例（等价类）<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401081957992.png"></li>
<li>加法器边界测试用例（边界值）<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401081958934.png"></li>
</ul>
<p>健壮性边界测试：变量除了取min，min＋，nom，max－，max五个边界值外，还要考虑采用一个略超过最大值（max+）以及一个略小于最小值 (min-) 的取值。健壮性测试最有意义的部分不是输入，而是预期的输出，观察例外情况如何处理。</p>
<ul>
<li>对于一个n变量的程序，边界值分析测试会产生4n+1个测试用例。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092132168.png"></li>
<li>对于一个n变量的程序，健壮性边界值测试将产生6n+1个测试用例<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092133878.png"></li>
</ul>
<h4 id="等价类、边界值分析法习题"><a href="#等价类、边界值分析法习题" class="headerlink" title="等价类、边界值分析法习题"></a>等价类、边界值分析法习题</h4><p>【例】某商店的货品价格（P）都不大于20元（且为整数），假设顾客每次付款为20元且每次限购一件商品，现有一个软件能在每位顾客购物后给出找零钱的最佳组合（找给顾客货币张数最少）。<br>假定此商店的找零货币面值只包括：10元（N10）、5元（N5）、1元（N1）3种。请采用等价类划分法为该软件设计测试用例（不考虑P 为非整数的情况）并填入到下表中。（&lt;&lt;N1,2&gt;&gt;表示2 张1 元，若无输出或输出非法，则填入N&#x2F;A）</p>
<p>答案：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>输入（商品价格P）</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>20（P&#x3D;20）</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>2</td>
<td>18（任意15&lt;P&lt;20）</td>
<td>&lt;&lt;N1, 2&gt;&gt;</td>
</tr>
<tr>
<td>3</td>
<td>15（P&#x3D;15）</td>
<td>&lt;&lt;N5, 1&gt;&gt;</td>
</tr>
<tr>
<td>4</td>
<td>10（P&#x3D;10）</td>
<td>&lt;&lt;N10, 1&gt;&gt;</td>
</tr>
<tr>
<td>5</td>
<td>5（P&#x3D;5）</td>
<td>&lt;&lt;N5, 3&gt;&gt;</td>
</tr>
<tr>
<td>6</td>
<td>1（P&#x3D;1）</td>
<td>&lt;&lt;N1, 19&gt;&gt;</td>
</tr>
<tr>
<td>7</td>
<td>0（P&#x3D;0）</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>8</td>
<td>19（任意15&lt;P&lt;20）</td>
<td>&lt;&lt;N1, 1&gt;&gt;</td>
</tr>
<tr>
<td>9</td>
<td>14（任意10&lt;P&lt;15）</td>
<td>&lt;&lt;N5, 1&gt;, &lt;N1, 1&gt;&gt;</td>
</tr>
<tr>
<td>10</td>
<td>9（任意5&lt;P&lt;10）</td>
<td>&lt;&lt;N10, 1&gt;, &lt;N1, 1&gt;&gt;</td>
</tr>
<tr>
<td>11</td>
<td>4（任意0&lt;P&lt;5）</td>
<td>&lt;&lt;N5, 1&gt;, &lt;N1, 16&gt;&gt;</td>
</tr>
</tbody></table>
<h4 id="判定表-x2F-决策表方法"><a href="#判定表-x2F-决策表方法" class="headerlink" title="判定表&#x2F;决策表方法"></a>判定表&#x2F;决策表方法</h4><p>判定表是把作为条件的所有输入的<strong>各种组合值</strong>以及对应输出值都罗列出来而形成的表格。</p>
<ul>
<li>条件桩：列出问题的所有条件。通常认为列出的条件的次序无关紧要。</li>
<li>条件项：针对所列条件的具体取值，在所有可能情况下的真假值。</li>
<li>动作桩：列出可能针对问题所采取的操作。这些操作的排列顺序没有约束。</li>
<li>动作项：列出在条件项（各种取值）组合情况下应该采取的动作。<br><em>在所有的黑盒测试方法中，基于判定表的测试是最严格，最具有逻辑性的测试方法。</em></li>
</ul>
<p>适合使用判定表设计测试用例的条件：</p>
<ul>
<li>规则说明以判定表的形式给出，或很容易转换成判定表</li>
<li><strong>条件的顺序无关</strong>：条件（C）的排列顺序不影响执行哪些操作（A）</li>
<li><strong>操作&#x2F;活动的顺序无关</strong>：如果某一规则要执行多个操作，这些操作的执行顺序无关紧要</li>
<li><strong>规则之间的无关联</strong>：规则（R）的排列顺序不影响执行哪些操作；当某一条规则（R）的条件（C）已经满足，并确定要执行的操作（A）后，不必检验别的规则</li>
</ul>
<p>步骤：</p>
<ol>
<li>列出条件桩</li>
<li>列出动作桩</li>
<li>填入条件项及其组合</li>
<li>填入动作项，制定初始判定表</li>
<li>简化、合并相似规则或者相同动作</li>
</ol>
<p>示例：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092144500.png"></p>
<h4 id="因果图法"><a href="#因果图法" class="headerlink" title="因果图法"></a>因果图法</h4><p><strong>组合之间有关系</strong>：多种输入条件的组合，输入之间有关系，例如，约束关系、组合关系，需要进行因果分析，不可直接采用判定表方法。因果图不擅长处理较大的规格说明。</p>
<p>因果图基本符号：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092147335.png"></p>
<p>步骤：</p>
<ol>
<li>分析软件规格说明文档描述的哪些是原因（输入条件），哪些是结果（输出条件）。原因常是输入条件或输入条件的等价类，结果是输出条件；</li>
<li>分析程序规格说明的描述中的语义内容，将其表示成连接各个原因与各个结果的“因果图”；</li>
<li>标明约束条件。在因果图上标上哪些<strong>不可能发生的因果关系</strong>，表明约束或限制条件；</li>
<li>根据因果图，创建判定表，将复杂的逻辑关系和多种条件组合很具体明确的表示出来；</li>
<li>把判定表的每一列作为依据设计测试用例。</li>
</ol>
<p>示例：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092151022.png"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092152692.png"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092153239.png"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092153957.png"></p>
<p>建立有限项的判定表：跟踪图中的状态变化情况，将因果图转换成一个有限项的判定表。表中的每一列代表一个测试用例。</p>
<ul>
<li>选择一个果作为当前状态</li>
<li><strong>对因果图进行回溯，查找导致该果为1的所有因的组合</strong></li>
<li>在判定表中为每个因的组合生成一列</li>
<li>对于每种“因”的组合，判断所有其他“果”的状态，并放置在每一列中。</li>
</ul>
<p>回溯：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092157031.png"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092157818.png"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092158817.png"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092158927.png"></p>
<ul>
<li>因果图没有考虑边界条件。测试用例将边界条件一并考虑；</li>
<li>难点在将因果图转化为判定表，有相关的算法实现及商业软件。</li>
</ul>
<h4 id="两两组合测试"><a href="#两两组合测试" class="headerlink" title="两两组合测试"></a>两两组合测试</h4><ul>
<li>假如一个软件系统由N个构件组成（或者说由N个因素决定），大部分的软件错误是由一个构件的错误所导致，或者由2个构件之间的交互错误导致。</li>
<li><strong>大部分缺陷是在两个变量取值冲突的测试时被发现的</strong></li>
<li>构造测试用例需要涵盖每个因素的所有状态，并且涵盖每2个因素之间的所有交互。</li>
<li>不仅仅是在所有的组合情况下才会发现所有的测试缺陷</li>
<li>没有必要构造覆盖所有因素的所有组合的测试用例集合，<strong>只需要构造覆盖每个因素的所有状态，覆盖任意2个因素所有状态的测试用例集合。</strong></li>
</ul>
<h5 id="正交试验法（Orthogonal-Test-Design-Method-OTDM）"><a href="#正交试验法（Orthogonal-Test-Design-Method-OTDM）" class="headerlink" title="正交试验法（Orthogonal Test Design Method, OTDM）"></a>正交试验法（Orthogonal Test Design Method, OTDM）</h5><p>正交表法（Orthogonal Array Testing Strategy, OATS ）：正交表的两大优越性，即“均匀分散，整齐可比”。特性中有任意一条不满足，就不是正交表。</p>
<ul>
<li>每列中不同数字出现的次数相等</li>
<li>任意两列，其横向组成的数字对，每种数字对出现的次数相等</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092206485.png"></p>
<ul>
<li>m: 因子</li>
<li>n : 水平 </li>
<li>试验次数 ：m*(n-1)+1</li>
<li>eg: 4*（3-1）+1&#x3D;9<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092208902.png"></li>
</ul>
<h5 id="正交表法练习"><a href="#正交表法练习" class="headerlink" title="正交表法练习"></a>正交表法练习</h5><p>【例】考察5个3水平因子、以及一个2水平因子，选择合适的正交表。</p>
<p>考察5个3水平因子和一个2水平因子时，选择合适的正交表需要考虑因子的水平数和实验的总次数。正交表通常用符号“L[实验次数]([水平数]^[因子数])”来表示。</p>
<p>在您的案例中，有5个因子各有3个水平，一个因子有2个水平。首先，我们需要一个能容纳3水平因子的正交表。由于最高水平数是3，我们选择以3为基础的正交表。接下来，需要考虑总的实验次数，它应该足够容纳所有因子的组合。</p>
<!-- TODO：计算 -->

<h5 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h5><ul>
<li>在因子水平数比较少的情况下，采用配对测试方法。因为测试组合数更加全面一些，当然在某些因子水平数时，两者最后筛选出的结果可能是一致的。</li>
<li>在因子水平数比较多的情况下，采用正交表测试，因为可以得到更加精炼的测试组合，从而使测试效率得到提升</li>
</ul>
<h5 id="组合分析方法作业"><a href="#组合分析方法作业" class="headerlink" title="组合分析方法作业"></a>组合分析方法作业</h5><p>某一在线购物网站，有多种条件影响操作界面或操作功能，主要有以下几个方面：</p>
<ul>
<li>登录方式（LOGIN）：未登录、第一次登录、正常登录；</li>
<li>会员状态（MEMBERSHIP）：非会员、会员、VIP、雇员；</li>
<li>折扣（DISCOUNT）：没有、假日95折、会员9折、VIP会员8折</li>
<li>物流方式（SHIP）：标准、快递、加急。<br>设计测试组合。可以考虑增加一些约束条件，进一步优化或减少组合。<br>IF [LOGIN]&#x3D;’未登录’ THEN [MEMBERSHIP]&#x3D;’非会员’<br>IF [LOGIN]&#x3D;’第一次登录’ THEN [MEMBERSHIP]&lt;&gt;’ VIP会员’<br>IF [MEMBERSHIP]&#x3D;’会员’ THEN [DISCOUNT]&#x3D;’会员9折’<br>IF [MEMBERSHIP]&#x3D;’VIP会员’ THEN [DISCOUNT]&#x3D;’会员8折’<br>采用微软PICT和正交表构造法生成测试用例，比较两种方法的结果。</li>
</ul>
<!-- TODO：做 -->

<h4 id="功能图法"><a href="#功能图法" class="headerlink" title="功能图法"></a>功能图法</h4><ul>
<li><p>每个程序的功能通常由静态说明和<strong>动态说明</strong>组成</p>
</li>
<li><p>静态说明描述了输入条件和输出条件之间的对应关系</p>
</li>
<li><p>动态说明描述了输入数据的次序或者转移的次序</p>
</li>
<li><p>功能图法就是为了解决动态说明问题的一种测试用例的设计方法</p>
</li>
<li><p>功能图由状态迁移图（state transition diagram，STD）和逻辑功能模型（logic function model，LFM）构成</p>
</li>
<li><p>状态迁移图</p>
</li>
<li><ul>
<li>表示<strong>输入数据序列</strong>以及相应的输出数据。</li>
</ul>
</li>
<li><ul>
<li>由状态和迁移来描述，状态指出数据输入的位置（或时间），而迁移则指明状态的改变。</li>
</ul>
</li>
<li><ul>
<li>在STD中，输入数据和当前状态决定输出数据和后续状态。</li>
</ul>
</li>
<li><p>状态逻辑功能模型</p>
</li>
<li><ul>
<li>表示状态中输入条件和输出条件之间的对应关系。逻辑功能模型只适合于描述静态说明，输出数据仅由输入数据决定。</li>
</ul>
</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092229092.png"></p>
<p>功能图生成测试用例的过程：</p>
<ul>
<li>测试用例是由测试中经过的一系列状态和在每个状态中必须依靠输入&#x2F;输出数据满足的一对条件组成。</li>
<li><strong>生成局部测试用例</strong>：在每个状态中，从因果图生成局部测试用例。局部测试库由原因值（输入数据）组合与对应的结果值（输出数据或状态）构成</li>
<li><strong>测试路径生成</strong>：利用上面的规则生成从初始状态到最后状态的测试路径；</li>
<li><strong>测试用例合成</strong>：合成测试路径与功能图中每个状态的局部测试用例。结果是初状态到最后一个状态的一个状态序列，以及每个状态中输入数据与对应输出数据组合。</li>
</ul>
<h4 id="场景设计法"><a href="#场景设计法" class="headerlink" title="场景设计法"></a>场景设计法</h4><p>黑盒测试中重要的测试用例设计方法。目前，多数软件系统都是用事件触发来控制业务流程，事件触发时的情景便形成了场景，场景的不同触发顺序构成了用例。同一事件的不同触发顺序和处理结果就形成<strong>事件流</strong>。</p>
<ul>
<li>基本流（基本流程）</li>
<li>备选流（分支流程）</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092232801.png"></p>
<ul>
<li>采用矩阵或决策表来确定和管理测试用例</li>
<li>确定执行用例场景所需要的数据元素，构建矩阵</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092234681.png"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092233282.png"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092234150.png"></p>
<ul>
<li>根椐UML覆盖系统用例中的主场景和扩展场景，并且适当补充各种<strong>正、反面的测试用例</strong>和考虑出现的异常情形</li>
<li>测试人员要充分发挥对用户实际业务场景的想象</li>
<li>关心用户做什么，而不是关心产品做什么</li>
<li>优点：实用性强，有效，设计出来的用例有价值</li>
<li>缺点：可能使用的场景不一定能对事件系列进行全面的分析，设计出来的用例不完整。</li>
</ul>
<h4 id="场景法例题"><a href="#场景法例题" class="headerlink" title="场景法例题"></a>场景法例题</h4><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401101720632.png"></p>
<h4 id="错误推测法"><a href="#错误推测法" class="headerlink" title="错误推测法"></a>错误推测法</h4><p>错误推测法是测试者根据经验、知识和直觉来发现软件的错误，来推测程序中可能存在的各种错误，从而有针对性地进行测试。例举出程序中所有可能有的错误和容易发生错误的特殊情况，根据它们选择测试用例。</p>
<p>方便实用，特别在软<strong>件测试基础较差</strong>的情况下，是一种有效的测试方法。但不是一个系统的测试方法，只能用作<strong>辅助手段</strong>。没有别的办法可用时用推测法补充一些测试用例。</p>
<ul>
<li>优点：快速切入体会到程序易用与否； </li>
<li>缺点：难以准确知道测试覆盖率。</li>
</ul>
<h4 id="方法比较与选择"><a href="#方法比较与选择" class="headerlink" title="方法比较与选择"></a>方法比较与选择</h4><ul>
<li><p>静态</p>
</li>
<li><ul>
<li>单因素：等价类划分、边界值分析</li>
</ul>
</li>
<li><ul>
<li>多因素：因果分析法、决策表、组合覆盖、正交实验法</li>
</ul>
</li>
<li><p>动态：功能图、场景法</p>
</li>
<li><p>其他：错误推测法</p>
</li>
<li><p>如果变量引用的是物理量，可采用等价类测试和边界值测试。</p>
</li>
<li><p>如果变量引用的是逻辑量，可采用等价类测试用例和决策表测试。</p>
</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>进行<strong>等价类划分</strong>，包括输入条件和输出条件的等价类划分，将无限测试变成有限测试，这是减少工作量和提高测试效率最有效的方法。</li>
<li>在任何情况下都必须使用<strong>边界值分析方法</strong>，经验表明，用这种方法设计出的测试用例<strong>发现错误的能力强</strong>。</li>
<li>如果程序的功能说明中含有输入条件的组合情况，则一开始就可选用<strong>因果图法</strong>和<strong>判定表法</strong>。</li>
<li>对于配置参数类软件，用<strong>正交试验法</strong>选择较好的组合方式达到最佳效果</li>
<li><strong>功能图法</strong>也是很好的测试用例设计方法，可以通过不同时期条件的有效性设计不同的测试数据</li>
<li>对于业务清晰的系统，可以利用<strong>场景法</strong>贯穿整个测试案例过程在案例中综合使用各种测试方法</li>
<li>可以用<strong>错误推测法</strong>追加一些测试用例，这需要依靠测试工程师的智慧和经验</li>
</ul>
<h3 id="测试执行"><a href="#测试执行" class="headerlink" title="测试执行"></a>测试执行</h3><h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><p>Test Case，在测试执行之前设计的一套详细的测试方案，包括测试环境、测试步骤、测试数据和预期结果。<br>测试用例&#x3D;输入（测试步骤和操作步骤）+输出（期望结果）+ <strong>测试环境</strong>（系统环境设置）</p>
<ul>
<li>用例名称</li>
<li>测试路径</li>
<li>前提条件</li>
<li>详细步骤</li>
</ul>
<h4 id="软件缺陷的生命周期"><a href="#软件缺陷的生命周期" class="headerlink" title="软件缺陷的生命周期"></a>软件缺陷的生命周期</h4><p>软件缺陷生命周期指的是一个软件缺陷被发现、报告到这个缺陷被修复、验证直至最后关闭的完整过程<br>发现——打开——修复——关闭</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401101728129.png"></p>
<ul>
<li>激活或打开（Active or Open）：问题还没有解决 ，存在源代码中，确认“提交地缺陷”，等待处理已</li>
<li>修正或修复（Fixed or Resolved）：已被开发人员检查、修复过的缺陷，通过单元测试，认为已解决但还没有被测试人员验证</li>
<li>关闭或非激活（Close or Inactive）：测试人员验证后，确认缺陷不存在之后的状态</li>
<li>重新打开：测试人员验证后，还依然存在的缺陷，等待开发人员进一步修复</li>
<li>推迟：这个软件缺陷可以再下一个版本中解决</li>
<li>保留：由于技术原因或第三种软件的缺陷，开发人员不能修复的缺陷</li>
<li>不能重现：开发不能复现这个软件缺陷，需要测试人员检查缺陷复现的步骤</li>
<li>需要更多信息：开发能复现这个软件缺陷，但开发人员需要一些信息，例如：缺陷的日志文件、图片等</li>
</ul>
<p>完整缺陷描述的重要因素</p>
<ul>
<li>步骤：提供了如何重复当前缺陷的准确描述，应简明而完备、清楚而准确。这些信息对开发人员是关键的，视为修复缺陷的向导</li>
<li>期望结果：与测试用例标准或设计规格说明书或用户需求等一致，达到软件预期的功能。是验证缺陷的依据。</li>
<li>实际结果：实际执行测试的结果，不同于期望结果，从而确认缺陷的存在</li>
</ul>
<p>测试进度管理：</p>
<ul>
<li>S曲线法：法通过对计划中、尝试的与实际的进度三者对比来实现</li>
<li>NOB（Number of Open Bug）：收集当前所有打开的（激活的）缺陷数</li>
</ul>
<h4 id="软件缺陷的处理和跟踪"><a href="#软件缺陷的处理和跟踪" class="headerlink" title="软件缺陷的处理和跟踪"></a>软件缺陷的处理和跟踪</h4><ul>
<li>收集缺陷数据并根据缺陷趋势曲线识别测试处于测试过程中的哪个阶段</li>
<li>通过缺陷趋势曲线来<strong>确定测试过程是否结束</strong>是常用且较为有效的一种方式</li>
</ul>
<ol>
<li>缺陷趋势分析：监控（打开&#x2F;关闭&#x2F;已修正的）缺陷随时间的变化</li>
<li>缺陷分布分析：缺陷数量与缺陷属性的函数。如测试需求和缺陷状态、严重性的分布情况等</li>
<li>缺陷报告：缺陷分布&#x2F;趋势&#x2F;年龄报告、测试结果进度报告</li>
<li>缺陷跟踪方法</li>
</ol>
<h4 id="测试执行-1"><a href="#测试执行-1" class="headerlink" title="测试执行"></a>测试执行</h4><p>实践经验</p>
<ul>
<li>抽查性质的探索式测试，验证高风险区域的测试质量</li>
<li>交叉互换测试人员所测试的模块，可以发挥互补作用</li>
</ul>
<h4 id="测试管理"><a href="#测试管理" class="headerlink" title="测试管理"></a>测试管理</h4><p>缺陷探测率（DDP Defect Detection Percentage）：衡量测试工作效率的软件质量成本的指标<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401101745932.png"></p>
<h2 id="第三章-开发人员测试"><a href="#第三章-开发人员测试" class="headerlink" title="第三章 开发人员测试"></a>第三章 开发人员测试</h2><h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><ul>
<li>黑盒测试：外部逻辑功能错误，界面错误，安装、卸载时的错误，兼容性错误，性能问题</li>
<li>白盒测试</li>
<li><ul>
<li>程序的源代码有多个分支，，尽可能覆盖所有分支，提高测试覆盖率，黑盒无法做到</li>
</ul>
</li>
<li><ul>
<li>代码中的内存泄漏问题，白盒（eg: C&#x2F;C++）可以很快找到黑盒需要长时间运行才能发现的内存泄漏问题</li>
</ul>
</li>
<li><ul>
<li>极端情况出现，(eg:卫星中的电磁辐射等）难以进行功能测试，一般只对源代码进行静态分析</li>
</ul>
</li>
</ul>
<h4 id="程序静态分析（结构分析）"><a href="#程序静态分析（结构分析）" class="headerlink" title="程序静态分析（结构分析）"></a>程序静态分析（结构分析）</h4><p>方法：</p>
<ul>
<li>程序流程分析：控制流分析、数据流分析</li>
<li>符号执行</li>
</ul>
<p>控制流分析（缺陷——影响）：</p>
<ul>
<li>转向并不存在的符号——程序运行意外终止</li>
<li>存在无用的语句标号——占用额外管理资源</li>
<li>存在不可达语句标号——相应功能无法调用</li>
<li>不可能到达停机语句——程序运行难以终止</li>
</ul>
<p>数据流分析：</p>
<ul>
<li>变量被定义，但从未被使用</li>
<li>变量被使用，但从未被定义</li>
<li>变量在使用之前被定义多次</li>
</ul>
<p>符号执行：得到运行特定区域代码的输入</p>
<ul>
<li>检查程序的执行结果是否符合预期</li>
<li>通过符号执行产生程序的执行路径，为进一步自动生成测试数据提供约束条件</li>
</ul>
<p>静态符号执行：</p>
<ul>
<li><strong>以符号值作为输入</strong>，不使用一般程序运行时使用的具体值，通过符号执行模拟代码运行的过程</li>
<li>任何执行点，符号化执行的<strong>程序状态</strong>包括：</li>
<li><ul>
<li>程序变量在该点的符号值</li>
</ul>
</li>
<li><ul>
<li>路径条件的符号值</li>
</ul>
</li>
<li><ul>
<li>一个程序计数器<br>示例：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401101754005.png"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401101755751.png"></li>
</ul>
</li>
</ul>
<p>动态符号执行：传统符号执行技术无法精确求解路径，也无法获得满足路径条件约束的测试用例</p>
<ul>
<li>结合符号输入和具体数据对程序进行分析</li>
<li>遇到复杂路径或大规模路径时使用具体输入值代替符号输入，驱使符号执行继续向后开展，获得可解的约束路径</li>
<li>优于使用具体值代替了部分符号输入，使得路径约束包含的复杂数据结构和表达式简化，减小符号执行代价<br>具体执行：</li>
<li>运行工具跟踪记录符号状态以及当前路径的运行条件</li>
<li>一条路径运行结束后，运行工具将路径中未覆盖分支的最后一个路径条件约束取反，再将新路径条件传递给约束求解器求解</li>
<li>如果约束求解器可以给出一个满足新路径条件的解，运行工具运行该路径重复上述过程</li>
<li>直到所有路径被覆盖，或覆盖特定目标，或满足时间需求<br>示例：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401101758906.png"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401101758399.png"></li>
</ul>
<p>动态白盒测试：<br>利用查看代码（做什么）和实现方法(怎么做)得到的信息来确定哪些需要测试、哪些不要测试、如何开展测试。又称为<strong>结构化测试</strong>(structral testing)<br><em>用尽量少的测试用例完成尽量高的逻辑覆盖。</em></p>
<h4 id="逻辑覆盖测试法"><a href="#逻辑覆盖测试法" class="headerlink" title="逻辑覆盖测试法"></a>逻辑覆盖测试法</h4><p>逻辑覆盖是通过对<strong>程序逻辑结构的遍历</strong>实现程序的覆盖。</p>
<ul>
<li>语句覆盖（SC）：设计若干测试用例，运行被测程序，使程序中的每个可执行语句至少被执行一次。盖能发现一般语句的错误，但不能发现其中的逻辑错误。</li>
<li>判定覆盖（DC）：设计若干用例，运行被测程序，使得程序中<strong>每个判断</strong>的取真分支和取假分支至少经历一次，即判断真假值均曾被满足。较语句覆盖测试强度更高</li>
<li><ul>
<li>满足判定覆盖 -&gt; 满足语句覆盖</li>
</ul>
</li>
<li>条件覆盖（CC）：设计若干测试用例，执行被测程序以后，要使<strong>每个判断</strong>中<strong>每个条件</strong>的可能取值至少满足一次。虽然条件覆盖分析了更小的条件粒度，与分支覆盖相比，并不具有更高测试强度</li>
<li>判定-条件覆盖（CDC）：是<strong>判定和条件覆盖设计方法的交集</strong>，即设计足够的测试用例，使得判断条件中的所有条件可能取值至少执行一次，同时，所有判断的可能结果至少执行一次</li>
<li>条件组合覆盖（MCC）：设计足够的测试用例，使得判断中每个条件的所有可能组合至少出现一次，并且每个判断本身的判定结果也至少出现一次。</li>
<li><ul>
<li>它与条件覆盖的差别是它不是简单地要求每个条件都出现“真”与“假”两种结果，而是要求让这些结果的所有可能组合都至少出现一次。</li>
</ul>
</li>
<li><ul>
<li><em>满足条件组合覆盖，一定满足判定覆盖、条件覆盖、条件判定组合覆盖</em></li>
</ul>
</li>
</ul>
<p>修正条件&#x2F;判定覆盖（MCDC）：</p>
<ul>
<li>每个程序模块的入口和出口至少执行一次</li>
<li>每个判定的所有可能结果至少能取值一次</li>
<li>判定中的每个条件的所有可能结果至少取值一次</li>
<li>一个判定中的每个条件曾经<strong>独立地</strong>对判定的结果产生影响<br>比条件&#x2F;判定覆盖测试强度更高的逻辑覆盖标准，应用更广泛、测试效果更佳的逻辑覆盖标准。</li>
</ul>
<h4 id="白盒测试逻辑覆盖习题"><a href="#白盒测试逻辑覆盖习题" class="headerlink" title="白盒测试逻辑覆盖习题"></a>白盒测试逻辑覆盖习题</h4><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401101958482.png"></p>
<!-- TODO -->

<h4 id="基本路径测试法"><a href="#基本路径测试法" class="headerlink" title="基本路径测试法"></a>基本路径测试法</h4><p>对程序中的可运行路径进行穷举测试是不可行的，只能选择部分可运行路径作为测试目标。<strong>基本</strong>路径覆盖就是以程序控制流图中的<strong>独立路径</strong>作为覆盖目标的测试方法。基本路径测试并不是测试所有路径的组合，仅仅保证每条基本路径被执行一次。</p>
<ol>
<li>依据代码绘制流程图（控制流图）</li>
<li>确定控制流图的圈&#x2F;环复杂度（cyclomatic complexity）</li>
<li>确定线性独立路径的基本集合（basis set）</li>
<li>设计测试用例覆盖每条基本路径</li>
</ol>
<p>如果判断中的条件表达式是复合条件，即条件表达式是由一个或多个逻辑运算符（or, and, nor）连接的<strong>逻辑表达式</strong>，则需要改变复合条件的判断为<strong>一系列只有单个条件的嵌套的判断</strong>。</p>
<p>控制流图：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401102030801.png"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401102030067.png"></p>
<p>圈复杂度（Cyclomatic complexity）: 环复杂度。确定了程序基本路径集合中独立路径条数的上界。复杂度越高，出错的概率越大。</p>
<ul>
<li><p>V(G) &#x3D; 区域数量(由节点、连线包围的区域，包括图形外部区域)</p>
</li>
<li><p>V(G) &#x3D; 简单可预测节点数量 + 1 &#x3D; 判断节点数目 + 1</p>
</li>
<li><p>V(G) &#x3D; 连线数量 - 节点数量 + 2</p>
</li>
<li><ul>
<li>(包括起点和终点；所有终点只计算一次，多个return和throw算作一个节点)</li>
</ul>
</li>
<li><p>独立路径：至少引入一系列新的处理语句或条件的任何路径。程序中的每条语句至少会包含在一个独立路径中，满足独立路径覆盖需求也必定满足语句覆盖需求。</p>
</li>
<li><p>基本集：由独立路径构成的集合。由基本集导出的测试用例，保证每行代码语句至少被执行一次。基本集合<strong>不一定唯一</strong>。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401102034407.png"></p>
</li>
<li><p>逻辑覆盖：以程序或系统的<strong>内部逻辑结构</strong>为基础，分为语句覆盖、判定覆盖、判定-条件覆盖、条件组合覆盖等</p>
</li>
<li><p>基本路径测试：在程序<strong>或业务</strong>控制流程的基础上，分析控制构造的环路复杂性，导出基本可执行路径集合，从而设计测试用例。</p>
</li>
</ul>
<h4 id="循环测试"><a href="#循环测试" class="headerlink" title="循环测试"></a>循环测试</h4><p>目标 : 在循环内部及边界上执行测试</p>
<p>简单循环（迭代次数n）<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401102038813.png"></p>
<p>嵌套（Nested）循环<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401102039001.png"></p>
<p>串行连接的循环<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401102039694.png"></p>
<p>循环化简：有时无法实现路径覆盖。考虑循环化简，限制循环次数。</p>
<ul>
<li>对循环机制进行简化，舍掉一些次要因素，极大地减少路径数量，使得覆盖有限的路径成为可能。</li>
<li>循环化简，即限制循环的次数。无论循环的形式和实际执行循环体的次数多少，只考虑<strong>循环1次和0次</strong>两种情况，即<strong>进入循环和跳过循环</strong>两种情况。</li>
</ul>
<h4 id="测试用例数估算"><a href="#测试用例数估算" class="headerlink" title="测试用例数估算"></a>测试用例数估算</h4><p>为简化问题，避免出现测试用例极多的组合爆炸，把构成循环操作的重复型结构用选择结构代替。即<em>不指望测试循环体所有的重复执行，而是只对循环体检验一次。</em></p>
<ul>
<li>顺序型——构成串行操作</li>
<li>选择型——构成分支操作</li>
<li>重复型——构成循环操作<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401102042346.png"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401102042937.png"></li>
</ul>
<h4 id="白盒测试路径覆盖习题"><a href="#白盒测试路径覆盖习题" class="headerlink" title="白盒测试路径覆盖习题"></a>白盒测试路径覆盖习题</h4><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401102043249.png"></p>
<!-- TODO -->

<h3 id="程序插桩和变异测试"><a href="#程序插桩和变异测试" class="headerlink" title="程序插桩和变异测试"></a>程序插桩和变异测试</h3><p>两类主要的程序修改方法</p>
<ul>
<li>程序插桩: 获得程序执行过程中的内部状态信息</li>
<li>程序变异: 度量测试用例的缺陷检测能力</li>
</ul>
<p>程序插桩原则：用尽可能少的插桩点完成尽量多的信息收集工作。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401102045551.png"></p>
<p>变异程序：一般用与源程序差异极小的简单变体模拟程序中可能存在的各种缺陷。<br>两个重要假设：</p>
<ul>
<li>熟练程序员假设：开发人员编程水平高，编写的代码即使包含缺陷，也仅需微小修改</li>
<li>变异偶尔效应假设：测试用例能够杀死简单变异体，也容易杀死复杂变异体</li>
</ul>
<p>变异体杀死：</p>
<ul>
<li>源程序与变异程序存在运行差异时，测试用例检测到变异程序中缺陷，变异程序被杀死</li>
<li>两个程序不存在运行差异时，测试用例没有检测到变异程序的缺陷，变异程序存活</li>
</ul>
<p>变异算子：</p>
<ul>
<li>模拟典型软件缺陷，度量测试用例对常见缺陷的检测能力</li>
<li>引入特殊值，度量测试用例在特殊环境下的缺陷检测能力</li>
</ul>
<p>面向过程程序的变异算子：</p>
<ul>
<li>运算符变异</li>
<li><ul>
<li>对关系运算符&lt;、&lt;&#x3D;, &gt;, &gt;&#x3D; 进行替换，将&lt; 替换为 &lt;&#x3D;</li>
</ul>
</li>
<li><ul>
<li>对自增运算符++或—运算符进行替换，如将++替换为–</li>
</ul>
</li>
<li><ul>
<li>对与数值运算有关的二元算数运算符进行替换，如将+替换为-</li>
</ul>
</li>
<li><ul>
<li>将程序中的条件运算符替换为相反运算符，如将 &#x3D;&#x3D; 替换为 !&#x3D;</li>
</ul>
</li>
<li>数值变异：对程序中的整数类型、浮点数类型的变量取反数，如将i 替换为 -i</li>
<li>方法返回值变异</li>
<li><ul>
<li>删除程序中返回值类型为void的方法</li>
</ul>
</li>
<li><ul>
<li>对程序中方法的返回值进行修改，如将true修改为false</li>
</ul>
</li>
</ul>
<p>面向对象程序的变异算子：</p>
<ul>
<li>继承变异</li>
<li><ul>
<li>增加或删除子类中的重写变量</li>
</ul>
</li>
<li><ul>
<li>增加、修改或重命名子类中的重写方法</li>
</ul>
</li>
<li><ul>
<li>删除子类中的关键字super，如将return a<em>super.b 修改为return a</em>b</li>
</ul>
</li>
<li>多态变异</li>
<li><ul>
<li>将变量实例化为子类型</li>
</ul>
</li>
<li><ul>
<li>将变量声明、形参类型改为父类型，如将 Integer i 修改为Object I</li>
</ul>
</li>
<li><ul>
<li>赋值时将使用的变量替换为其他可用类型</li>
</ul>
</li>
<li>重载变异</li>
<li><ul>
<li>修改重载方法的内容，或删除重载方法</li>
</ul>
</li>
<li><ul>
<li>修改方法参数的顺序或数量</li>
</ul>
</li>
</ul>
<p>变异程序运行结束后，仍存活，为<strong>等价变异程序</strong>。<br>变异得分 &#x3D; 被杀死的变异程序 &#x2F; （变异程序总数 - 等价变异程序数）</p>
<h4 id="变异测试习题"><a href="#变异测试习题" class="headerlink" title="变异测试习题"></a>变异测试习题</h4><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401102110010.png"></p>
<!-- TODO -->

<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><ul>
<li>定义：单元测试是对软件基本的组成单元进行独立的测试</li>
<li>时机：单元测试和编码是同步进行，但在测试驱动开发（Test driven development, TDD）中，强调测试在先，编码在后</li>
<li>人员：单元测试一般由开发人员完成, QA人员辅助</li>
<li>概念：模块、组件、单元</li>
<li>目标：单元模块被正确编码</li>
<li><ul>
<li>信息正确地流入和流出单元</li>
</ul>
</li>
<li><ul>
<li>在单元工作过程中，其内部数据保持其完整性</li>
</ul>
</li>
<li><ul>
<li>为限制数据加工而设置的边界处正确工作</li>
</ul>
</li>
<li><ul>
<li>单元的运行做到满足特定的逻辑覆盖</li>
</ul>
</li>
<li>任务：</li>
<li><ul>
<li>模块独立执行路径测试</li>
</ul>
</li>
<li><ul>
<li>局部数据结构测试</li>
</ul>
</li>
<li><ul>
<li>模块接口测试</li>
</ul>
</li>
<li><ul>
<li>单元边界条件测试</li>
</ul>
</li>
<li><ul>
<li>单元容错测试&#x2F;错误处理</li>
</ul>
</li>
<li><ul>
<li>表达式与SQL语句</li>
</ul>
</li>
</ul>
<p>单元测试最重要的手段——静态测试：不运行被测试程序，对代码通过检查、阅读进行分析。</p>
<p>运行单元程序有时需要基于被测单元的接口，开发相应的驱动模块和桩模块。</p>
<ul>
<li><p>驱动模块（drive）： 对<strong>底层或子层模块</strong>进行测试所编写的<strong>调用</strong>这些模块的程序</p>
</li>
<li><p>桩模块（stub）：对<strong>顶层或上层模块</strong>进行测试时所编写的<strong>替代下层模块</strong>的程序<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401102116532.png"></p>
</li>
<li><p>传统单元测试：针对程序的函数、过程或完成某一特定功能的程序块。</p>
</li>
<li><p>面向对象软件的单元测试：测试类成员函数。数据成员是否满足数据封装的要求？类是否实现了要求的功能？</p>
</li>
</ul>
<p>父类中已经测试过的成员函数，两种情况需要在子类中重新测试:</p>
<ul>
<li>继承的成员函数在子类中做了改动</li>
<li>成员函数调用了改动过的成员函数的部分</li>
</ul>
<p>对包含多态的成员函数进行测试时，只在原有测试分析和基础上增加对<strong>测试用例中输入数据类型</strong>的考虑</p>
<h3 id="面向对象的单元测试习题"><a href="#面向对象的单元测试习题" class="headerlink" title="面向对象的单元测试习题"></a>面向对象的单元测试习题</h3><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401102121701.png"></p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401102121487.png"></p>
<h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><ul>
<li>定义：根据实际情况将程序模块采用适当的集成测试策略组装起来，对<strong>模块之间的接口以及集成后的功能等</strong>进行正确性检验的测试工作。</li>
<li>时机：确保测试对象所包含的程序模块全部通过单元测试</li>
<li>缺陷类型：接口缺陷、数据丢失、误差放大、规格问题、并发问题</li>
</ul>
<p>组件之间存在显式&#x2F;隐形相依性，需通过结构分析、接口分析、模块分析获取相依性关系。</p>
<p>集成测试模式：</p>
<ul>
<li><strong>非渐增式测试模式</strong>先分别测试每个模块，再把所有模块按设计要求放在一起结合成所要的程序，如大棒模式。</li>
<li><ul>
<li>很难确定出错的真正位置、所在的模块、错误的原因，并不推荐在任何系统中使用，适合在规模较小的应用系统中使用。</li>
</ul>
</li>
<li><ul>
<li><strong>可以并行测试</strong></li>
</ul>
</li>
<li><strong>渐增式测试模式</strong>把下一个要测试的模块同已经测试好的模块结合起来进行测试，测试完以后再把下一个应该测试的模块结合进来测试，如自顶向下和自底向上</li>
<li><ul>
<li>测试更彻底</li>
</ul>
</li>
<li><ul>
<li>需要较多的机器时间</li>
</ul>
</li>
</ul>
<p>自顶向下法（Top-down Integration）步骤：</p>
<ol>
<li>对<strong>主控模块</strong>进行测试，测试时用<strong>桩程序</strong>代替所有直接附属于主控模块的模块</li>
<li>根据<strong>选定的结合策略</strong>（深度优先&#x2F;宽度优先），<strong>每次用一个实际模块代替一个桩程序</strong>（新结合进来的模块往往又需要桩程序）</li>
<li>在结合下一个模块的同时进行测试</li>
<li>为了保证加入模块没有引进新的错误，可能需要进行<strong>回归测试</strong>。</li>
</ol>
<p>自底向上法步骤：</p>
<ol>
<li>把底层模块组合成实现某个特定的软件子功能的族</li>
<li>写一个驱动程序（用于测试的控制程序），协调测试数据的输入和输出</li>
<li>对由模块组成的子功能进行测试</li>
<li>去掉驱动程序，沿软件结构自下向上移动，把子功能族结合起来形成更大的子功能族（Cluster）</li>
</ol>
<p>三明治集成方法(Sandwich Integration)：</p>
<ul>
<li>优点：将自顶向下和自底向上的集成方法有机地结合起来，不需要写桩程序。因为在测试初自底向上集成已经验证了底层模块的正确性。</li>
<li>缺点：在真正集成之前（中层）每一个独立的模块没有完全测试过。</li>
<li>改进的三明治集成方法，不仅自两头向中间集成，而且保证每个模块得到单独的测试，使测试进行得比较彻底 。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401102128113.png"></li>
</ul>
<p>基于调用图的集成：较少所需的驱动模块和测试桩模块，有效地减少集成测试的工作量。<br>构建程序调用图 → 识别各个模块间的程序调用关系<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401102129362.png"></p>
<p>持续集成：通常系统集成都会采用持续集成的策略，软件开发中各个模块不是同时完成，根据进度将完成的模块尽可能早的进行集成，有助于尽早发现Bug，避免集成中大量Bug涌现</p>
<ul>
<li>传统集成测试：自顶向下和自底向上</li>
<li>面向对象软件的集成测试</li>
<li><ul>
<li>没有层次的控制结构</li>
</ul>
</li>
<li><ul>
<li>OO程序相互调用的功能在程序的不同类中，类之间相互依赖紧密</li>
</ul>
</li>
<li><ul>
<li>集成测试在<strong>整个程序编译完成后</strong>进行</li>
</ul>
</li>
<li><ul>
<li><strong>基于使用的测试</strong>：先测试独立类构造系统，完成后测试下一层，测试使用了独立类的类（依赖类）</li>
</ul>
</li>
</ul>
<h3 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h3><h4 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h4><ul>
<li>单元功能测试：保证所测试的每个独立的模块的功能正确，从输入条件和输出结果来判断是否满足程序的设计要求</li>
<li>系统功能测试：</li>
<li><ul>
<li>考虑模块间的相互作用，考虑系统的应用环境</li>
</ul>
</li>
<li><ul>
<li>衡量标准是实现产品规格说明书上所要求的功能</li>
</ul>
</li>
<li><ul>
<li>特别地，模拟用户从头到尾（End-to-End,端到端）的业务测试，确保系统可以完成实现设计的功能，满足用户实际业务需求<br>功能测试的整体思路：需求 -&gt; 测试用例。客户需求为导向，全面理解功能特性。</li>
</ul>
</li>
</ul>
<h4 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h4><ul>
<li>一旦程序某些区域被修改了，就可能影响其它区域，导致受影响的区域出现新的缺陷（<strong>回归缺陷</strong>）。</li>
<li>回归测试是为了<strong>发现回归缺陷</strong>而进行的测试。</li>
<li><strong>定义</strong>：对软件的新版本测试时，重复执行上一个版本测试时的用例。</li>
<li>回归测试可以在任何测试阶段进行。既有黑盒测试的回归，也有白盒测试的回归。</li>
</ul>
<h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h4><p>性能测试：是为了发现系统性能问题或获取系统性能相关指标而进行的测试。一般在真实环境、特定负载（正常或峰值）条件下，通过工具模拟实际软件系统的运行及其操作，同时监控性能各项指标，最后对测试结果进行分析来确定系统的性能状况。<br><em>性能测试用来保证产品发布后系统的性能能够满足用户需求</em></p>
<p>性能测试目标：</p>
<ul>
<li>获取系统性能某些指标数据</li>
<li>为了<strong>验证</strong>系统是否达到用户提出的性能指标</li>
<li>发现系统中存在的<strong>性能瓶颈</strong>，优化系统的性能</li>
</ul>
<p>性能测试类型：</p>
<ul>
<li>性能规划测试</li>
<li>性能基准测试</li>
<li>容量测试</li>
<li>性能验证测试</li>
</ul>
<p>产品生命周期中的性能要点：</p>
<ul>
<li>需求分析中充分关注负载压力性能</li>
<li>在设计中得到负载压力性能指标</li>
<li>开发阶段创建负载压力性能测试环境</li>
<li>验收阶段在多等级范围内测试并调优</li>
<li>运行阶段持续监控系统负载压力性能</li>
</ul>
<p>不同角度的关注点：</p>
<ul>
<li>响应时间是用户的关注点；</li>
<li>容量和数据吞吐量是（产品市场团队）业务处理方面的关注点；</li>
<li>而系统资源占用率是开发团队的技术关注点。</li>
</ul>
<p>性能的具体指标：</p>
<ul>
<li>数据传输的吞吐量（Transactions）</li>
<li>数据处理效率（Transactions per second）</li>
<li>数据请求的响应时间（Response time）</li>
<li>内存和CPU使用率</li>
</ul>
<p>80～20原理：每个工作日80％的业务在20％的时间内完成。</p>
<p>负载压力测试：在一定约束条件下测试系统所能承受的并发用户量、运行时间、数据量，以确定系统能承受的最大负载压力。<br>在一种需要反常（如长时间的峰值）数量、频率或资源的方式下，执行可重复的负载测试，以检查程序对异常情况的抵抗能力，找出<strong>性能瓶颈</strong>或其它<strong>不稳定性问题</strong>。</p>
<p>并发性能测试：<strong>逐渐增加并发用户数</strong>负载，直到系统出现性能瓶颈或者崩溃（不能接受的性能点）为止。通过综合分析交易执行指标、资源监控指标来确定系统并发性能的过程。<strong>并发性能是负载压力测试的重要内容。</strong></p>
<ul>
<li>负载测试：通过逐步增加系统负载，测试系统性能的变化，并最终确定<strong>在满足性能指标的情况下</strong>，系统能承受的<strong>最大负载量</strong>的测试。</li>
<li>压力测试：通过逐步增加系统负载，测试系统性能的变化，并最终确定在什么负载条件下系统性能处于<strong>失效状态</strong>，并以此来获得<strong>系统能提供的最大服务级别</strong>的测试。压力测试是为了发现在什么条件下系统的性能会变得不可接受。</li>
</ul>
<h4 id="其他非功能性测试"><a href="#其他非功能性测试" class="headerlink" title="其他非功能性测试"></a>其他非功能性测试</h4><h5 id="安全性测试"><a href="#安全性测试" class="headerlink" title="安全性测试"></a>安全性测试</h5><p>安全性：使伤害或损害的风险限制在可接受的水平内<br>软件安全性测试：检验系统权限设置有效性、防范非法入侵的能力、数据备份和恢复能力等，设法找出各种安全性漏洞<br><strong>系统安全设计的准则</strong>：使非法侵入的代价超过被保护信息的价值</p>
<p>安全性测试：</p>
<ul>
<li>软件不做它不应该做的事, 应用输入验证, 没有不安全的事情发生</li>
<li>在测试软件系统中对危险防止和危险处理设施进行的测试，以验证其是否有效</li>
<li>安全性缺陷常常由软件的副作用引起，即软件应当做A，它<em>做了A的同时，又做了B</em></li>
</ul>
<p>安全性测试方法：</p>
<ul>
<li>基于漏洞的方法，从软件内部考虑其安全性，识别软件的安全漏洞。如借助于特定的漏洞扫描器。</li>
<li>基于威胁的方法，从软件外部考察其安全性，识别软件面临的安全威胁并测试其是否能够发生</li>
<li>模拟攻击测试是一组特殊的 、极端的测试方法，如Fuzzing，使用大量半有效的数据作为应用程序的输入，以程序是否出现异常为标志，来发现应用程序中可能存在的安全漏洞</li>
</ul>
<h5 id="可靠性和容错性测试"><a href="#可靠性和容错性测试" class="headerlink" title="可靠性和容错性测试"></a>可靠性和容错性测试</h5><p>可靠性（Reliability）是产品在<strong>规定的条件下和规定的时间内完成规定功能的能力</strong>。软件可靠性与软件缺陷有关，也与系统输入和系统使用有关。理论上说，可靠的软件系统应该是正确、完整、一致和健壮的。</p>
<p><strong>成熟性度量</strong>可以通过错误发现率DDP（Defect Detection Percentage）来表现。在测试中查找出来的错误越多，实际应用中出错的机会就越小，软件也就越成熟。</p>
<p>容错性测试（Fault-tolrent test）是检查软件在异常条件下自身是否具有<strong>防护性的措施</strong>或者某种<strong>灾难性恢复</strong>的手段。</p>
<ul>
<li>输入异常数据或进行异常操作，以检验系统的保护性。如果系统的容错性好的话，系统只给出提示或内部消化掉，而不会导致系统出错甚至崩溃。</li>
<li>灾难恢复性测试。通过各种手段，让软件强制性地发生故障，然后验证系统已保存的用户数据是否丢失、系统和数据是否能尽快恢复。</li>
</ul>
<h5 id="兼容性测试"><a href="#兼容性测试" class="headerlink" title="兼容性测试"></a>兼容性测试</h5><p>兼容性测试: 验证软件之间是否正确地交互和共享信息<br>需要对所有可能的软件组合等价分配，验证软件之间正确交互的最小有效集合。</p>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>university</tag>
        <tag>software-test</tag>
      </tags>
  </entry>
  <entry>
    <title>教程其二之git</title>
    <url>/2023/08/04/tutorial-git/</url>
    <content><![CDATA[<h2 id="开源为王-git安装与github初入门"><a href="#开源为王-git安装与github初入门" class="headerlink" title="开源为王- git安装与github初入门"></a>开源为王- git安装与github初入门</h2><p>“开源（open source）”——人人可审查、修改与增强，可以从这篇文章稍作了解<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNzUwMTA3MA==">什么是开源？<i class="fa fa-external-link-alt"></i></span>。<br>至于git——世界上<strong>目前最先进</strong>的分布式版本控制系统，详见廖雪峰大佬的<span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvODk2MDQzNDg4MDI5NjAw">Git教程<i class="fa fa-external-link-alt"></i></span>。</p>
<p>以下内容不对其上概念和重要性做过多阐述，请自行选择阅读上述文章，以下仅从安装配置讨论。</p>
<span id="more"></span>

<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Windows 上安装方法有几种，对于新手推荐以下两种。</p>
<h4 id="官网安装"><a href="#官网安装" class="headerlink" title="官网安装"></a>官网安装</h4><p>官网下载地址（通过科学上网访问）：<span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9kb3dubG9hZC93aW4=">https://git-scm.com/download/win<i class="fa fa-external-link-alt"></i></span><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308041758468.png"></p>
<blockquote>
<p>小提示：如果你对你的英语水平不自信，edge&#x2F;chrome浏览器可以安装<code>沉浸式翻译</code>插件。<br>官网安装的详细步骤详见<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L211a2VzL2FydGljbGUvZGV0YWlscy8xMTU2OTM4MzM=">Git详细安装教程<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h4 id="Github-Desktop-安装"><a href="#Github-Desktop-安装" class="headerlink" title="Github Desktop 安装"></a>Github Desktop 安装</h4><p>该安装程序包含图形化和命令行版本的 Git。它也能支持 Powershell，提供了稳定的凭证缓存和健全的换行设置。前往 Github for Windows 网站下载，网址为<span class="exturl" data-url="aHR0cHM6Ly9kZXNrdG9wLmdpdGh1Yi5jb20v">https://desktop.github.com/<i class="fa fa-external-link-alt"></i></span>。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>打开 Git Bash ，命令行界面如下：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308041813146.png"></p>
<p>配置用户名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;username&quot;</span> // 将<span class="string">&quot;username&quot;</span>替换为你的账户名</span><br></pre></td></tr></table></figure>
<p>邮箱：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.email <span class="string">&quot;user@email.com&quot;</span> // 将<span class="string">&quot;user@email.com&quot;</span>替换为你的邮箱</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果你不清楚为什么要配置用户名和邮箱，请重新阅读<span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvODk2MDQzNDg4MDI5NjAw">Git教程<i class="fa fa-external-link-alt"></i></span>并找到相关部分。</p>
</blockquote>
<p>以上命令执行完毕后，可以用如下命令查看配置是否正确。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308041817797.png"></p>
<p>确认完毕后，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>
<p>此时有三个配置问题，第一次使用保持默认配置即可，<strong>请连按三次回车键</strong>。<br>结束后你可以看到两个目录地址，如你保持默认配置则前往系统盘目录<code>C:\Users(用户)\&quot;username&quot;\.ssh</code>文件夹查看 ssh 文件是否生成成功，分别为<code>id_rsa</code>和<code>id_rsa.pub</code>。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308041826736.png"></p>
<p>此时 git 的配置暂时告一段落，让我们将目光转向 github ，世界上最大的开源仓库平台。</p>
<h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>如果你对注册账号的流程抱有疑问，请查看<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MTY1OTQ1MjA=">注册Github账号详细教程<i class="fa fa-external-link-alt"></i></span>，本博客不再详述。</p>
<blockquote>
<p>如若可以，建议用非 qq 邮箱注册，出于 qq 号可能被封禁考虑。</p>
</blockquote>
<p>你的 github 主页如下：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308041832965.png"></p>
<h3 id="绑定-git"><a href="#绑定-git" class="headerlink" title="绑定 git"></a>绑定 git</h3><p>点击右上角你的头像，选择<code>Settings</code>：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308041833037.png"></p>
<p>于左侧<code>Access</code>下选择<code>SSH and GPG keys</code>：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308041835639.png"></p>
<p>点击<code>New SSH Key</code>：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308041840544.png"></p>
<p>title随意取好，个人建议为<code>你的电脑型号-Windows</code>（如<code>ThinkBook16p-Windows</code>），方便日后管理不同电脑&#x2F;虚拟机&#x2F;系统的 git 密钥。 Key Type 保持不变为<code>Authentication Key</code>。将<strong>公钥（<code>id_rsa.pub</code>）</strong>文件中的内容用 vscode 打开后复制粘贴到key中，然后点击<code>Add SSH key</code>即可。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308041841111.png">。</p>
<blockquote>
<p>如果你对 SSH 公钥与私钥之分很感兴趣，可以阅读<span class="exturl" data-url="aHR0cHM6Ly9zb25nbGVlMjQuZ2l0aHViLmlvLzIwMTUvMDUvMDMvcHVibGljLWtleS1hbmQtcHJpdmF0ZS1rZXkv">理解公钥与私钥<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>测试一下你的配置是否成功，在 Git Bash 终端中输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308041848555.png"><br>看到如上字样则你的 github 与 git 已经配置成功。欢迎来到开源世界！</p>
]]></content>
      <categories>
        <category>recruitment</category>
      </categories>
      <tags>
        <tag>software-engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js 笔记</title>
    <url>/2023/08/26/note-nodeJs/</url>
    <content><![CDATA[<h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><h3 id="Zero-Delay"><a href="#Zero-Delay" class="headerlink" title="Zero Delay"></a>Zero Delay</h3><p>如果指定超时延迟为 0 ，回调函数将尽快执行，但在当前函数执行之后：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;after &#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27; before &#x27;</span>);</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>该代码将打印</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">before</span><br><span class="line">after</span><br></pre></td></tr></table></figure>

<p>这对于避免在密集型任务上阻塞 CPU 并通过在调度程序中对函数进行排队来让其他函数在执行繁重计算时执行特别有用。</p>
<h3 id="Recursive-setTimeout"><a href="#Recursive-setTimeout" class="headerlink" title="Recursive setTimeout"></a>Recursive setTimeout</h3><p><code>setInterval</code> 每 n 毫秒启动一个函数，而不考虑函数何时完成执行。如果一个函数总是花费相同的时间，那就没问题；但也许一个长执行会与下一个执行重叠：</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308261059739.png"></p>
<p>为了避免这种情况，您可以安排在回调函数完成时调用递归 setTimeout：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">myFunction</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(myFunction, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(myFunction, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>为了实现这个场景：</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308261100968.png"></p>
<p>Node.js 还提供了 <code>setImmediate()</code> ，相当于使用 <code>setTimeout(() =&gt; &#123;&#125;</code>, 0) ，主要用于与 Node.js 事件循环配合使用。</p>
<h3 id="setImmediate"><a href="#setImmediate" class="headerlink" title="setImmediate()"></a>setImmediate()</h3><p><code>setImmediate()</code> 与 <code>setTimeout(() =&gt; &#123;&#125;, 0)</code> （传递 0 毫秒超时）以及 <code>process.nextTick() </code>和 <code>Promise.then()</code> 有何不同？</p>
<p>当前操作结束后，传递给 <code>process.nextTick()</code> 的函数将在事件循环的当前迭代中执行。这意味着它将始终在 <code>setTimeout</code> 和 <code>setImmediate</code> 之前执行。</p>
<p>延迟 0 毫秒的 <code>setTimeout()</code> 回调与 <code>setImmediate()</code> 非常相似。执行顺序将取决于各种因素，但它们都将在事件循环的下一次迭代中运行。</p>
<p><code>process.nextTick</code> 回调被添加到 <code>process.nextTick queue</code> 。 <code>Promise.then()</code> 回调被添加到 <code>promises microtask queue</code> 。 setTimeout 回调被添加到 <code>macrotask queue</code> 。</p>
<p>事件循环首先执行 <code>process.nextTick queue</code> 中的任务，然后执行 <code>promises microtask queue</code> ，然后执行 <code>macrotask queue</code> 。</p>
<p>下面是一个显示 <code>setImmediate()</code> 、 <code>process.nextTick()</code> 和 <code>Promise.then()</code> 之间顺序的示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">baz</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">zoo</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;zoo&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">start</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>);</span><br><span class="line">  <span class="title function_">setImmediate</span>(baz);  <span class="comment">// 3</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(resolve);</span><br><span class="line">    process.<span class="title function_">nextTick</span>(zoo);  <span class="comment">// 2</span></span><br><span class="line">  &#125;);</span><br><span class="line">  process.<span class="title function_">nextTick</span>(foo);  <span class="comment">// 1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">start</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// start foo bar zoo baz</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此代码将首先调用 <code>start()</code> ，然后调用 <code>process.nextTick queue</code> 中的 <code>foo()</code> 。之后，它将处理 <code>promises microtask queue</code> ，打印 <code>bar</code> 并同时在 <code>process.nextTick queue</code> 中添加 <code>zoo()</code> 。然后就会调用刚刚添加的 <code>zoo()</code> 。最终调用了 <code>macrotask queue</code> 中的 <code>baz()</code> 。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p>更应该说是摘抄自</p>
</blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMuZGV2L2VuL2xlYXJuL2Rpc2NvdmVyLWphdmFzY3JpcHQtdGltZXJzLw==">探索 JavaScript 定时器<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>教程其一之VSCode</title>
    <url>/2023/08/03/tutorial-vscode/</url>
    <content><![CDATA[<h2 id="工欲善其事，必先利其器-从环境开始讲起"><a href="#工欲善其事，必先利其器-从环境开始讲起" class="headerlink" title="工欲善其事，必先利其器-从环境开始讲起"></a>工欲善其事，必先利其器-从环境开始讲起</h2><p>刚踏入计算机相关专业，却从未有编程经验？甚至从小到大第一次遇见计算机？没有关系，让我们从零开始讲起，一步一步从最最基础的开始讲起。<br>开篇先叠甲：<em>以下所有内容仅源于于个人体验，请根据你使用最舒服的方式进行配置。</em></p>
<span id="more"></span>

<h2 id="计算机环境"><a href="#计算机环境" class="headerlink" title="计算机环境"></a>计算机环境</h2><h3 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h3><p>如题，请确保你能通过<strong>科学上网</strong>访问<a href="%22https://github.com/%22">Github</a>。如若不能（或者你从未听过科学上网），请询问你身边的学长学姐。</p>
<h3 id="安全软件"><a href="#安全软件" class="headerlink" title="安全软件"></a>安全软件</h3><p>首先，如果你有良好的计算机使用习惯，日常远离p2p下崽器、xxx中文网，始终对于网络资源尤其是各类安装包保持警惕，安装软件的第一步是寻找官网且日常略过前三广告，那么恭喜你，可以卸载所有安全管家等。<strong>Windows安全中心</strong>绝对足敷使用，请打开它并开启所有必要的保护。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308021111543.png"><br>这个可以解决许多因安全软件拦截而产生的疑难杂症。<strong>请务必确保您的使用习惯足够良好，本站概不承担因卸载后猪脑过载导致的财产损失。</strong></p>
<h3 id="浏览器和搜索引擎"><a href="#浏览器和搜索引擎" class="headerlink" title="浏览器和搜索引擎"></a>浏览器和搜索引擎</h3><p>Chrome，Edge，Firefox三选其一（排名分先后）。<br><strong>近乎所有的国产浏览器都是Chromium套壳+捆绑广告，请不要让它们污染你重金购入的电脑。</strong><br>利用科学上网手段注册账号后，打开密码自动填充并在手机端下载相同浏览器，上网体验如德芙般丝滑。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308021121569.png"><br>请将默认浏览器设置为你最喜欢的御三家之一，搜索引擎推荐google&#x2F;bing（前者更好，但需要保持科学上网）。<strong>作为高质量大学生，请不要使用百度搜索引擎。</strong></p>
<p>益智小游戏，请指出图中真正的steam官网：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308021126585.png"></p>
<p>最基本的计算机环境已经配置完毕，电脑已经清爽许多，现在让我们叩开编程的大门，不妨先从环境入手。</p>
<h2 id="Visual-Studio-Code：免费开源的轻量级代码编辑器"><a href="#Visual-Studio-Code：免费开源的轻量级代码编辑器" class="headerlink" title="Visual Studio Code：免费开源的轻量级代码编辑器"></a>Visual Studio Code：免费开源的轻量级代码编辑器</h2><h3 id="为什么是-VS-Code-？"><a href="#为什么是-VS-Code-？" class="headerlink" title="为什么是 VS Code ？"></a>为什么是 VS Code ？</h3><p>VS Code 的全称是 Visual Studio Code，是一款开源的、免费的、跨平台的、高性能的、轻量级的代码<strong>编辑器</strong>。</p>
<p>何为编辑器？何为IDE？</p>
<ul>
<li>IDE（Integrated Development Environment，集成开发环境）:一组集成在一起的工具，包含文本编辑器、编译器、构建或集成、调试。侧重于工程项目，比较臃肿笨重。如Visual Studio、IDEA、Eclipse。</li>
<li>编辑器：文本（代码）的编辑。如Windows系统自带的记事本就是最简单的编辑器。</li>
</ul>
<p>微软有两种软件：一种是 VS Code，一种是其他软件。</p>
<h3 id="VS-Code-的特点"><a href="#VS-Code-的特点" class="headerlink" title="VS Code 的特点"></a>VS Code 的特点</h3><ul>
<li>跨平台：支持 MacOS、Windows 和 Linux 等多个平台，且有一致的用户界面和开发体验，支持同步配置</li>
<li>开源：源代码、开发计划和发布管理均开源</li>
<li>自带终端、Git版本支持</li>
<li>丰富的插件拓展</li>
<li>活跃的社区生态</li>
<li>语法支持：语法高亮、代码智能提示和补全、括号匹配、颜色区分、代码片段提示</li>
</ul>
<h3 id="官网安装"><a href="#官网安装" class="headerlink" title="官网安装"></a>官网安装</h3><p>免费？不是70r吗？</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308021130466.png"></p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308021132921.webp"></p>
<p>这就是为什么推荐google或bing搜索引擎，因为你真的能在国产搜索引擎看到这些。如果对是否是官网有疑问，请尤其注意他的域名。通过域名，能够分辨一大半的虚假官网。</p>
<p>真正的VSCode官网：<span class="exturl" data-url="aHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20v">https://code.visualstudio.com/<i class="fa fa-external-link-alt"></i></span>，点开后你应该能看到如下网页。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308021137406.png"></p>
<p>请根据你的电脑型号（Windows or MacOS）选择对应Stable（*稳定）版本下载。安装过程不再赘述，其中注意Win本<strong>尽量选择安装路径为非C盘</strong>即可，否则后续很可能<strong>因为C盘爆满，Windows系统无法更新</strong>。</p>
<p>安装完成后打开软件，界面如下：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308030942879.png"></p>
<p>如果你对英文界面感觉不太好，那么第一步就是<strong>将VSCode设置为中文</strong>。以下有两种方法：</p>
<ul>
<li>Windows用户快捷键<code>Ctrl+Shift+P</code>（Mac用户快捷键<code>Cmd+Shift+P</code>），打开命令面板，输入<code>Configure Display Language</code>，选择<code>Install additional languages</code>，然后安装插件<code>Chinese(Simplified) Language Pack for Visual Studio Code</code>即可</li>
<li>Windows用户快捷键<code>Ctrl+Shift+X</code>，打开拓展页面，同样安装此插件<code>Chinese(Simplified) Language Pack for Visual Studio Code</code><br>安装完成后，重启 VS Code 。</li>
</ul>
<p>解放右手，请熟记常用快捷键组合。</p>
<h3 id="常见操作-amp-使用技巧"><a href="#常见操作-amp-使用技巧" class="headerlink" title="常见操作&amp;使用技巧"></a>常见操作&amp;使用技巧</h3><h4 id="1、快速生成HTML骨架"><a href="#1、快速生成HTML骨架" class="headerlink" title="1、快速生成HTML骨架"></a>1、快速生成HTML骨架</h4><p>新建一个.html文件（如example.html），然后通过以下方式可快速生成HTML骨架：</p>
<ol>
<li>输入<code>!</code>（英文感叹号），然后按下<code>Enter</code>键</li>
<li>输入<code>html:5</code>，然后按住<code>Tab</code>键<br>生成的骨架如下：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>小技巧：</strong>在HTML文件中输入<code>lorem</code>可生成一段占位文本。</p>
<h4 id="2、并排编辑：上下左右显示多个文件窗口"><a href="#2、并排编辑：上下左右显示多个文件窗口" class="headerlink" title="2、并排编辑：上下左右显示多个文件窗口"></a>2、并排编辑：上下左右显示多个文件窗口</h4><p>Windows用户按住快捷键<code>Ctrl + \</code>（反斜杠，在你的<code>Enter</code>回车键上方），即可同时打开多个编辑器窗口，进行并排编辑。按快捷键<code>Ctrl + 1</code>切换到左侧窗口，<code>Ctrl + 2</code>切换到右侧窗口，以此类推。</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308031012609.png"></p>
<h3 id="部分插件推荐"><a href="#部分插件推荐" class="headerlink" title="部分插件推荐"></a>部分插件推荐</h3><h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308031015953.png"></p>
<p>我们可通过点击上图中红框部分，即可在顶部输入框中查找想要安装的插件名，然后进行安装。安装完毕后部分插件会需要重启软件，插件才会生效。<br>另外，我们也可以通过访问官网的插件市场来安装插件：<br>VS Code 官网插件市场：<span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL3ZzY29kZQ==">https://marketplace.visualstudio.com/vscode<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="推荐的插件"><a href="#推荐的插件" class="headerlink" title="推荐的插件"></a>推荐的插件</h4><h5 id="0、基本插件"><a href="#0、基本插件" class="headerlink" title="0、基本插件"></a>0、基本插件</h5><h6 id="Chinese-Simplified-Language-Pack-for-Visual-Studio-Code"><a href="#Chinese-Simplified-Language-Pack-for-Visual-Studio-Code" class="headerlink" title="Chinese (Simplified) Language Pack for Visual Studio Code"></a>Chinese (Simplified) Language Pack for Visual Studio Code</h6><p>中文语言插件，不必多言。</p>
<h5 id="1、Git相关"><a href="#1、Git相关" class="headerlink" title="1、Git相关"></a>1、Git相关</h5><p>还不熟悉Git？没事，先安装再说，后续我们一定会讲到or用上。</p>
<h6 id="GitLens"><a href="#GitLens" class="headerlink" title="GitLens"></a>GitLens</h6><p>Git管理神器，可视化仓库。</p>
<h6 id="Local-History"><a href="#Local-History" class="headerlink" title="Local History"></a>Local History</h6><p>维护文件的本地历史记录，妈妈再也不用担心我代码忘记保存了。</p>
<h5 id="2、代码显示增强"><a href="#2、代码显示增强" class="headerlink" title="2、代码显示增强"></a>2、代码显示增强</h5><h6 id="highlight-icemode"><a href="#highlight-icemode" class="headerlink" title="highlight-icemode"></a>highlight-icemode</h6><p>选中相同代码时高亮显示。安装后请关闭 VS Code 自带高亮，于用户设置添加<code>&quot;editor.selectionHighlight&quot;: false</code>。</p>
<h6 id="TODO-Highlight"><a href="#TODO-Highlight" class="headerlink" title="TODO Highlight"></a>TODO Highlight</h6><p>什么，手上的 bug 还没修完突然有事，正巧这时候有了思路？按照代码规范，可以在代码中加上 TODO 注释（区分大小写）。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// TODO:发现跳转bug，可能的解决思路为：······</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// FIXME: 如没有万分把握请勿删去此行注释，可能导致程序崩溃。</span><br></pre></td></tr></table></figure>
<p>安装此插件后，打开命令面板（还记得快捷键吗？）输入<code>TODO-Highlight</code>，选择相关命令，我们就可以看到 todoList 清单。</p>
<h5 id="3、图片相关插件"><a href="#3、图片相关插件" class="headerlink" title="3、图片相关插件"></a>3、图片相关插件</h5><h6 id="Polacode-2022"><a href="#Polacode-2022" class="headerlink" title="Polacode-2022"></a>Polacode-2022</h6><p>可优雅地分享你的代码截图，如下所示：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308031036600.png"></p>
<p>我们谴责愚蠢的拍屏主义者，<code>Win+Shift+S</code>截图为可接受的。</p>
<h5 id="4、Markdown相关"><a href="#4、Markdown相关" class="headerlink" title="4、Markdown相关"></a>4、Markdown相关</h5><p>本网站所有博客均由 Markdown 写成，其优点在于不用操心格式，随想随写，解放右手。推荐 VS Code + Markdown ，最好的笔记组合。</p>
<h6 id="Markdown-Preview-Github-Styling"><a href="#Markdown-Preview-Github-Styling" class="headerlink" title="Markdown Preview Github Styling"></a>Markdown Preview Github Styling</h6><p>以 Github 风格预览 Markdown 样式，简洁且优雅。左侧书写右侧预览。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308031047619.png"></p>
<h5 id="5、通用工具"><a href="#5、通用工具" class="headerlink" title="5、通用工具"></a>5、通用工具</h5><h6 id="Live-Server"><a href="#Live-Server" class="headerlink" title="Live Server"></a>Live Server</h6><p>在本地启动服务器，代码修改时实现<strong>热更新</strong>，不需要手动刷新页面。<br>使用方式：于代码页面点击右键，选择<code>Open with Live Server</code>。</p>
<h6 id="WakaTime"><a href="#WakaTime" class="headerlink" title="WakaTime"></a>WakaTime</h6><p>统计在各安装了 WakaTime 插件的编程环境中写代码的时间，发现真实的自己。网站统计效果如下：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308031051230.png"></p>
<h5 id="6、软件主题"><a href="#6、软件主题" class="headerlink" title="6、软件主题"></a>6、软件主题</h5><p>想给你的 VS Code 换个皮肤？欢迎来到海澜之家！</p>
<ul>
<li><p>Dracula Theme</p>
</li>
<li><p>Material Theme</p>
</li>
<li><p>Nebula Theme</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPXpodWFuZ3RvbmdmYS5NYXRlcmlhbC10aGVtZQ==">One Dark Pro<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>One Monokai Theme</p>
</li>
<li><p>Monokai Pro</p>
</li>
<li><p>Ayu</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPWFrYXJsc3Rlbi52c2NvZGUtc25henp5LWFrYXJsc3Rlbg==">Snazzy Plus<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPWFsZXhhbmRlcnRlLmRhaW50eS12c2NvZGU=">Dainty<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>GitHub Plus Theme：白色主题</p>
</li>
<li><p>Horizon Theme：红色主题</p>
</li>
</ul>
<h3 id="多端协作：-VS-Code-云同步"><a href="#多端协作：-VS-Code-云同步" class="headerlink" title="多端协作： VS Code 云同步"></a>多端协作： VS Code 云同步</h3><ol>
<li>上方菜单栏选择<code>文件-首选项-打开设置同步</code></li>
<li>选择需要同步的配置，全选即可</li>
<li>通过 GitHub 账号登录</li>
<li>同步完成后，菜单栏显示“设置同步已打开”</li>
</ol>
<p>什么，你还没有 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLw==">GitHub<i class="fa fa-external-link-alt"></i></span> 账号？注册啊！</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308031041381.jpg"></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3FpYW5ndXlpaGFvL1dlYi9ibG9iL21hc3Rlci8wMC0lRTUlODklOEQlRTclQUIlQUYlRTUlQjclQTUlRTUlODUlQjcvMDEtVlMlMjBDb2RlJUU3JTlBJTg0JUU0JUJEJUJGJUU3JTk0JUE4Lm1k">Web-Master&#x2F;00-前端工具<i class="fa fa-external-link-alt"></i></span><br>多有参考，如想进一步了解 VS Code 如快捷键及更进一步的配置，可阅读全文。<br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC85MjMxMjY0Mg==">为什么要学Markdown？有什么用？<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>recruitment</category>
      </categories>
      <tags>
        <tag>frontend</tag>
        <tag>software-engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>websocket 在 vue 中的使用</title>
    <url>/2023/08/22/use-websocket-in-vue/</url>
    <content><![CDATA[<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>socket.io-client</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pnpm i socket.io-client</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol>
<li>规范 socket api</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// socket.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; io, <span class="title class_">Socket</span> &#125; <span class="keyword">from</span> <span class="string">&quot;socket.io-client&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SocketService</span> &#123;</span><br><span class="line">  <span class="attr">socket</span>: <span class="title class_">Socket</span></span><br><span class="line">  <span class="attr">state</span>: <span class="built_in">any</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="attr">room</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="attr">sio</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">flag</span>: <span class="number">60</span>,</span><br><span class="line">      <span class="attr">sid</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="attr">heartbeatTimer</span>: <span class="literal">null</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socket</span> = <span class="title function_">io</span>(<span class="string">&quot;/websocket&quot;</span>, &#123;</span><br><span class="line">      <span class="attr">autoConnect</span>: <span class="literal">false</span>, <span class="comment">// 禁止自动连接</span></span><br><span class="line">      <span class="attr">extraHeaders</span>: &#123;</span><br><span class="line">        <span class="string">&quot;Access-Control-Allow-Origin&quot;</span>: <span class="string">&quot;*&quot;</span> <span class="comment">// 设置跨域请求头</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// connect, get_sid 只执行一次，采用 once</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socket</span>.<span class="title function_">once</span>(<span class="string">&quot;connect&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">handleConnect</span>()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socket</span>.<span class="title function_">once</span>(<span class="string">&quot;get_sid&quot;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">handleGetSid</span>(data)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socket</span>.<span class="title function_">on</span>(<span class="string">&quot;join_room_result&quot;</span>, <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">handleJoinRoomResult</span>(res)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socket</span>.<span class="title function_">on</span>(<span class="string">&quot;test&quot;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">handleTest</span>(data)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socket</span>.<span class="title function_">on</span>(<span class="string">&quot;leave&quot;</span>, <span class="function">(<span class="params">room</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">handleLeave</span>(room)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socket</span>.<span class="title function_">on</span>(<span class="string">&quot;leave_all&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">handleLeaveAll</span>()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socket</span>.<span class="title function_">on</span>(<span class="string">&quot;connect_error&quot;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">handleConnectError</span>(err)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">connect</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socket</span>.<span class="title function_">connect</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;socket connect&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">disconnect</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">handleLeaveAll</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">stopHeartbeat</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socket</span>.<span class="title function_">disconnect</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;socket disconnect&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">joinRoom</span>(<span class="params">room: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socket</span>.<span class="title function_">emit</span>(<span class="string">&quot;join&quot;</span>, &#123; <span class="attr">rooms</span>: [room] &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">leaveRoom</span>(<span class="params">room: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">handleLeave</span>(room)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">leaveAll</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">handleLeaveAll</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">handleConnect</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socket</span>.<span class="title function_">emit</span>(<span class="string">&quot;get_sid&quot;</span>, &#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">handleGetSid</span>(<span class="params">data: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">sid</span> = data.<span class="property">sid</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;get_sid:&quot;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">sid</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">handleJoinRoomResult</span>(<span class="params">res: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">handleTest</span>(<span class="params">data: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;test data:&quot;</span> + data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 离开指定房间</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">handleLeave</span>(<span class="params">room: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socket</span>.<span class="title function_">emit</span>(<span class="string">&quot;leave&quot;</span>, &#123; <span class="attr">rooms</span>: [room] &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;leave room &quot;</span> + room)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 离开所有房间</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">handleLeaveAll</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socket</span>.<span class="title function_">emit</span>(<span class="string">&quot;leave_all&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;leave all room&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理连接错误</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">handleConnectError</span>(<span class="params">err: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">stopHeartbeat</span>() <span class="comment">// 停止心跳，避免不必要的心跳消息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 启动心跳计时器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">startHeartbeat</span>() =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">heartbeatTimer</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">heartbeatTimer</span> = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">sendHeartbeat</span>()</span><br><span class="line">        &#125;, <span class="number">15000</span>) <span class="comment">// 15秒发送一次心跳，可以根据需求调整</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 停止心跳计时器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">stopHeartbeat</span>() =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">heartbeatTimer</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">heartbeatTimer</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">heartbeatTimer</span> = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送心跳数据</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">sendHeartbeat</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socket</span>.<span class="title function_">emit</span>(<span class="string">&quot;heartbeat&quot;</span>, &#123; <span class="comment">/* 心跳数据 */</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> socketService = <span class="keyword">new</span> <span class="title class_">SocketService</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> socket = socketService.<span class="property">socket</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> state = socketService.<span class="property">state</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>设置 url</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vite.config.ts</span></span><br><span class="line"></span><br><span class="line"><span class="attr">proxy</span>: &#123;</span><br><span class="line">    <span class="string">&quot;/socket.io&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&quot;http://example.com&quot;</span> <span class="comment">// 代理目标（后端 socket URL ）</span></span><br><span class="line">        <span class="attr">ws</span>: <span class="literal">true</span>, <span class="comment">// 设置代理 WebSocket 连接</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">// 允许跨域</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>建立 socket 连接</li>
</ol>
<p>websocket 连接应在打开页面时建立，关闭页面时销毁，所以应选择在入口文件建立。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// App.vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; socketService &#125; <span class="keyword">from</span> <span class="string">&quot;@/api/socket&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; onBeforeUnmount &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line">socketService.<span class="title function_">connect</span>()</span><br><span class="line"></span><br><span class="line"><span class="title function_">onBeforeMount</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    socketService.<span class="title function_">disconnect</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>进入 socket 房间</li>
</ol>
<p>为保证浏览器性能，房间应该在进入特定路由时建立，离开特定路由时退出，所以选择在路由守卫文件编写相关逻辑。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// permission.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&quot;@/router&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; socketService &#125; <span class="keyword">from</span> <span class="string">&quot;@/api/socket&quot;</span></span><br><span class="line"></span><br><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 离开特定路由时离开对应房间</span></span><br><span class="line">    <span class="keyword">if</span>( <span class="keyword">from</span>.<span class="property">name</span> === <span class="string">&quot;room-name&quot;</span> ) &#123;</span><br><span class="line">        socketService.<span class="title function_">leaveRoom</span>(<span class="string">&quot;room-name&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入特定路由时进入特定房间</span></span><br><span class="line">    <span class="keyword">if</span>( to.<span class="property">name</span> !== <span class="string">&quot;room-name&quot;</span> ) &#123;</span><br><span class="line">        socketService.<span class="title function_">joinRoom</span>(<span class="string">&quot;room-name&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>监听数据</li>
</ol>
<p>后端通过 WebSocket 发送的数据在前端页面渲染的部分，应在前端对应页面监听。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; socket &#125; <span class="keyword">from</span> <span class="string">&quot;@/api/socket&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">subscribeChannel</span> = (<span class="params">channel: <span class="built_in">string</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">unsubscribeChannel</span>(channel) <span class="comment">// 避免重复订阅</span></span><br><span class="line"></span><br><span class="line">    socket.<span class="title function_">on</span>(channel, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 处理数据...</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">unsubscribeChannel</span> = (<span class="params">channel: <span class="built_in">string</span></span>) =&gt; &#123;</span><br><span class="line">    socket.<span class="title function_">off</span>(channel)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL1dlYlNvY2tldA==">WebSocket - Web Api 接口参考|MDN<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9zb2NrZXQuaW8vemgtQ04v">Socket.io<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>websocket</tag>
        <tag>frontend</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>教程其三之常用git命令</title>
    <url>/2023/08/16/tutorial-git-command/</url>
    <content><![CDATA[<blockquote>
<p>本文由部长代写形成，赞美 youyiBYSKY</p>
</blockquote>
<h1 id="git的仓库管理"><a href="#git的仓库管理" class="headerlink" title="git的仓库管理"></a>git的仓库管理</h1><p>git在工程实践中起着举足轻重的作用，能够大大提高开发时版本迭代的效率。<br>接下来，本文将简单介绍一下git管理仓库的一些方法。希望阅读这篇博客的萌新能够看懂。<br><strong><del>毕竟不会用git要担心被开除了</del></strong><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/noob01.png" alt="0"><br><strong>（图来自runoob.com）</strong><br>本文从三个方面介绍仓库的管理  </p>
<ul>
<li>本地仓库</li>
<li>外部仓库</li>
<li>仓库的分支管理</li>
</ul>
<span id="more"></span>

<p>本文所用到的代码总览</p>
<blockquote>
<p><code>$ git init //仓库初始化  </code><br><code>$ git status //仓库状态  </code><br><code>$ git add //将工作区文件添加到缓存区  </code><br><code>$ git commit -m &quot;(日志内容)&quot;//提交更改到版本库 </code><br><code>$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; //push代码到远程仓库</code><br><code>$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; //从远程仓库上pull下代码</code><br><code>$ git fetch //从远程仓库下载新分支与数据</code><br><code>$ git clone &lt;repo&gt; &lt;directory&gt; //从现有 Git 仓库中拷贝项目</code><br><code>$ git branch //查看当前git中的分支列表</code><br><code>$ git checkout (branchname) //切换当前所在分支</code><br><code>$ git merge (branchname) //将指定分支合并到当前分支</code><br><code>$ git branch -d (branchname) //删除指定分支</code>  </p>
</blockquote>
<blockquote>
<p><code>$ git log //查看git日志 </code>  </p>
</blockquote>
<h2 id="git本地仓库的基础操作"><a href="#git本地仓库的基础操作" class="headerlink" title="git本地仓库的基础操作"></a>git本地仓库的基础操作</h2><h3 id="本地仓库的初始化"><a href="#本地仓库的初始化" class="headerlink" title="本地仓库的初始化"></a>本地仓库的初始化</h3><p>初始化git本地仓库的命令格式如下</p>
<blockquote>
<p><code>$ git init</code><br>在所选定的文件夹下启动git，在cmd中输入<br><code>$ git init</code>  </p>
</blockquote>
<p>之后返回提示</p>
<pre><code>Initialized empty Git repository in &quot;仓库所在文件夹的路径&quot;
</code></pre>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/1.png" alt="1"><br>即可完成仓库的初始化，同时，在该文件夹下会生成一个 <strong>.git</strong> 文件夹。</p>
<p>此时要查看仓库状态，可以输入  </p>
<blockquote>
<p><code> git status</code>  </p>
</blockquote>
<p>此时会看到已经被初始化的仓库<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/2.png" alt="2"><br><strong>这只是一个空仓库</strong></p>
<h3 id="本地仓库的管理"><a href="#本地仓库的管理" class="headerlink" title="本地仓库的管理"></a>本地仓库的管理</h3><h4 id="文件的工作区导入"><a href="#文件的工作区导入" class="headerlink" title="文件的工作区导入"></a>文件的工作区导入</h4><p>在原来的文件夹下面新增一个 <strong>“GitTest”</strong> 文件夹<br>在所选定的文件夹下导入你所要保存的项目，启动git，在cmd中输入  </p>
<blockquote>
<p><code>$ git status</code>   </p>
</blockquote>
<p>此时可以看到导入的项目文件未提交的git仓库  </p>
<pre><code class="bash">On branch master

No commits yet

Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
        GitTest/ (.git同级文件)

nothing added to commit but untracked files present (use &quot;git add&quot; to track)
</code></pre>
<h4 id="文件的暂存区导入"><a href="#文件的暂存区导入" class="headerlink" title="文件的暂存区导入"></a>文件的暂存区导入</h4><p>git中将工作区文件导入到暂存区的命令格式如下：  </p>
<blockquote>
<p><code>git add &lt;文件名&gt;</code>  </p>
</blockquote>
<p>在cmd中输入<br><code>$ git add GitTest/（所要添加到暂存区的文件）</code><br><code>（输入$ git add . 可将当前目录下的所有文件都添加到暂存区）</code>  </p>
<p>此时再查看仓库状态<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/5.png" alt="5"><br>可以看到工作区中的文件已经添加到了暂存区  </p>
<h4 id="提交文件到版本库"><a href="#提交文件到版本库" class="headerlink" title="提交文件到版本库"></a>提交文件到版本库</h4><p>git中将暂存区文件提交到版本库的命令格式如下：  </p>
<blockquote>
<p><code>git commit -m &quot;(日志内容)&quot;</code>  </p>
</blockquote>
<p>在cmd中输入  </p>
<blockquote>
<p><code>$ git commit -m &quot;提交到版本库&quot; </code>  </p>
</blockquote>
<p>然后可以看到暂存区的文件已经被更新到版本库  </p>
<pre><code class="bash">[master (root-commit) c868616] &quot;提交到版本库&quot;
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 GitTest/introduction.md
</code></pre>
<p>在cmd中再次输入  </p>
<blockquote>
<p><code>$ git status</code>  </p>
</blockquote>
<p>此时可以看到在版本库更新后，缓存区中的内容已经被清空<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/3.png" alt="3"></p>
<h4 id="提交更改到版本库"><a href="#提交更改到版本库" class="headerlink" title="提交更改到版本库"></a>提交更改到版本库</h4><p>打开上例中的 &#x2F;GitTest&#x2F;introduction.md 文件进行如下修改</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/7.png" alt="7"></p>
<p>查看仓库状态，可以看到git检测到introduction.md已被修改<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/8.png" alt="8"><br>按照上一段的步骤再次操作（工作区-&gt;暂存区-&gt;提交更改）即可将项目保存的修改提交到版本库  </p>
<h2 id="git远程仓库的基础操作"><a href="#git远程仓库的基础操作" class="headerlink" title="git远程仓库的基础操作"></a>git远程仓库的基础操作</h2><p>前言：这里稍稍加速一下，本地仓库的分支管理、版本库回溯等操作暂且跳过，就先优先讲解一写远程仓库的基础操作（pull、push）  </p>
<p><del>说实话，这种很不负责任的做法，但为了快速上手，我还是把分支管理放在了这一节之后<br><strong>原谅我</strong></del>    </p>
<h3 id="新建远程仓库"><a href="#新建远程仓库" class="headerlink" title="新建远程仓库"></a>新建远程仓库</h3><p>登录GitHub ,在主页导航栏找到新建，选中“New repository”,<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/9.png" alt="9"><br>根据引导创建远程仓库  </p>
<h3 id="关联远程仓库"><a href="#关联远程仓库" class="headerlink" title="关联远程仓库"></a>关联远程仓库</h3><p>在github中找到远程仓库的地址<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/11.png" alt="11"><br>新建仓库后复制仓库地址，在git中输入  </p>
<blockquote>
<p><code>$ git remodte add origin &quot;远程仓库地址&quot;</code>  </p>
</blockquote>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/12.png" alt="12">  </p>
<h4 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h4><p>git中push代码的命令格式如下：</p>
<blockquote>
<p><code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code>  </p>
</blockquote>
<p>现在来开始push我们已有的代码<br>此时尝试直接输入<code>git push</code>来push本地代码，会出现以下情况<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/13.png" alt="13"><br>这里提示当前master分支没有上传分支，并且提示输入  <code>git push --set-upstream origin master</code> 来建立origin和master之间的流通道<br><em><strong>（origin是远程仓库的默认名称，master是本地分支的默认名称）</strong></em><br>如上建立流通道后，打开github中的远程仓库，可以看到本地代码已经上传至远程仓库<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/14.png" alt="14">  </p>
<h4 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h4><p>git中pull代码的命令格式如下：  </p>
<blockquote>
<p><code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code>  </p>
</blockquote>
<p>打开GitHub，将先前上传的introduction.md 文件做一些改动后保存<br><strong>（在GitHub上直接修改代码时记得选择分支，这个会在之后细说）</strong><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/15.png" alt="15"><br>在git中直接输入<code>git pull</code><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/16.png" alt="16"><br>打开本地的introduction.md ，可以看见GitHub上的更改已经同步到本地<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/17.png" alt="17">  </p>
<h2 id="git的分支管理"><a href="#git的分支管理" class="headerlink" title="git的分支管理"></a>git的分支管理</h2><p>分支，是将修改的项目整体分叉保存，每个分叉后的分支相互独立，互不影响。<br>git的分支模型是git的一大 <strong>“绝学”</strong>，几乎每一种版本控制系统都以某种形式支持分支，一个分支代表一条独立的开发线。<br>利用分支，可以让多个人同时为同一个项目进行开发。在自己完成工作后，将自己分支上的修改合并到主分支。  </p>
<h3 id="查看与新建git分支"><a href="#查看与新建git分支" class="headerlink" title="查看与新建git分支"></a>查看与新建git分支</h3><p>git中查看分支的命令格式如下：  </p>
<blockquote>
<p><code>git branch</code>  </p>
</blockquote>
<p>在默认情况下，本地仓库只有一个 <strong>master</strong>分支，并且该分支是当前分支。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/18.png" alt="18">  </p>
<p>git中新建分支的命令格式如下：  </p>
<blockquote>
<p><code>git branch (branchname)</code>  </p>
</blockquote>
<p>现在我们要新建一个 <strong>“moke”</strong> 分支，只需输入：<code>git branch moke</code><br>然后再次输入<code>git branch</code>来查看所有分支。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/19.png" alt="19">  </p>
<p>现在我们可以看到，我们有了一个新的分支 <strong>“moke”</strong>。  </p>
<h3 id="切换git分支"><a href="#切换git分支" class="headerlink" title="切换git分支"></a>切换git分支</h3><p>git中切换分支的命令格式如下：  </p>
<blockquote>
<p><code>git checkout (branchname)</code>  </p>
</blockquote>
<p>现在我们要切换到方才创建的<strong>“moke”</strong> 分支，就只需要输入<code>git checkout moke</code><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/20.png" alt="20">  </p>
<p>可以看到，我们现在已经切换到了 <strong>“moke”</strong> 分支。  </p>
<p>现在打开 introduction.md ，删除第二行的内容，然后更新到版本库。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/21.png" alt="21"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/22.png" alt="22">   </p>
<p>此时输入<code>git checkout mmaster</code>切换到默认的master分支。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/23.png" alt="23">  </p>
<p>再打开 introduction.md ，可以看到在 <strong>“moke”</strong> 中被删除的第二行回来了。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/24.png" alt="24">  </p>
<p>这里证明了不同的分支下，同一个项目可以同时开发，而且互不影响。  </p>
<h3 id="合并git分支"><a href="#合并git分支" class="headerlink" title="合并git分支"></a>合并git分支</h3><p>git中合并分支的命令格式如下：  </p>
<blockquote>
<p><code>git merge (branchname)</code>  </p>
</blockquote>
<p><strong>首先先解释一下这个命令：</strong><br>这个分支合并命令是将指定分支合（上面命令格式中的参数）并到当前分支。</p>
<p>上文中master分支与 <strong>“moke”</strong> 中的内容并不相同，这里我们要把这<strong>“moke”</strong>分支合并到master分支。<br>在git中输入<code>git merge moke</code>,可以看到<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/25.png" alt="25"><br>再打开 introduction.md ，可以看到在master分支中第二行继承了 <strong>“moke”</strong>的状态，也就是被删除了。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/21.png" alt="21">    </p>
<h3 id="删除git分支"><a href="#删除git分支" class="headerlink" title="删除git分支"></a>删除git分支</h3><p>git中删除分支的命令格式如下：  </p>
<blockquote>
<p><code>git branch -d (branchname)</code>  </p>
</blockquote>
<p>上面我们将 <strong>“moke”</strong>分支合并到了master中，那么现在 <strong>“moke”</strong>分支没用了，我们就要准备删除这个分支了。<br>在git中输入<code>git branch -d moke</code>,可以看到 <strong>“moke”</strong>分支已经被删除了<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/26.png" alt="26">  </p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ul>
<li>合并冲突分支</li>
<li>git clone 与 pull、fetch之间的区别</li>
<li>git log命令的使用</li>
<li>git blame命令的使用</li>
<li>git diff命令的使用</li>
<li>远程仓库的使用进阶</li>
<li>git版本回溯</li>
</ul>
]]></content>
      <categories>
        <category>recruitment</category>
      </categories>
      <tags>
        <tag>software-engineering</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>教程其四之编码风格</title>
    <url>/2023/08/23/tutorial-style-guide/</url>
    <content><![CDATA[<h2 id="google-编码风格"><a href="#google-编码风格" class="headerlink" title="google 编码风格"></a>google 编码风格</h2><blockquote class="blockquote-center">
<p>干净的代码既简单又直接。干净的代码读起来像写得很好的散文。简洁的代码永远不会掩盖设计者的意图，而是充满清晰的抽象和直接的控制线。</p>

</blockquote>

<p><strong>style guide</strong>，编码规范，又称风格指南。每个较大的开源项目都有自己的风格指南：关于如何为该项目编写代码的一系列规定（有时候会比较武断）。当所有代码均保持一致的风格时，在理解大型代码库时更为轻松。</p>
<span id="more"></span>

<p>为什么要遵循编码规范？</p>
<ol>
<li>代码更加干净整洁</li>
<li>代码质量更高</li>
<li>提升代码的可读性</li>
<li>使后续维护更加容易</li>
</ol>
<p>如今大型软件系统之代码量，早已不是一人之力可以完成，需借助团队的力量。此时就显现出编码规范的重要之处。虽然初期为了适应编码规范需要额外的时间、降低了工作效率，但和日后维护的收益比起来，这些阵痛不值一提。</p>
<p>本篇教程我们主要介绍 Google 开源项目的 HTML&#x2F;CSS 风格指南的部分内容，同时有一些常用规范（如命名约定，函数约定）。如感兴趣可前往文末链接查看完整内容，本教程大部分引用其中。</p>
<p>请注意，我们不鼓励背诵以下内容。快速阅读，按需查找。</p>
<h3 id="先导内容"><a href="#先导内容" class="headerlink" title="先导内容"></a>先导内容</h3><h4 id="常用编程命名规范"><a href="#常用编程命名规范" class="headerlink" title="常用编程命名规范"></a>常用编程命名规范</h4><h5 id="驼峰式命名法-camel-case"><a href="#驼峰式命名法-camel-case" class="headerlink" title="驼峰式命名法(camel case)"></a>驼峰式命名法(camel case)</h5><p>第一个单词首字母小写，后面其他单词首字母大写。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> myAge;</span><br><span class="line"><span class="type">char</span> myName[<span class="number">10</span>];</span><br><span class="line"><span class="type">float</span> myHeight;</span><br></pre></td></tr></table></figure>

<h5 id="帕斯卡命名法（upper-camel-case）"><a href="#帕斯卡命名法（upper-camel-case）" class="headerlink" title="帕斯卡命名法（upper camel case）"></a>帕斯卡命名法（upper camel case）</h5><p>所有单词首字母大写。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> MyAge;</span><br><span class="line"><span class="type">char</span> MyName;</span><br><span class="line"><span class="type">float</span> MyHeight;</span><br></pre></td></tr></table></figure>

<h5 id="下划线命名法"><a href="#下划线命名法" class="headerlink" title="下划线命名法"></a>下划线命名法</h5><p>用下划线连接单词。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> my_age;</span><br><span class="line"><span class="type">char</span> my_name[<span class="number">10</span>]；</span><br><span class="line"><span class="type">float</span> my_height;</span><br></pre></td></tr></table></figure>

<h2 id="常用风格指南"><a href="#常用风格指南" class="headerlink" title="常用风格指南"></a>常用风格指南</h2><h3 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h3><p>最重要的一致性规则是命名管理. 命名的风格能让我们在不需要去查找类型声明的条件下快速地了解某个名字代表的含义: 类型, 变量, 函数, 常量, 宏, 等等, 甚至. 我们大脑中的模式匹配引擎非常依赖这些命名规则.</p>
<p>命名规则具有一定随意性, 但相比按个人喜好命名, 一致性更重要, 所以无论你认为它们是否重要, 规则总归是规则.</p>
<h4 id="通用命名规则"><a href="#通用命名规则" class="headerlink" title="通用命名规则"></a>通用命名规则</h4><h5 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h5><p>函数命名, 变量命名, 文件命名要有描述性; 少用缩写。</p>
<h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><p>尽可能使用描述性的命名, 别心疼空间, 毕竟相比之下让代码易于新读者理解更重要. 不要用只有项目开发者能理解的缩写, 也不要通过砍掉几个字母来缩写单词。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> price_count_reader;    <span class="comment">// 无缩写</span></span><br><span class="line"><span class="type">int</span> num_errors;            <span class="comment">// &quot;num&quot; 是一个常见的写法</span></span><br><span class="line"><span class="type">int</span> num_dns_connections;   <span class="comment">// 人人都知道 &quot;DNS&quot; 是什么</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;                     <span class="comment">// 毫无意义.</span></span><br><span class="line"><span class="type">int</span> nerr;                  <span class="comment">// 含糊不清的缩写.</span></span><br><span class="line"><span class="type">int</span> n_comp_conns;          <span class="comment">// 含糊不清的缩写.</span></span><br><span class="line"><span class="type">int</span> wgc_connections;       <span class="comment">// 只有贵团队知道是什么意思.</span></span><br><span class="line"><span class="type">int</span> pc_reader;             <span class="comment">// &quot;pc&quot; 有太多可能的解释了.</span></span><br><span class="line"><span class="type">int</span> cstmr_id;              <span class="comment">// 删减了若干字母.</span></span><br></pre></td></tr></table></figure>

<p>注意, 一些特定的广为人知的缩写是允许的, 例如用 <code>i</code> 表示迭代变量和用 <code>T</code> 表示模板参数。</p>
<p>模板参数的命名应当遵循对应的分类: 类型模板参数应当遵循<strong>类型命名</strong>的规则, 而非类型模板应当遵循<strong>变量命名</strong>的规则。</p>
<h4 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h4><h5 id="总述-1"><a href="#总述-1" class="headerlink" title="总述"></a>总述</h5><p>文件名要全部小写, 可以包含下划线 (<code>_</code>) 或连字符 (<code>-</code>), 依照项目的约定. 如果没有约定, 那么 “<code>_</code>” 更好。</p>
<h5 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h5><p>可接受的文件命名实例：</p>
<ul>
<li><code>my_useful_class.cc</code></li>
<li><code>my-useful-class.cc</code></li>
<li><code>myusefulclass.cc</code></li>
</ul>
<p>通常应尽量让文件名更加明确.<code> http_server_logs.h</code> 就比 <code>logs.h</code> 要好。</p>
<h4 id="类型命名"><a href="#类型命名" class="headerlink" title="类型命名"></a>类型命名</h4><blockquote>
<p>如果你还不知道什么是类型，大可以跳过此小节，但我依然建议大致看一下。</p>
</blockquote>
<h5 id="总述-2"><a href="#总述-2" class="headerlink" title="总述"></a>总述</h5><p>类型名称的每个单词首字母均大写, 不包含下划线:<code>MyExcitingClass</code>，<code>MyExcitingEnum</code>。</p>
<h5 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h5><p>所有类型命名 —— 类, 结构体, 类型定义 (<code>typedef</code>), 枚举, 类型模板参数 —— 均使用相同约定, 即以大写字母开始, 每个单词首字母均大写, 不包含下划线. 例如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类和结构体</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UrlTable</span> &#123; ...</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UrlTableTester</span> &#123; ...</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UrlTableProperties</span> &#123; ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// using 别名</span></span><br><span class="line"><span class="keyword">using</span> PropertiesMap = hash_map&lt;UrlTableProperties *, string&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">UrlTableErrors</span> &#123; ...</span><br></pre></td></tr></table></figure>

<h4 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h4><h5 id="总述-3"><a href="#总述-3" class="headerlink" title="总述"></a>总述</h5><p>变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 但结构体的就不用, 如: <code>a_local_variable</code>, <code>a_struct_data_member</code>, <code>a_class_data_member_</code>。</p>
<h5 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h5><h6 id="普通变量命名"><a href="#普通变量命名" class="headerlink" title="普通变量命名"></a>普通变量命名</h6><p>举例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string table_name;  <span class="comment">// 好 - 用下划线.</span></span><br><span class="line">string tablename;   <span class="comment">// 好 - 全小写.</span></span><br><span class="line"></span><br><span class="line">string tableName;  <span class="comment">// 差 - 混合大小写</span></span><br></pre></td></tr></table></figure>

<h6 id="类数据成员"><a href="#类数据成员" class="headerlink" title="类数据成员"></a>类数据成员</h6><p>不管是静态的还是非静态的, 类数据成员都可以和普通变量一样, 但要接下划线。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TableInfo</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  string table_name_;  <span class="comment">// 好 - 后加下划线.</span></span><br><span class="line">  string tablename_;   <span class="comment">// 好.</span></span><br><span class="line">  <span class="type">static</span> Pool&lt;TableInfo&gt;* pool_;  <span class="comment">// 好.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="结构体变量"><a href="#结构体变量" class="headerlink" title="结构体变量"></a>结构体变量</h6><p>不管是静态的还是非静态的, 结构体数据成员都可以和普通变量一样, 不用像类那样接下划线:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">UrlTableProperties</span> &#123;</span><br><span class="line">  string name;</span><br><span class="line">  <span class="type">int</span> num_entries;</span><br><span class="line">  <span class="type">static</span> Pool&lt;UrlTableProperties&gt;* pool;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a>常量命名</h4><h5 id="总述-4"><a href="#总述-4" class="headerlink" title="总述"></a>总述</h5><p>声明为 <code>constexpr</code> 或 <code>const</code> 的变量, 或在程序运行期间其值始终保持不变的, 命名时以 “k” 开头, 大小写混合. 例如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> kDaysInAWeek = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>

<h5 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h5><p>所有具有静态存储类型的变量 (例如静态变量或全局变量, 参见 <strong>存储类型</strong>) 都应当以此方式命名. 对于其他存储类型的变量, 如自动变量等, 这条规则是可选的. 如果不采用这条规则, 就按照一般的变量命名规则。</p>
<h4 id="函数命名"><a href="#函数命名" class="headerlink" title="函数命名"></a>函数命名</h4><h5 id="总述-5"><a href="#总述-5" class="headerlink" title="总述"></a>总述</h5><p>常规函数使用大小写混合, 取值和设值函数则要求与变量名匹配: <code>MyExcitingFunction()</code>, <code>MyExcitingMethod()</code>, <code>my_exciting_member_variable()</code>, <code>set_my_exciting_member_variable()</code></p>
<h5 id="说明-5"><a href="#说明-5" class="headerlink" title="说明"></a>说明</h5><p>一般来说, 函数名的每个单词首字母大写 (即 “驼峰变量名” 或 “帕斯卡变量名”), 没有下划线. 对于首字母缩写的单词, 更倾向于将它们视作一个单词进行首字母大写 (例如, 写作 <code>StartRpc()</code> 而非 <code>StartRPC()</code>)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">AddTableEntry</span>()</span><br><span class="line"><span class="built_in">DeleteUrl</span>()</span><br><span class="line"><span class="built_in">OpenFileOrDie</span>()</span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h4><h5 id="说明-6"><a href="#说明-6" class="headerlink" title="说明"></a>说明</h5><p>在排序函数参数时，将所有输入参数放在所有输出参数之前. 特别要注意, 在加入新参数时不要因为它们是新参数就置于参数列表最后, 而是仍然要按照前述的规则, 即将新的输入参数也置于输出参数之前。</p>
<h4 id="编写简短函数"><a href="#编写简短函数" class="headerlink" title="编写简短函数"></a>编写简短函数</h4><h5 id="总述-6"><a href="#总述-6" class="headerlink" title="总述"></a>总述</h5><p>我们倾向于编写简短, 凝练的函数。</p>
<h5 id="说明-7"><a href="#说明-7" class="headerlink" title="说明"></a>说明</h5><p>我们承认长函数有时是合理的, 因此并不硬性限制函数的长度. 如果函数超过 40 行, 可以思索一下能不能在不影响程序结构的前提下对其进行分割。</p>
<p>即使一个长函数现在工作的非常好, 一旦有人对其修改, 有可能出现新的问题, 甚至导致难以发现的 bug. 使函数尽量简短, 以便于他人阅读和修改代码。</p>
<p>在处理代码时, 你可能会发现复杂的长函数. 不要害怕修改现有代码: 如果证实这些代码使用 &#x2F; 调试起来很困难, 或者你只需要使用其中的一小段代码, 考虑将其分割为更加简短并易于管理的若干函数。</p>
<h2 id="HTML-x2F-CSS-风格指南"><a href="#HTML-x2F-CSS-风格指南" class="headerlink" title="HTML&#x2F;CSS 风格指南"></a>HTML&#x2F;CSS 风格指南</h2><h3 id="总体排版规则"><a href="#总体排版规则" class="headerlink" title="总体排版规则"></a>总体排版规则</h3><h4 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h4><p>每次缩进使用两个空格。不使用<code>TAB</code>键或混合使用<code>TAB</code>键和空格进行缩进。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Fantastic</span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Great</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.example</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="整体的元数据规则"><a href="#整体的元数据规则" class="headerlink" title="整体的元数据规则"></a>整体的元数据规则</h3><h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p>使用<strong>UTF-8</strong>无BOM编码。</p>
<p>在 HTML 模板和文档中使用<code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>指定编码。不需要为样式表（css）指定编码，它默认是 UTF-8 。</p>
<blockquote>
<p>想要了解关于编码的知识，可查阅<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMzc4NzU2MTU=">unicode 编码简介<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>在需要时尽可能去解释你的代码，包括它的应用范围、用途、此方案的选择理由等。</p>
<h4 id="处理内容"><a href="#处理内容" class="headerlink" title="处理内容"></a>处理内容</h4><p>用 <strong>TODO</strong> 标记待办事宜和处理内容。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;# TODO(john.doe): 重新处理水平居中 #&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- <span class="doctag">TODO:</span> 移除可选的标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Apples<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Oranges<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="HTML-样式规则"><a href="#HTML-样式规则" class="headerlink" title="HTML 样式规则"></a>HTML 样式规则</h3><h4 id="文档类型"><a href="#文档类型" class="headerlink" title="文档类型"></a>文档类型</h4><p>使用 HTML5 。HTML5 是所有 HTML 文档的首选： <code>&lt;!DOCTYPE html&gt;</code> 。</p>
<h4 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a>语义化</h4><p>根据 HTML 的目的使用它。</p>
<p>根据元素（有时被错误的叫做“标签”）被创造的用途使用他们。比如，对标题使用标题元素，对段落使用<code>p</code>元素，对锚点使用<code>a</code>元素等。</p>
<p>语义化的使用HTML对于可访问性、复用性和代码的高效性等因素非常重要。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 不推荐 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;goToRecommendations();&quot;</span>&gt;</span>All recommendations<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 推荐 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;recommendations/&quot;</span>&gt;</span>All recommendations<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="多媒体降级"><a href="#多媒体降级" class="headerlink" title="多媒体降级"></a>多媒体降级</h4><p>为多媒体提供替代内容。</p>
<p>对于图片、视频、通过 <code>canvas</code> 实现的动画等多媒体来说，确保提供可访问的替代内容。对于图片，可提供有意义的替代文本（ <code>alt</code> ）；对于视频和音频，如有条件可提供对白和字幕。</p>
<p>提供替代内容对辅助功能很重要：没有 <code>alt</code> ，一位盲人用户很难知道一张图片的内容，其他用户可能不能了解视频和音频的内容。 （对于 <code>alt</code> 属性会引起冗余的图片和你不打算添加CSS的纯粹装饰性的图片，不用添加替代文本，写成 <code>alt=&quot;&quot;</code> 即可。）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 不推荐 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;spreadsheet.png&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 推荐 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;spreadsheet.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Spreadsheet screenshot.&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="关注点分离"><a href="#关注点分离" class="headerlink" title="关注点分离"></a>关注点分离</h4><p><strong>将结构、表现、行为分离。</strong></p>
<p>严格保持结构（标识），表现（样式），行为（脚本）分离，尽量使三者之间的相互影响最小。</p>
<p>就是说，确保文档和模板只包含HTML，并且HTML只用来表现结构。把任何表现性的东西都移到样式表，任何行为性的东西都移到脚本中。</p>
<p>此外，<em>尽可能少的从文档和模板中引用样式表和脚本来减少三者的相互影响</em>。</p>
<p>结构、表现、行为分离对维护非常重要。更改HTML文档和模板总是比更新样式表和脚本成本更高。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 不推荐 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>HTML sucks<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;base.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;grid.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;print.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;print&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 1em;&quot;</span>&gt;</span>HTML sucks<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>I’ve read about this on a few sites but now I’m sure:</span><br><span class="line">  <span class="tag">&lt;<span class="name">u</span>&gt;</span>HTML is stupid!!1<span class="tag">&lt;/<span class="name">u</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span>I can’t believe there’s no way to control the styling of</span><br><span class="line">  my website without doing everything all over again!<span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 推荐 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>My first CSS-only redesign<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;default.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>My first CSS-only redesign<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>I’ve read about this on a few sites but today I’m actually</span><br><span class="line">  doing it: separating concerns and avoiding anything in the HTML of</span><br><span class="line">  my website that is presentational.</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>It’s awesome!</span><br></pre></td></tr></table></figure>

<h4 id="type-属性"><a href="#type-属性" class="headerlink" title="type 属性"></a>type 属性</h4><p>为样式表和脚本省略 <code>type</code> 属性。</p>
<p>引用样式表（除非不是使用CSS）和脚本（除非不是使用JavaScript）不要使用type属性。</p>
<p>HTML5将 text&#x2F;css 和 text&#x2F;javascript 设置为默认值，在这种情况下指定type属性并不必要。甚至同样兼容老版本的浏览器。</p>
<h3 id="HTML-格式规则"><a href="#HTML-格式规则" class="headerlink" title="HTML 格式规则"></a>HTML 格式规则</h3><h4 id="常规格式化"><a href="#常规格式化" class="headerlink" title="常规格式化"></a>常规格式化</h4><p>对每个块、列表、表格元素都另起一行，每个子元素都缩进。</p>
<p>每个块元素、列表元素或表格元素另起一行，而不必考虑元素的样式（因CSS可以改变元素的 <code>display</code> 属性）。</p>
<p>同样的，如果他们是块、列表或者表格元素的子元素，则将之缩进。</p>
<p>（如果你遇到列表项之间有空白的问题，可以把所有 <code>li</code> 元素放到一行。Linter鼓励抛出警告而不是错误。）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>Space<span class="tag">&lt;/<span class="name">em</span>&gt;</span>, the final frontier.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Moe</span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Larry</span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Curly</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">&quot;col&quot;</span>&gt;</span>Income</span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">&quot;col&quot;</span>&gt;</span>Taxes</span><br><span class="line">  <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>$ 5.00</span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>$ 4.50</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="CSS-样式规则"><a href="#CSS-样式规则" class="headerlink" title="CSS 样式规则"></a>CSS 样式规则</h3><h4 id="id-与-class-的命名"><a href="#id-与-class-的命名" class="headerlink" title="id 与 class 的命名"></a>id 与 class 的命名</h4><p>使用有意义的或者通用的id和class名称</p>
<p>用能反映出元素目的或者通用的id、class名称，代替那些很表象的、难懂的名称。</p>
<p>如果名称需要是易懂的，或不容易被修改，应该首选特定的或者能反映出元素目的的名称。</p>
<p>通用的名称适用于非特殊元素或与兄弟元素无区别的元素。他们常被称为“辅助元素”。</p>
<p>使用功能性或者通用的名称，可减少不必要的文档或者模板变化。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 不推荐：无意义 */</span></span><br><span class="line"><span class="selector-id">#yee-1901</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 不推荐：表象 */</span></span><br><span class="line"><span class="selector-class">.button-green</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.clear</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 推荐：具体的 */</span></span><br><span class="line"><span class="selector-id">#gallery</span> &#123;&#125;</span><br><span class="line"><span class="selector-id">#login</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.video</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 推荐：通用的 */</span></span><br><span class="line"><span class="selector-class">.aux</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.alt</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="id与class的命名规范"><a href="#id与class的命名规范" class="headerlink" title="id与class的命名规范"></a>id与class的命名规范</h4><p>ID和class命名要尽可能简短，但必要的话就别怕长。</p>
<p>尽可能简洁地传达id或者class名称的含义。</p>
<p>使用简洁的id或者class名称有助于提高可读性和代码效率。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 不推荐 */</span></span><br><span class="line"><span class="selector-id">#navigation</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.atr</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 推荐 */</span></span><br><span class="line"><span class="selector-id">#nav</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.author</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="简写属性"><a href="#简写属性" class="headerlink" title="简写属性"></a>简写属性</h4><p>尽可能使用简写的属性书写方式。</p>
<p>CSS提供了多种属性<strong>简写</strong>的方式（如 <code>font</code> ），即使只显式设置一个值，也应该尽可能地使用。</p>
<p>使用简写属性有助于提高代码效率及可读性。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 不推荐 */</span></span><br><span class="line"><span class="attribute">border-top-style</span>: none;</span><br><span class="line"><span class="attribute">font-family</span>: palatino, georgia, serif;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">line-height</span>: <span class="number">1.6</span>;</span><br><span class="line"><span class="attribute">padding-bottom</span>: <span class="number">2em</span>;</span><br><span class="line"><span class="attribute">padding-left</span>: <span class="number">1em</span>;</span><br><span class="line"><span class="attribute">padding-right</span>: <span class="number">1em</span>;</span><br><span class="line"><span class="attribute">padding-top</span>: <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 推荐 */</span></span><br><span class="line"><span class="attribute">border-top</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">font</span>: <span class="number">100%</span>/<span class="number">1.6</span> palatino, georgia, serif;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">0</span> <span class="number">1em</span> <span class="number">2em</span>;</span><br></pre></td></tr></table></figure>

<h4 id="id与class名称分隔符"><a href="#id与class名称分隔符" class="headerlink" title="id与class名称分隔符"></a>id与class名称分隔符</h4><p>用连字符分隔ID和类名中的单词。</p>
<p>选择器中的词语和缩写中不要使用除了连字符以外的任何字符（包括空字符），以提高可理解性和可读性。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 不推荐: 单词未分开 */</span></span><br><span class="line"><span class="selector-class">.demoimage</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 不推荐：使用下划线而不是连字符 */</span></span><br><span class="line"><span class="selector-class">.error_status</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 推荐 */</span></span><br><span class="line"><span class="selector-id">#video-id</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.ads-sample</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CSS-格式化规则"><a href="#CSS-格式化规则" class="headerlink" title="CSS 格式化规则"></a>CSS 格式化规则</h3><h4 id="声明顺序"><a href="#声明顺序" class="headerlink" title="声明顺序"></a>声明顺序</h4><p>按字母顺序排列声明。</p>
<p>css文件书写按字母顺序排列的方式，容易记忆和维护，以达到一致的代码。</p>
<p>在排序时忽略浏览器特定的前缀。但是，特定CSS属性的多个浏览器前缀应按字母顺序排列（如-moz书写在-webkit前面）。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>: fuchsia;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">-moz-<span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">-webkit-<span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line"><span class="attribute">color</span>: black;</span><br><span class="line"><span class="attribute">text-align</span>: center;</span><br><span class="line"><span class="attribute">text-indent</span>: <span class="number">2em</span>;</span><br></pre></td></tr></table></figure>

<h4 id="块内容的缩进"><a href="#块内容的缩进" class="headerlink" title="块内容的缩进"></a>块内容的缩进</h4><p>缩进块内容。</p>
<p>将包括嵌套及声明的 块内容 进行缩进，以体现层次并提高可读性。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen, projection &#123;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#444</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CSS属性名结束"><a href="#CSS属性名结束" class="headerlink" title="CSS属性名结束"></a>CSS属性名结束</h4><p>属性名称的冒号后有一个空格。</p>
<p>为保证一致性，在属性名与属性值之间添加一个空格（但是属性名和冒号间没有空格）。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 不推荐 */</span></span><br><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>:bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 推荐 */</span></span><br><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="声明块间隔"><a href="#声明块间隔" class="headerlink" title="声明块间隔"></a>声明块间隔</h4><p>在选择器和后面的声明块之间使用一个空格。</p>
<p>最后一个选择器与表示 声名块 开始的左大花括号在同行，中间有一个字符空格。</p>
<p>表示开始的左大花括号和选择器在同行。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 不推荐：缺少空间 */</span></span><br><span class="line"><span class="selector-id">#video</span>&#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 不推荐：不必要的换行符 */</span></span><br><span class="line"><span class="selector-id">#video</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 推荐 */</span></span><br><span class="line"><span class="selector-id">#video</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CSS代码块分离"><a href="#CSS代码块分离" class="headerlink" title="CSS代码块分离"></a>CSS代码块分离</h4><p>使用新空行分离规则。</p>
<p>始终把一个空行（两个换行符）放在代码块规则之间。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CSS元规则"><a href="#CSS元规则" class="headerlink" title="CSS元规则"></a>CSS元规则</h3><h4 id="分段规则"><a href="#分段规则" class="headerlink" title="分段规则"></a>分段规则</h4><p>组的分段由一段注释完成（可选）。</p>
<p>尽可能地用注释来将css分段，段与段之间采用新行。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Header */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#adw-header</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Footer */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#adw-footer</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Gallery */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.adw-gallery</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="赠言"><a href="#赠言" class="headerlink" title="赠言"></a>赠言</h3><p>请与周围保持一致。</p>
<p>如果你正在编辑代码，花几分钟时间看看上下文代码的格式，确定他们的编码风格。如果在上下文代码中，算术运算符前后有空格，或注释前后添加了“#”，你也应该这样做。</p>
<p>编写这个风格指导的目标是让人们可以专注于“我们在讨论什么”而不是“我们该怎么描述”。我们提供了一些通用的编码规范，大家就可以基于这些规范而继续，但特定情况下的规范也同样重要。如果你在一个文件中添加的代码看上去跟其他代码明显不同，你就把阅读此文件的人的节奏打乱了。避免这种情况出现。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="%22https://zh-google-styleguide.readthedocs.io/en/latest/contents/%22">Google 开源项目风格指南</a></p>
]]></content>
      <categories>
        <category>recruitment</category>
      </categories>
      <tags>
        <tag>style</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode 下的 PR 流程</title>
    <url>/2023/10/26/vscode-PR/</url>
    <content><![CDATA[<h2 id="VSCode-下的-PR-流程"><a href="#VSCode-下的-PR-流程" class="headerlink" title="VSCode 下的 PR 流程"></a>VSCode 下的 PR 流程</h2><ol>
<li>VSCode 安装 <code>Github Pull Request 插件</code><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202310261942360.png"></li>
<li>于源代码管理处点击<code>创建拉取请求</code><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202310261943040.png"></li>
<li>提交 PR 后等待其余协同开发者审核<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202310261945217.png"></li>
</ol>
<span id="more"></span>

<h2 id="Commit-x2F-PR-规范"><a href="#Commit-x2F-PR-规范" class="headerlink" title="Commit&#x2F;PR 规范"></a>Commit&#x2F;PR 规范</h2><blockquote>
<p>参考：Angular commit 规范</p>
</blockquote>
<p>提交信息包括三个部分：</p>
<ul>
<li>Header</li>
<li>Body</li>
<li>footer<br>其中 header 为必填，其余可省略</li>
</ul>
<h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>Header 部分只有一行，包含两个字段，均必填</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;type&gt;: &lt;subject&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>type：说明 commit 的类别，可以使用如下类别</li>
</ol>
<ul>
<li>feat：新功能（feature）</li>
<li>fix：修补 bug</li>
<li>doc：文档（documentation）</li>
<li>refactor：重构（不属于 feat 和 fix 的代码变动）</li>
<li>test：增加测试</li>
<li>chore：构建过程或辅助工具的变动</li>
</ul>
<ol start="2">
<li>subject：对 commit 目的的简短描述</li>
</ol>
<ul>
<li>以动词开头，使用第一人称现在时（改变 √ 改变了 ×）</li>
<li>结尾不加句号（。）</li>
</ul>
<h3 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h3><p>Body 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">More detailed explanatory text, if necessary.  Wrap it to </span><br><span class="line">about 72 characters or so. </span><br><span class="line"></span><br><span class="line">Further paragraphs come after blank lines.</span><br><span class="line"></span><br><span class="line">- Bullet points are okay, too</span><br><span class="line">- Use a hanging indent</span><br></pre></td></tr></table></figure>

<p>注意：应注意代码变动的动机，以及与以前行为的对比</p>
<h3 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h3><p>Footer 部分应该包含：</p>
<ol>
<li>Breaking Changes</li>
<li>关闭 issue</li>
</ol>
<h4 id="Breaking-Changes"><a href="#Breaking-Changes" class="headerlink" title="Breaking Changes"></a>Breaking Changes</h4><p>如果当前代码与上一个版本不兼容，则 Footer 部分以 BREAKING CHANGE 开头，后面是对变动的描述、以及变动理由和迁移方法。</p>
<h4 id="issue"><a href="#issue" class="headerlink" title="issue"></a>issue</h4><ol>
<li>通过 commit 关联 issue ：如果当前提交信息关联了某个issue，那么可以在 Footer 部分关联这个 issue：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">issue #2</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过commit关闭issue，当提交到默认分支时，提交信息里可以使用 fix&#x2F;fixes&#x2F;fixed , close&#x2F;closes&#x2F;closed 或者 resolve&#x2F;resolves&#x2F;resolved等关键词，后面为 issue 编号，关闭对应Issue：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Closes #1</span><br></pre></td></tr></table></figure>

<p>注意：如果不是提交到默认分支，那么并不能关闭这个issue，但是在这个issue下面会显示相关的信息表示曾经想要关闭这个issue，当这个分支合并到默认分支时，就可以关闭这个issue了。</p>
<h2 id="PR-模板"><a href="#PR-模板" class="headerlink" title="PR 模板"></a>PR 模板</h2><p>推荐路径：<code>.github/pull_request_template.md</code></p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="section"># PR 标题</span></span><br><span class="line">&lt;!-- </span><br><span class="line">格式为 type：subject（中文分号）</span><br><span class="line"><span class="bullet">-</span> type：说明 commit 的类别，可以使用如下类别</span><br><span class="line"><span class="bullet">-</span> - feat：新功能（feature）</span><br><span class="line"><span class="bullet">-</span> - fix：修复 bug</span><br><span class="line"><span class="bullet">-</span> - doc：文档（documentation）</span><br><span class="line"><span class="bullet">-</span> - refactor：重构（不属于 feat 和 fix 的代码变动）</span><br><span class="line"><span class="bullet">-</span> - build：构建打包</span><br><span class="line"><span class="bullet">-</span> - test：增加测试</span><br><span class="line"><span class="bullet">-</span> - chore：构建过程或辅助工具的变动</span><br><span class="line"><span class="bullet">-</span> - revert：恢复</span><br><span class="line"><span class="bullet">-</span> subject：对 commit/PR 目的的简短描述</span><br><span class="line"><span class="bullet">-</span> - 以动词开头，使用第一人称现在时（改变 √ 改变了 ×）</span><br><span class="line"><span class="bullet">-</span> - 结尾不加句号（。）</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line">feat：添加实时表格</span><br><span class="line">bug：修复实时表格小数点位问题</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line"><span class="section">## 内容</span></span><br><span class="line">&lt;!-- </span><br><span class="line">是对本次 commit 的详细描述，可以分成多行。下面是一个范例</span><br><span class="line"></span><br><span class="line">More detailed explanatory text, if necessary.  Wrap it to </span><br><span class="line">about 72 characters or so. </span><br><span class="line"></span><br><span class="line">Further paragraphs come after blank lines.</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> Bullet points are okay, too</span><br><span class="line"><span class="bullet">-</span> Use a hanging indent</span><br><span class="line"></span><br><span class="line">应注意代码变动的动机、与以前行为的对比</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line"><span class="section">## 影响范围</span></span><br><span class="line">&lt;!-- </span><br><span class="line">描述这个PR对现有代码的影响。例如：</span><br><span class="line"><span class="bullet">  -</span> 影响哪些组件或功能</span><br><span class="line"><span class="bullet">  -</span> 是否引入了任何可能的性能问题</span><br><span class="line"><span class="bullet">  -</span> 是否有任何向后兼容的问题 </span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line"><span class="section">## 附加信息</span></span><br><span class="line">&lt;!-- </span><br><span class="line">包含 Breaking Changes 和关闭 issue</span><br><span class="line"><span class="bullet">-</span> Breaking Changes： 当前代码是否与上一个版本不兼容，如有，需包含对变动的描述、以及变动理由和迁移方法</span><br><span class="line"><span class="bullet">-</span> issue：是否有关联的 issue，是否需关闭 issue</span><br><span class="line"><span class="bullet">-</span> - 关联 issue ： issue #42</span><br><span class="line"><span class="bullet">-</span> - 关闭 issue ： closes #42</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line"><span class="section">## 请求审查</span></span><br><span class="line">&lt;!-- @提及需要审查这个PR的团队成员或团队。 --&gt;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202312071711649.png"></p>
]]></content>
      <categories>
        <category>experience</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
</search>
