<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>一些建议</title>
    <url>/2023/07/28/advice/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
<p>I know nothing except the fact of my ignorance。<br>我唯一知道的就是我一无所知</p>

</blockquote>

<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>下列建议都出自同一个前提：各位同学对编程0基础</p>
<h3 id="计算机概览"><a href="#计算机概览" class="headerlink" title="计算机概览"></a>计算机概览</h3><p><strong>推荐阅读：</strong><br><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8zMDIwMDI0OC8=">普林斯顿大学计算机公开课<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>理由：</strong><br>通俗易懂，零基础入门，包含绝大部分所需要了解的基础知识</p>
<span id="more"></span>

<h3 id="前端编程入门"><a href="#前端编程入门" class="headerlink" title="前端编程入门"></a>前端编程入门</h3><p><strong>推荐观看：</strong><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXZzNDExTTdhVA==">为初学者准备的：HTML 速成<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWJXNDExUjdoZw==">为初学者准备的：CSS 速成<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMUp0NDExRDdqNg==">为初学者准备的：JavaScript 速成<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>理由：</strong><br>足够精练，两小时通览上手的必备知识。从实践中学习，是软件工程的精髓所在。</p>
<h3 id="后端编程入门"><a href="#后端编程入门" class="headerlink" title="后端编程入门"></a>后端编程入门</h3><p><strong>推荐阅读：</strong><br><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8yNjc5MjUyMS8=">C Primer Plus（第6版）中文版<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>理由：</strong><br>风趣幽默，无需预备知识。无论是浅尝辄止或反复品味都非常推荐。</p>
<h3 id="行业背景"><a href="#行业背景" class="headerlink" title="行业背景"></a>行业背景</h3><p><strong>推荐阅读：</strong><br><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8zMzQ3NDc1MC8=">浪潮之巅（第四版）（上下册）<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>理由：</strong><br>技术决定下限，变革的思想定义上限。</p>
<h2 id="一些小建议"><a href="#一些小建议" class="headerlink" title="一些小建议"></a>一些小建议</h2><ul>
<li>快速学习。网课、书籍、文档各有利弊，智者见智，快速入门后投入实践才是王道。<strong>实践是检验真理的唯一标准。</strong></li>
<li>保持谦逊。<strong>永远不要说自己精通。</strong></li>
<li>大胆提问。不耻上问，但要注意提问的礼仪。</li>
<li>劳逸结合。不做过多评价卷与躺，选择最适合自己的方式度过大学便可。人生有梦，各自精彩，永不要用同一个标杆衡量所有人。<strong>不是每一个人都有你所拥有的条件。</strong></li>
</ul>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>experience</category>
      </categories>
      <tags>
        <tag>csu</tag>
        <tag>advice</tag>
        <tag>university</tag>
        <tag>software engineering</tag>
        <tag>frontend</tag>
        <tag>backend</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络笔记</title>
    <url>/2023/10/08/computer-network/</url>
    <content><![CDATA[<blockquote>
<p> 参考书籍：计算机网络——自顶向下方法（原书第 8 版）</p>
</blockquote>
<span id="more"></span>

<h2 id="第-1-章-计算机网络和因特网"><a href="#第-1-章-计算机网络和因特网" class="headerlink" title="第 1 章 计算机网络和因特网"></a>第 1 章 计算机网络和因特网</h2><p>端系统（end system）通过通信链路（communication link）和分组交换机（packet switch）的网络连接到一起。</p>
<p>端系统通过因特网服务提供商（Internet Service Provider，ISP）接入因特网。每一个 ISP 网络都是独立管理的。</p>
<ul>
<li>TCP（Transmission Control Protocol，传输控制协议）</li>
<li>IP（Internet Protoc，网络协议）</li>
</ul>
<p>分布式应用（distributed application）：涉及多个相互交换数据的端系统。</p>
<p>与因特网相连的端系统提供了一个套接字接口（socket interface），因特网套接字接口是一套发送程序必须遵循的规则集合。</p>
<p>为了完成一项工作，要求两个（或多个）通信实体运行相同的协议。<br>&#x2F;&#x2F; TODO：附图计算机网络协议 P5</p>
<p><strong>向一个 Web 服务器发出请求（即在 Web 浏览器中键入一个 Web 网页的 URL）所发生的情况</strong>：<br>首先，计算机向该 Web 服务器发送一条连接请求报文，并等待回答。该 Web 服务器最终能接收到连接请求报文，并返回一条连接响应报文。得知请求该 Web 文档正常后，计算机则在一条 GET 报文中发送该网页的名字，而该网页的名字要从这台 Web 服务器上取回。最后，Web 服务器向你的计算机返回该 Web 网页（文件）。</p>
<p>协议（protocol）定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文的发送&#x2F;接收或其他事件所采取的操作。</p>
<p>WiFi：基于 IEEE 802.11 技术的无线 LAN（局域网）接入</p>
<p>为了从源端系统向目的端系统发送一个报文（message），源将长报文划分为较小的数据块，称为分组（packet）。在源和目的地之间，每个分组都通过通信链路（communication link）和分组交换机（packet switch）传送，交换机主要有路由器（router）和链路层交换机（link-layer switch）两类。</p>
<p>存储转发传输（store-and-forward transmission）：交换机在开始向输出链路传输该分组的第一个比特之前，必须接受到整个分组。</p>
<p>分组交换机具有一个输出缓存【output buffer，也称为输出队列（output queue）】，缓存充满时将出现分组丢失（丢包）（packet loss），到达的分组或已经排队的分组之一将被丢弃。</p>
<p>转发表（forwarding table）用于将目的地址（或目的地址的一部分）映射为输出链路。</p>
<p>通过网络链路和交换机移动数据有两种基本方法：电路交换（circuit switching）和分组交换（packet switching）。<br>在电路交换网络中，在端系统间通信会话期间，预留了端系统间沿路径通信所需要的资源（缓存，链路传输速率）。在分组交换网络中，这些数据不是预留的。<br>因特网尽最大努力以及时方式交付分组，但它不做任何保证。</p>
<p><strong>电路交换网络中的复用</strong></p>
<ul>
<li>频分复用（Frequency-Division Multiplexing, FDM）：链路的频谱由跨越链路创建的所有连接共享。特别是，在连接期间为每条连接专设一个频段。该频段的宽度称为带宽（band-width）。</li>
<li>时分复用（Time-Division Multiplexing, TDM）：时间被划分为固定的帧，而且每个帧又被划分为固定数量的时隙。当网络跨越链路创建一条连接时，网络在每个帧中为该连接指定一个时隙。</li>
</ul>
<p>电路交换不够经济：静默期 （silent period）专用电路是空闲的。</p>
<p>端到端电路传输时间与链路数量无关。</p>
<p>对比：</p>
<ol>
<li>分组交换不适合实时服务</li>
<li>比电路交换更好的带宽共享，更简单有效，实现成本更低</li>
</ol>
<p>&#x2F;&#x2F; TODO：ISP 互联图</p>
<p>位于相同等级结构层次的临近的一对 ISP 能够对等（peer），当两个 ISP 对等时，为减少费用通常不进行结算，即任何一个 ISP 都不对其对等付费。<br>因特网交换点（Internet Exchange Point，IXP）是一个汇合点，多个 ISP 能够在这里一起对等。<br>谷歌专用网络通过与较低层 ISP 对等（无结算），尝试“绕过”互联网的较高层。通过创建自己的网络，内容提供商不仅减少了向顶层 ISP 支付的费用，而且对其服务最终如何交付给端用户有了更多的控制。</p>
<p>节点总时延（total nodal delay）：</p>
<ul>
<li>节点处理时延（nodal processing delay）</li>
<li>排队时延（queuing delay）</li>
<li>传输时延（transmission delay）</li>
<li>传播时延（propagation delay）<br>传输时延事路由器推出分组所需要的时间，它是分组长度和链路传输速率的函数，而与两台路由器之间的距离无关。而传播时延是一个比特从一台路由器传播到另一台路由器所需要的时间，它是两台路由器之间的距离的函数，与分组长度或链路传输速率无关。</li>
</ul>
<p>排队时延很大程度取决于流量到达队列的速率、链路的传输速率和到达流量的性质，即流量是周期性到达还是以突发形式到达。</p>
<p>a - 分组到达队列的平均速率（分组&#x2F;秒，pkt&#x2F;s）<br>R - 传输速率，即从队列中推出比特的速率（bps）<br>假设所有分组由 L bit 组成，则比特到达队列的平均速率是<code>La bps</code>，流量强度（traffic intensity）为<code>La/R</code><br><em>sh</em></p>
]]></content>
      <categories>
        <category>GEE</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>computer network</tag>
      </tags>
  </entry>
  <entry>
    <title>git 报错 empty reply 或 time out</title>
    <url>/2024/02/16/git-proxy/</url>
    <content><![CDATA[<h2 id="Windows-设置-git-代理"><a href="#Windows-设置-git-代理" class="headerlink" title="Windows 设置 git 代理"></a>Windows 设置 git 代理</h2><h3 id="查看代理地址和端口"><a href="#查看代理地址和端口" class="headerlink" title="查看代理地址和端口"></a>查看代理地址和端口</h3><ol>
<li>打开控制面板</li>
<li>选择网络和Internet</li>
<li>选择Internet选项</li>
<li>弹出窗口中选择连接选项卡</li>
<li>连接选项卡中选择局域网设置<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202402161202079.png"></li>
<li>查看代理服务器设置（默认为<strong>本机地址7890端口</strong>）<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202402161203307.png"></li>
</ol>
<span id="more"></span>

<h3 id="git-代理命令"><a href="#git-代理命令" class="headerlink" title="git 代理命令"></a>git 代理命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:7890</span><br><span class="line"><span class="comment"># http://127.0.0.1:7890 替换为你的代理服务器地址</span></span><br></pre></td></tr></table></figure>

<p>也可以用如下命令修改文本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global -e </span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tvcHJ2aGRpeC9hcnRpY2xlL2RldGFpbHMvODc1Mzc5NTY=">GitHub 无法连接问题<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>vpn</tag>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构笔记</title>
    <url>/2023/09/27/data-structure-in-c/</url>
    <content><![CDATA[<blockquote>
<p>参考书籍：数据结构与算法分析（C语言描述） 原书第二版</p>
</blockquote>
<span id="more"></span>

<h2 id="第-1-章-引论"><a href="#第-1-章-引论" class="headerlink" title="第 1 章 引论"></a>第 1 章 引论</h2><p>递归的四条基本法则</p>
<ul>
<li><strong>基准情形</strong>：不用递归就能求解</li>
<li><strong>不断推进</strong>：递归调用必须能够朝着产生基本情形的方向推进</li>
<li><strong>设计法则</strong>：假设所有的递归调用都能运行</li>
<li><strong>合成效益法则</strong>（compound interest rule）：在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作</li>
</ul>
<h2 id="第-2-章-算法分析"><a href="#第-2-章-算法分析" class="headerlink" title="第 2 章 算法分析"></a>第 2 章 算法分析</h2><blockquote>
<p>计算任何事情不要超过一次</p>
</blockquote>
<h3 id="最大子序列和"><a href="#最大子序列和" class="headerlink" title="最大子序列和"></a>最大子序列和</h3><h4 id="算法1"><a href="#算法1" class="headerlink" title="算法1"></a>算法1</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MaxSubsequenceSum</span><span class="params">(<span class="type">const</span> <span class="type">int</span> A[], <span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ThisSum, MaxSum, i, j, k;</span><br><span class="line">    </span><br><span class="line">    MaxSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &lt; N; j++) &#123;</span><br><span class="line">            ThisSum = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (k = i; k &lt;= j; k++)&#123;</span><br><span class="line">                ThisSum += A[k];    <span class="comment">/* 过分耗时 */</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(ThisSum &gt; MaxSum) &#123;</span><br><span class="line">                MaxSum = ThisSum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MaxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度为<code>O(N*3)</code></p>
<h4 id="算法2"><a href="#算法2" class="headerlink" title="算法2"></a>算法2</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MaxSubSequenceSum</span><span class="params">(<span class="type">const</span> <span class="type">int</span> A[], <span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ThisSum, MaxSum, i, j;</span><br><span class="line"></span><br><span class="line">    MaxSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        ThisSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(j = i; j &lt; N; j++) &#123;</span><br><span class="line">            ThisSum += A[j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ThisSum &gt; MaxSum) &#123;</span><br><span class="line">                MaxSum = ThisSum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MaxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度为<code>O(N*2)</code></p>
<h4 id="算法3"><a href="#算法3" class="headerlink" title="算法3"></a>算法3</h4><p>分析知最大子序列和可能在三处出现，或者整个出现在输入数据的左半部，或者整个出现在右半部，或者跨越输入数据的中部从而占据左右两半部分。前两种情况可以递归求解，第三种情况的最大和可以通过求出前半部分的最大和（包括前半部分的最后一个元素）以及后半部分的最大和（包括后半部分的第一个元素）而得到。</p>
<p><strong>递归调用的一般形式是通过传递输入的数组以及左（Left）边界和右（Right）边界，它们界定了数组待处理的部分。单行驱动程序通过传递数组以及边界 0 和 N-1 以启动该过程。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">MaxSubSum</span><span class="params">(<span class="type">const</span> <span class="type">int</span> A[], <span class="type">int</span> Left, <span class="type">int</span> Right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> MaxLeftSum, MaxRightSum;</span><br><span class="line">    <span class="type">int</span> MaxLeftBorderSum, MaxRightBorderSum;</span><br><span class="line">    <span class="type">int</span> LeftBorderSum, RightBorderSum;</span><br><span class="line">    <span class="type">int</span> Center, i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Base Case</span></span><br><span class="line">    <span class="keyword">if</span>(Left == Right) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[Left] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> A[Left];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Center = (Left + Right)/<span class="number">2</span>;  <span class="comment">// assume N is even</span></span><br><span class="line">    MaxLeftSum = MaxSubSum(A, Left, Center);</span><br><span class="line">    MaxRightSum = MaxSubSum(A, Center + <span class="number">1</span>; right);</span><br><span class="line"></span><br><span class="line">    MaxLeftBorderSum = <span class="number">0</span>; LeftBorderSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = Center; i &gt;= Left; i--) &#123;</span><br><span class="line">        LeftBorderSum += A[i];</span><br><span class="line">        <span class="keyword">if</span>(LeftBorderSum &gt; MaxLeftBorderSum) &#123;</span><br><span class="line">            MaxLeftBorderSum = LeftBorderSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MaxRightBorderSum = <span class="number">0</span>; RightBorderSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = Center + <span class="number">1</span>; i &lt;= Right; i++) &#123;</span><br><span class="line">        RightBorderSum += A[i];</span><br><span class="line">        <span class="keyword">if</span>(RightBorderSum &gt; MaxRightBorderSum) &#123;</span><br><span class="line">            MaxRightBorderSum = RightBorderSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Max3(MaxLeftSum, MaxRightSum, MaxLeftBorderSum, MaxRightBorderSum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">MaxSubsequenceSum</span><span class="params">(<span class="type">const</span> <span class="type">int</span> A[], <span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MaxSubSum(A, <span class="number">0</span>, N - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度为<code>O(N)</code></p>
<h4 id="算法4"><a href="#算法4" class="headerlink" title="算法4"></a>算法4</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MaxSubsequenceSum</span><span class="params">(<span class="type">const</span> <span class="type">int</span> A[], <span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ThisSum, MaxSum, j;</span><br><span class="line"></span><br><span class="line">    ThisSum = MaxSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">        ThisSum += A[j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ThisSum &gt; MaxSum) &#123;</span><br><span class="line">            MaxSum = ThisSum;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ThisSum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ThisSum = <span class="number">0</span>;    <span class="comment">// clear ThisSum when negative</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MaxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在任意时刻，算法都能对它已经读入的数据给出子序列问题的正确答案，具有这种特性的算法叫做<strong>联机算法</strong>（on-line algorithm）。仅需要常量空间并以线性时间运行的联机算法几乎是完美的算法。</p>
<h2 id="第-3-章-表、栈和队列"><a href="#第-3-章-表、栈和队列" class="headerlink" title="第 3 章 表、栈和队列"></a>第 3 章 表、栈和队列</h2><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _List_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> PtrToNode List;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode Position;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"></span><br><span class="line">List <span class="title function_">MakeEmpty</span><span class="params">(List L)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmpty</span><span class="params">(List L)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">IsLast</span><span class="params">(Position P, List L)</span>;</span><br><span class="line">Position <span class="title function_">Find</span><span class="params">(ElementType X, List L)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Delete</span><span class="params">(ElementType X, List L)</span>;</span><br><span class="line">Position <span class="title function_">FindPrevious</span><span class="params">(ElementType X, List L)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">(ElementType X, List L, Position P)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DeleteList</span><span class="params">(List L)</span>;</span><br><span class="line">Position <span class="title function_">Header</span><span class="params">(List L)</span>;</span><br><span class="line">Position <span class="title function_">First</span><span class="params">(List L)</span>;</span><br><span class="line">Position <span class="title function_">Advance</span><span class="params">(Position P)</span>;</span><br><span class="line">ElementType <span class="title function_">Retrieve</span><span class="params">(Position P)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">/* _List_H */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Place in the implementation file</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Element;</span><br><span class="line">    Position Next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return true if L is empty</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmpty</span><span class="params">(List L)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> L-&gt;Next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return true if P is the last position in list L</span></span><br><span class="line"><span class="comment">// Parameter L is unused in this implementation</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsLast</span><span class="params">(Position P, List L)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> P-&gt;Next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return Position of X in L; NULL if not found</span></span><br><span class="line">Position <span class="title function_">Find</span><span class="params">(ElementType X, List L)</span> &#123;</span><br><span class="line">    Position P;</span><br><span class="line"></span><br><span class="line">    P = L-&gt;Next;</span><br><span class="line">    <span class="keyword">while</span>(P != <span class="literal">NULL</span> &amp;&amp; P-&gt;Element != X) &#123;</span><br><span class="line">        P = P-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete first occurrence of X from a list</span></span><br><span class="line"><span class="comment">// Assume use of a header node</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delete</span><span class="params">(ElementType X, List L)</span> &#123;</span><br><span class="line">    Position P, TempCell;</span><br><span class="line"></span><br><span class="line">    P = FindPrevious(X, L);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!IsLast(P, L)) &#123;</span><br><span class="line">        <span class="comment">// Assumption of header use</span></span><br><span class="line">        <span class="comment">// X is found, delete it</span></span><br><span class="line">        TempCell = P-&gt;Next;</span><br><span class="line">        P-&gt;Next = TempCell-&gt;Next; <span class="comment">// Bypass deleted cell</span></span><br><span class="line">        <span class="built_in">free</span>(TempCell);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If X is not found, then next field of returned</span></span><br><span class="line"><span class="comment">// Position is NULL</span></span><br><span class="line"><span class="comment">// Assumes a header</span></span><br><span class="line">Position <span class="title function_">FindPrevious</span><span class="params">(ElementType X, List L)</span> &#123;</span><br><span class="line">    Position P;</span><br><span class="line"></span><br><span class="line">    P = L;</span><br><span class="line">    <span class="keyword">while</span>(P-&gt;Next != <span class="literal">NULL</span> &amp;&amp; P-&gt;Next-&gt;Element != X) &#123;</span><br><span class="line">        P = P-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert (after legal position P)</span></span><br><span class="line"><span class="comment">// Header implementation assumed</span></span><br><span class="line"><span class="comment">// Parameter L is unused in this implementation</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">(ElementType X, List L, Position P)</span> &#123;</span><br><span class="line">    Position TmpCell;</span><br><span class="line"></span><br><span class="line">    TmpCell = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    <span class="keyword">if</span>(TmpCell == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        FatalError(<span class="string">&quot;Out of space!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TmpCell-&gt;Element = X;</span><br><span class="line">    TmpCell-&gt;Next = P-&gt;Next;</span><br><span class="line">    P-&gt;Next = TmpCell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeleteList</span><span class="params">(List L)</span> &#123;</span><br><span class="line">    Position P, Tmp;</span><br><span class="line"></span><br><span class="line">    P = L-&gt;Next;    <span class="comment">// Header assumed</span></span><br><span class="line">    L-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (P != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Tmp = P-&gt;Next;</span><br><span class="line">        <span class="built_in">free</span>(P);</span><br><span class="line">        P = Tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第-4-章-树"><a href="#第-4-章-树" class="headerlink" title="第 4 章 树"></a>第 4 章 树</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树的一个性质是<strong>平均二叉树的深度要比 N 小的多</strong>，这个平均深度为**O(根号 N)<strong>；对于二叉查找树（binary search tree），深度的平均值为</strong>O(log N)**。</p>
<h4 id="平均情形分析"><a href="#平均情形分析" class="headerlink" title="平均情形分析"></a>平均情形分析</h4><p>假设所有树出现的机会均等，则树的所有节点的平均深度为**O(log N)**。</p>
<ul>
<li>平衡条件：任何节点的深度均不得过深</li>
<li>放弃平衡条件，允许树有任意的深度，但是在每次操作之后要使用一个规则进行调整，使得后面的操作效率更高。<strong>自调查（self-adjusting）类结构</strong>。</li>
</ul>
<h3 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h3><p>一颗 AVL 树是其每个节点的左子树和右子树的高度最多差 1 的二叉查找树。（空树的高度定义为-1。）在高度为 h 的 AVL 树中，最少节点数 S(h) 由 S(h)&#x3D;S(h-1)+S(h-2)+1 给出。</p>
<p>插入一个节点可能破坏 AVL 树的特性，通过旋转进行修正。高度不平衡时，必须重新平衡的节点的两棵子树的高度差 2 。</p>
<h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p>把树形象地看成柔软灵活的，重力作用。<br>除旋转引起的局部变化外，树的其余部分必须知晓该变化。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>递归地将 X 插入到了 T 的相应的子树中。如果子树的高度不变，那么插入完成。否则，如果 T 中出现了高度不平衡，那么我们根据 X 以及 T 和子树中的关键字做适当的单旋转或双旋转，更新这些高度（并解决好与树的其余部分的连接），从而完成插入。</p>
<!-- TODO：寻找满意的旋转图 -->

<h3 id="伸展树"><a href="#伸展树" class="headerlink" title="伸展树"></a>伸展树</h3><p>伸展树（splay tree）保证从空树开始连续 M 次对树的操作最多花费 O(M log N) 时间，并不保证任意一次操作花费 O(N) 时间的可能。<em>不存在坏的输入序列</em>。<br><em>当 M 次操作的序列总的最坏情形运行时间为 O(MF(N)) 时，我们就说它的摊还（amortized）运行时间为 O(F(N))。</em>一颗伸展树每次操作的摊还代价为 O(log N) 。<br>伸展树是基于这样的事实：对于二叉查找树来说，每次操作最坏情形时间 O(N) 并不坏，只要它相对不常发生就行。累积的运行时间很重要。<br><em>只要有一个节点被访问，它就必须被移动。当一个节点被访问后，它就要经过一系列的 AVL 树的旋转后放到根上。</em><br>伸展树的基本想法是，当一个节点被访问后，它就要经过一系列 AVL 树的旋转后放到根上。伸展树不要求保留高度或平衡信息，因此它在某种程度上节省空间并简化代码。</p>
<h4 id="旋转-1"><a href="#旋转-1" class="headerlink" title="旋转"></a>旋转</h4><p>一种方法是执行单旋转，从下而上进行，将 k1 一直推向树根，使得对 k1 的进一步访问很容易（暂时的）。不足之处是它把另一个节点（k3）几乎推向和 k1 以前同样的深度，并没有明显地改变（原先）访问路径上其它节点的状况。<br>依序访问所有关键字后，该树转变回原始状态。</p>
<h4 id="展开"><a href="#展开" class="headerlink" title="展开"></a>展开</h4><p>展开（splaying）的实施有两种情况。令 X 是访问路径上的一个（非根）节点。若 X 的父节点是树根，则只需要旋转 X 和树根。否则， X 就有父亲（P）和祖父（G），存在两种情形以及对称的情形要考虑。</p>
<p><strong>之字形</strong></p>
<p>&#x2F;&#x2F; TODO： 图片</p>
<p><strong>一字型</strong></p>
<p>展开操作不仅将访问的节点移动到根处，而且还把访问路径上的大部分节点的深度大致减少一半。</p>
]]></content>
      <categories>
        <category>GEE</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js 笔记</title>
    <url>/2023/08/26/note-nodeJs/</url>
    <content><![CDATA[<h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><h3 id="Zero-Delay"><a href="#Zero-Delay" class="headerlink" title="Zero Delay"></a>Zero Delay</h3><p>如果指定超时延迟为 0 ，回调函数将尽快执行，但在当前函数执行之后：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;after &#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27; before &#x27;</span>);</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>该代码将打印</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">before</span><br><span class="line">after</span><br></pre></td></tr></table></figure>

<p>这对于避免在密集型任务上阻塞 CPU 并通过在调度程序中对函数进行排队来让其他函数在执行繁重计算时执行特别有用。</p>
<h3 id="Recursive-setTimeout"><a href="#Recursive-setTimeout" class="headerlink" title="Recursive setTimeout"></a>Recursive setTimeout</h3><p><code>setInterval</code> 每 n 毫秒启动一个函数，而不考虑函数何时完成执行。如果一个函数总是花费相同的时间，那就没问题；但也许一个长执行会与下一个执行重叠：</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308261059739.png"></p>
<p>为了避免这种情况，您可以安排在回调函数完成时调用递归 setTimeout：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">myFunction</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(myFunction, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(myFunction, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>为了实现这个场景：</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308261100968.png"></p>
<p>Node.js 还提供了 <code>setImmediate()</code> ，相当于使用 <code>setTimeout(() =&gt; &#123;&#125;</code>, 0) ，主要用于与 Node.js 事件循环配合使用。</p>
<h3 id="setImmediate"><a href="#setImmediate" class="headerlink" title="setImmediate()"></a>setImmediate()</h3><p><code>setImmediate()</code> 与 <code>setTimeout(() =&gt; &#123;&#125;, 0)</code> （传递 0 毫秒超时）以及 <code>process.nextTick() </code>和 <code>Promise.then()</code> 有何不同？</p>
<p>当前操作结束后，传递给 <code>process.nextTick()</code> 的函数将在事件循环的当前迭代中执行。这意味着它将始终在 <code>setTimeout</code> 和 <code>setImmediate</code> 之前执行。</p>
<p>延迟 0 毫秒的 <code>setTimeout()</code> 回调与 <code>setImmediate()</code> 非常相似。执行顺序将取决于各种因素，但它们都将在事件循环的下一次迭代中运行。</p>
<p><code>process.nextTick</code> 回调被添加到 <code>process.nextTick queue</code> 。 <code>Promise.then()</code> 回调被添加到 <code>promises microtask queue</code> 。 setTimeout 回调被添加到 <code>macrotask queue</code> 。</p>
<p>事件循环首先执行 <code>process.nextTick queue</code> 中的任务，然后执行 <code>promises microtask queue</code> ，然后执行 <code>macrotask queue</code> 。</p>
<p>下面是一个显示 <code>setImmediate()</code> 、 <code>process.nextTick()</code> 和 <code>Promise.then()</code> 之间顺序的示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">baz</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">zoo</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;zoo&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">start</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>);</span><br><span class="line">  <span class="title function_">setImmediate</span>(baz);  <span class="comment">// 3</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(resolve);</span><br><span class="line">    process.<span class="title function_">nextTick</span>(zoo);  <span class="comment">// 2</span></span><br><span class="line">  &#125;);</span><br><span class="line">  process.<span class="title function_">nextTick</span>(foo);  <span class="comment">// 1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">start</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// start foo bar zoo baz</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此代码将首先调用 <code>start()</code> ，然后调用 <code>process.nextTick queue</code> 中的 <code>foo()</code> 。之后，它将处理 <code>promises microtask queue</code> ，打印 <code>bar</code> 并同时在 <code>process.nextTick queue</code> 中添加 <code>zoo()</code> 。然后就会调用刚刚添加的 <code>zoo()</code> 。最终调用了 <code>macrotask queue</code> 中的 <code>baz()</code> 。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p>更应该说是摘抄自</p>
</blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMuZGV2L2VuL2xlYXJuL2Rpc2NvdmVyLWphdmFzY3JpcHQtdGltZXJzLw==">探索 JavaScript 定时器<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>前端实习面试问题准备</title>
    <url>/2023/12/07/note-interview/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="Node-js-单线程如何保证线程不中断？"><a href="#Node-js-单线程如何保证线程不中断？" class="headerlink" title="Node.js 单线程如何保证线程不中断？"></a>Node.js 单线程如何保证线程不中断？</h2><p>Node.js 被广泛认为是单线程的，但这个说法需要更准确的解释。Node.js 的主执行线程是单线程的，它运行在 V8 JavaScript 引擎上。然而，Node.js 使用多线程来处理 I&#x2F;O 密集型任务，这是通过其底层的 libuv 库实现的。以下是 Node.js 保证其单线程不中断的几个关键方面：</p>
<ol>
<li><p><strong>异步非阻塞 I&#x2F;O</strong>:</p>
<ul>
<li>Node.js 主要依靠事件循环和回调函数来处理 I&#x2F;O 操作（如文件读写、网络请求等），这些操作是异步和非阻塞的。</li>
<li>当一个 I&#x2F;O 操作开始时，它会被发送到事件循环，并继续执行后续的代码，而不是等待 I&#x2F;O 操作完成。当 I&#x2F;O 操作完成时，相应的回调函数会被放入事件队列中，等待主线程空闲时执行。</li>
</ul>
</li>
<li><p><strong>事件驱动架构</strong>:</p>
<ul>
<li>Node.js 使用事件驱动模型来处理各种异步操作。每当有事件发生时（如数据到达、超时、处理完成），相应的回调函数会被触发。</li>
<li>这种模型使得 Node.js 能够在不被阻塞的情况下高效地处理大量的并发请求。</li>
</ul>
</li>
<li><p><strong>libuv 库</strong>:</p>
<ul>
<li>尽管 JavaScript 代码在单个主线程上运行，Node.js 使用 libuv 库在背后管理一个线程池。</li>
<li>对于一些复杂的操作（如文件系统操作、某些加密操作），libuv 会在后台的多个线程上执行这些任务，而主线程继续执行 JavaScript 代码。</li>
</ul>
</li>
<li><p><strong>错误处理机制</strong>:</p>
<ul>
<li>Node.js 提供了异常处理机制，比如 <code>try-catch</code> 块和全局的 <code>uncaughtException</code> 事件，来处理同步和异步代码中的错误。</li>
<li>正确的错误处理能够防止异常导致主线程崩溃。</li>
</ul>
</li>
<li><p><strong>进程管理</strong>:</p>
<ul>
<li>对于 CPU 密集型任务，可以使用 Node.js 的 <code>child_process</code> 模块来创建子进程，分担主线程的负载。</li>
<li>还可以使用集群（Cluster）模块来创建多个进程，每个进程都有自己的事件循环和 V8 实例，可以更好地利用多核 CPU。</li>
</ul>
</li>
</ol>
<p>通过这些机制，Node.js 能够确保即使是在单个主线程上运行，也能高效地处理大量的并发 I&#x2F;O 操作，同时避免线程中断和阻塞。</p>
<span id="more"></span>

<h2 id="TCP-三次握手与四次挥手"><a href="#TCP-三次握手与四次挥手" class="headerlink" title="TCP 三次握手与四次挥手"></a>TCP 三次握手与四次挥手</h2><p>TCP（传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。在TCP&#x2F;IP协议族中，TCP的任务是在两个主机之间建立一个可靠的连接，并保证数据包的顺序传输和完整性。这一过程通过“三次握手”来建立连接，通过“四次挥手”来终止连接。</p>
<h3 id="TCP三次握手（连接建立过程）"><a href="#TCP三次握手（连接建立过程）" class="headerlink" title="TCP三次握手（连接建立过程）"></a>TCP三次握手（连接建立过程）</h3><p>三次握手的主要目的是双方确认自身的发送与接收是正常的。过程如下：</p>
<ol>
<li><p><strong>SYN</strong>：客户端发送一个SYN（同步序列编号）报文到服务器。在这个阶段，客户端尝试建立连接，告诉服务器它想要开始一个新的连接，并且包含了客户端的初始序列号（ISN），用于同步。</p>
</li>
<li><p><strong>SYN-ACK</strong>：服务器收到SYN报文后，会发送一个SYN-ACK（同步应答）报文作为响应。这个报文中既确认（ACK）了客户端的SYN（ACK编号设为客户端的ISN+1），也包含了服务器自己的初始序列号，准备同步。</p>
</li>
<li><p><strong>ACK</strong>：客户端收到SYN-ACK后，发送一个ACK（确认）报文作为回应。这个ACK报文的序列号设置为服务器的ISN+1，确认号则是服务器的SYN-ACK中的序列号+1。至此，连接建立完成。</p>
</li>
</ol>
<h3 id="TCP四次挥手（连接释放过程）"><a href="#TCP四次挥手（连接释放过程）" class="headerlink" title="TCP四次挥手（连接释放过程）"></a>TCP四次挥手（连接释放过程）</h3><p>四次挥手的主要目的是允许双方各自独立地关闭连接。过程如下：</p>
<ol>
<li><p><strong>FIN</strong>：当通信的一方完成数据传输后，会发送一个FIN（结束）报文，表示它已经没有数据发送了，请求释放连接。</p>
</li>
<li><p><strong>ACK</strong>：接收方收到FIN报文后，会发送一个ACK报文作为响应，确认号为接收到的序列号+1。这表明接收方已经知道发送方没有数据发送了，但它还可能有数据发送给对方。</p>
</li>
<li><p><strong>FIN</strong>：如果接收方也发送了所有数据，它将发送自己的FIN报文，请求释放连接。</p>
</li>
<li><p><strong>ACK</strong>：发送方收到这个FIN之后，发送一个ACK报文作为回应，确认号为接收到的序列号+1。在等待一段时间之后（称为TIME_WAIT状态），以确保对方收到了最后的ACK报文，连接被彻底关闭。</p>
</li>
</ol>
<p>这个过程确保了TCP连接的可靠性，使得每一方都能独立地关闭自己的半连接，从而完全关闭整个TCP连接。</p>
<h2 id="建立可靠的-UDP-连接"><a href="#建立可靠的-UDP-连接" class="headerlink" title="建立可靠的 UDP 连接"></a>建立可靠的 UDP 连接</h2><ol>
<li><p><strong>确认和重传机制</strong>：发送端对每个UDP数据包分配序列号，并在发送后等待接收端的确认响应。如果在预定时间内未收到确认，发送端会重传该数据包。</p>
</li>
<li><p><strong>序列号和排序</strong>：接收端利用序列号检查接收到的数据包顺序，并重新排序乱序到达的数据包。</p>
</li>
<li><p><strong>错误检测</strong>：通过在数据包中加入校验和（Checksum），接收端可以检测到数据包在传输过程中的任何错误。</p>
</li>
<li><p><strong>流量控制和拥塞控制</strong>：可以通过动态调整发送数据的速率和频率来避免网络拥塞和数据丢失。</p>
</li>
<li><p><strong>连接管理</strong>：虽然UDP本身是无连接的，但应用可以设计握手协议来初始化通信参数，如协商数据包大小、传输速率等，以及通过心跳机制检测对方是否可达，从而实现类似于TCP的连接管理功能。</p>
</li>
</ol>
<h2 id="websocket-建立连接的过程"><a href="#websocket-建立连接的过程" class="headerlink" title="websocket 建立连接的过程"></a>websocket 建立连接的过程</h2><p>WebSocket 建立连接的过程是一个升级自 HTTP 协议的握手过程。WebSocket 允许在用户的浏览器和服务器之间建立一个持久的连接，使得数据可以双向传输。下面是 WebSocket 建立连接的详细步骤：</p>
<ol>
<li><p><strong>客户端发送握手请求</strong>:</p>
<ul>
<li>首先，客户端（通常是一个网页的 JavaScript）通过发送一个 HTTP 请求来初始化 WebSocket 连接。这个请求被称为”握手请求”。</li>
<li>这个请求使用普通的 HTTP GET 方法，但在请求头中包含特定的头部字段，指示这是一个 WebSocket 连接请求。主要的头部字段包括：<ul>
<li><code>Upgrade: websocket</code>：告诉服务器，客户端希望将 HTTP 连接升级到 WebSocket。</li>
<li><code>Connection: Upgrade</code>：同样表示这是一个升级请求。</li>
<li><code>Sec-WebSocket-Key</code>：一个 Base64 编码的随机值，服务器将用它来构建一个响应密钥，验证连接。</li>
<li><code>Sec-WebSocket-Version</code>：标示客户端支持的 WebSocket 版本。</li>
<li><code>Origin</code>（可选）：指示请求来自哪个源，用于服务器的跨源策略。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>服务器响应握手</strong>:</p>
<ul>
<li>服务器解析这个握手请求，如果接受升级请求，则会发送一个 HTTP 101 Switching Protocols 响应。</li>
<li>服务器的响应也包含几个特定的头部字段：<ul>
<li><code>Upgrade: websocket</code> 和 <code>Connection: Upgrade</code>：确认升级到 WebSocket。</li>
<li><code>Sec-WebSocket-Accept</code>：这是对客户端 <code>Sec-WebSocket-Key</code> 的响应，由服务器生成，客户端会验证这个值以确认连接的有效性。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>连接建立</strong>:</p>
<ul>
<li>客户端收到服务器的 101 响应后，WebSocket 连接被视为已经建立，客户端和服务器就可以开始通过这个连接双向传输数据了。</li>
<li>此时，连接从 HTTP 协议升级为 WebSocket 协议。</li>
</ul>
</li>
<li><p><strong>数据传输</strong>:</p>
<ul>
<li>一旦连接建立，客户端和服务器就可以开始发送和接收消息。</li>
<li>WebSocket 协议支持文本和二进制数据的传输。</li>
</ul>
</li>
<li><p><strong>保持连接</strong>:</p>
<ul>
<li>WebSocket 连接会保持活跃状态，直到客户端或服务器决定关闭连接。</li>
<li>连接保持活跃使得双方可以随时发送数据，无需重新建立连接。</li>
</ul>
</li>
</ol>
<p>这个握手过程的设计允许 WebSocket 连接轻松地穿过大多数防火墙，因为它们在初始阶段模仿标准的 HTTP 连接。这种方法还使得在不支持 WebSocket 的环境中回退到其他协议（如长轮询）变得更加容易。</p>
<h2 id="websocket和长轮询的区别"><a href="#websocket和长轮询的区别" class="headerlink" title="websocket和长轮询的区别"></a>websocket和长轮询的区别</h2><p>WebSocket 和长轮询（Long Polling）是两种在客户端和服务器之间实现实时数据通信的技术，但它们在工作原理和效率方面有显著区别。下面是 WebSocket 和长轮询之间的主要区别：</p>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><ol>
<li><p><strong>持久连接</strong>:</p>
<ul>
<li>WebSocket 协议建立的是一个持久的、全双工的连接。一旦连接建立，客户端和服务器可以随时互相发送数据，直到任一方主动关闭连接。</li>
</ul>
</li>
<li><p><strong>协议升级</strong>:</p>
<ul>
<li>WebSocket 通过一次 HTTP 握手升级到 WebSocket 协议。握手完成后，协议从 HTTP 切换到 WebSocket，这个连接将保持打开状态，不再是 HTTP 协议。</li>
</ul>
</li>
<li><p><strong>高效率</strong>:</p>
<ul>
<li>因为连接是持久的，所以不存在为了每次数据交换而建立和终止连接的额外开销。这使得 WebSocket 在数据实时性和网络效率方面优于长轮询。</li>
</ul>
</li>
<li><p><strong>双向通信</strong>:</p>
<ul>
<li>WebSocket 支持全双工通信，即客户端和服务器可以同时发送和接收数据。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>:</p>
<ul>
<li>适合需要高频率、实时性强的应用场景，例如在线游戏、实时聊天、实时数据更新等。</li>
</ul>
</li>
</ol>
<h3 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h3><ol>
<li><p><strong>基于 HTTP 请求</strong>:</p>
<ul>
<li>长轮询是在标准的 HTTP 协议上工作的。客户端发送一个 HTTP 请求到服务器，服务器保持这个请求开放直到有数据可发送。</li>
</ul>
</li>
<li><p><strong>非持久连接</strong>:</p>
<ul>
<li>每次服务器向客户端发送响应后，连接被关闭。对于新的数据，客户端需要发起新的 HTTP 请求。</li>
</ul>
</li>
<li><p><strong>效率较低</strong>:</p>
<ul>
<li>长轮询需要频繁地建立和关闭 HTTP 连接，这在某些场景下可能导致较高的网络开销和延迟。</li>
</ul>
</li>
<li><p><strong>单向请求模式</strong>:</p>
<ul>
<li>尽管长轮询可以较快地将服务器的更新推送到客户端，但它本质上仍然是一种单向请求模式，即服务器不能主动向客户端发送消息，除非客户端首先发送请求。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>:</p>
<ul>
<li>适合对实时性要求不是特别高的应用，或是在不支持 WebSocket 的环境中作为替代方案使用。</li>
</ul>
</li>
</ol>
<p>总结来说，WebSocket 提供了更高效、更适合实时通信的双向连接，而长轮询是一种更简单、在旧浏览器上更容易实现的替代方案。WebSocket 是实现实时应用的首选技术，但在某些场景下，长轮询可能因其简单性和兼容性而被选择。</p>
<h2 id="tcp-如何保证可靠性"><a href="#tcp-如何保证可靠性" class="headerlink" title="tcp 如何保证可靠性"></a>tcp 如何保证可靠性</h2><p>TCP（传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。它通过一系列机制来保证数据传输的可靠性，包括：</p>
<ol>
<li><p><strong>三次握手建立连接</strong>:</p>
<ul>
<li>在传输数据之前，TCP 使用一种被称为“三次握手”的过程来建立连接。这确保了双方都准备好接收和发送数据，并防止了初始化连接时的一些常见的问题。</li>
</ul>
</li>
<li><p><strong>序列号和确认应答</strong>:</p>
<ul>
<li>TCP 给发送的每个数据包分配一个序列号，并要求接收方对每个接收到的数据包发送确认（ACK）。</li>
<li>如果发送方在预定的超时时间内没有收到对特定数据包的确认，它会重新发送该数据包。</li>
</ul>
</li>
<li><p><strong>数据校验和</strong>:</p>
<ul>
<li>每个 TCP 数据包包含一个校验和，以确保数据在传输过程中没有被破坏或更改。</li>
<li>如果接收方检测到数据包损坏（校验和不匹配），它将丢弃该数据包并不发送确认，导致发送方重新发送数据。</li>
</ul>
</li>
<li><p><strong>流量控制</strong>:</p>
<ul>
<li>TCP 使用窗口大小控制来进行流量控制，以避免发送方过快发送数据，导致接收方来不及处理。</li>
<li>接收方通过在确认应答中指定一个“窗口大小”来告诉发送方它还能接收多少数据，从而控制发送方的数据发送速率。</li>
</ul>
</li>
<li><p><strong>拥塞控制</strong>:</p>
<ul>
<li>TCP 还实现了拥塞控制机制，以避免网络中过多的数据包导致网络拥塞。</li>
<li>当网络拥塞时，TCP 会减少其数据传输速率，并在网络状况改善时逐渐增加速率。</li>
</ul>
</li>
<li><p><strong>乱序数据重新排序</strong>:</p>
<ul>
<li>由于网络原因，TCP 数据包可能会乱序到达。TCP 在接收端会根据序列号重新对数据包进行排序，以确保数据的正确顺序。</li>
</ul>
</li>
<li><p><strong>保持活动检测</strong>:</p>
<ul>
<li>TCP 定期发送保持活动包，以检测连接是否仍然有效，防止“死”连接占用资源。</li>
</ul>
</li>
</ol>
<p>通过这些机制，TCP 能够在不可靠的互联网环境中提供可靠的数据传输服务。这些特性使得 TCP 成为了许多需要高可靠性数据传输的应用（如Web页面加载、文件传输、电子邮件等）的理想选择。</p>
<h2 id="拥塞算法"><a href="#拥塞算法" class="headerlink" title="拥塞算法"></a>拥塞算法</h2><p>TCP拥塞控制算法是为了解决和避免网络拥塞问题而设计的一组算法。当多个网络设备尝试同时发送过多数据时，网络拥塞可能发生，导致网络性能下降和数据包丢失。TCP拥塞控制算法的目的是确保每个网络连接获得公平的带宽使用，并减少数据包丢失。下面是一些主要的TCP拥塞控制算法：</p>
<ol>
<li><p><strong>慢启动（Slow Start）</strong>:</p>
<ul>
<li>在TCP连接开始时，慢启动算法被用来探测网络的载荷能力。</li>
<li>慢启动通过逐渐增加拥塞窗口（Congestion Window, cwnd）的大小来增加网络中的数据量，开始时cwnd从一个或几个数据包开始，每收到一个确认响应，cwnd就增加一倍，呈指数增长。</li>
<li>当cwnd达到一个阈值（ssthresh）时，切换到拥塞避免算法。</li>
</ul>
</li>
<li><p><strong>拥塞避免（Congestion Avoidance）</strong>:</p>
<ul>
<li>在拥塞避免阶段，每经过一个往返时间（Round-Trip Time, RTT），cwnd线性增加一个数据包，而不是指数增长。</li>
<li>这个阶段旨在维持网络载荷在一个相对稳定的水平。</li>
</ul>
</li>
<li><p><strong>快重传（Fast Retransmit）</strong>:</p>
<ul>
<li>快重传是指在接收方连续收到三个相同的确认（Triple Duplicate ACKs）时，立即重传丢失的数据包，而不是等待重传计时器到期。</li>
<li>这种机制可以更快地纠正丢包的情况。</li>
</ul>
</li>
<li><p><strong>快恢复（Fast Recovery）</strong>:</p>
<ul>
<li>快恢复算法与快重传一起工作，当检测到丢包（通过三个重复的 ACK ）时，它会减少 cwnd 的大小而不是像慢启动时那样将其减至1，通常将 cwnd 设置为 ssthresh 的一半。</li>
<li>在快恢复阶段，对于每个接收到的重复 ACK ， cwnd 逐渐增加，直到收到新的数据确认。</li>
</ul>
</li>
<li><p><strong>TCP Tahoe 和 Reno</strong>:</p>
<ul>
<li>TCP Tahoe 和 Reno 是两种实现了上述拥塞控制算法的TCP变体。</li>
<li>Tahoe 使用慢启动、拥塞避免和快重传，但在检测到丢包时，它会将cwnd重置为1。</li>
<li>Reno 则引入了快恢复算法，它在丢包时减少cwnd而不是重置。</li>
</ul>
</li>
<li><p><strong>其他算法</strong>:</p>
<ul>
<li>随着网络技术的发展，出现了更多的拥塞控制算法，如TCP Vegas, TCP BBR（Bottleneck Bandwidth and RTT）等，它们在不同的网络环境和场景中提供了改进的性能。</li>
</ul>
</li>
</ol>
<p>TCP拥塞控制算法的设计旨在使TCP连接能够自适应网络状况的变化，优化网络资源的使用，同时保证网络的稳定性和公平性。随着网络条件的不断变化，这些算法也在不断地进化和优化。</p>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>TCP（传输控制协议）的三次握手（Three-Way Handshake）过程是用于在两个网络实体之间建立一个可靠的连接的关键机制。这个过程不仅用于协商和初始化连接参数，还用于确保双方准备好进行数据传输。下面是三次握手的详细介绍：</p>
<h3 id="第一次握手：SYN"><a href="#第一次握手：SYN" class="headerlink" title="第一次握手：SYN"></a>第一次握手：SYN</h3><ol>
<li><p><strong>发起方发送SYN包</strong>:</p>
<ul>
<li>连接的发起方（客户端）开始握手过程，发送一个包含 SYN（同步序列编号）标志的数据包到接收方（服务器）。</li>
<li>在这个数据包中，发起方选择一个随机的序列号（Seq &#x3D; X），这个序列号在后续数据传输中用于保证数据的有序和完整性。</li>
</ul>
</li>
<li><p><strong>目的</strong>:</p>
<ul>
<li>主要是向接收方表明发起方希望建立连接。</li>
</ul>
</li>
</ol>
<h3 id="第二次握手：SYN-ACK"><a href="#第二次握手：SYN-ACK" class="headerlink" title="第二次握手：SYN-ACK"></a>第二次握手：SYN-ACK</h3><ol>
<li><p><strong>接收方响应SYN-ACK包</strong>:</p>
<ul>
<li>接收方收到 SYN 包后，需要确认这个请求。它发送一个包含 SYN 和 ACK（确认响应）标志的数据包。</li>
<li>这个数据包中的确认号（Ack &#x3D; X + 1）是对发起方 SYN 包中序列号的确认，同时接收方也选择自己的一个随机序列号（Seq &#x3D; Y）。</li>
</ul>
</li>
<li><p><strong>目的</strong>:</p>
<ul>
<li>确认发起方的 SYN，并且通知发起方接收方也准备好建立连接。</li>
</ul>
</li>
</ol>
<h3 id="第三次握手：ACK"><a href="#第三次握手：ACK" class="headerlink" title="第三次握手：ACK"></a>第三次握手：ACK</h3><ol>
<li><p><strong>发起方发送ACK包</strong>:</p>
<ul>
<li>发起方收到 SYN-ACK 包后，发送一个包含 ACK 标志的数据包，这个包的确认号被设置为接收方的序列号加一（Ack &#x3D; Y + 1）。</li>
<li>这一步完成了对接收方初始序列号的确认。</li>
</ul>
</li>
<li><p><strong>连接建立</strong>:</p>
<ul>
<li>一旦接收方收到这个 ACK 包，连接就被认为是建立了。现在，双方都已确认彼此的初始序列号，并且都准备好进行数据传输。</li>
</ul>
</li>
</ol>
<h3 id="为什么需要三次握手？"><a href="#为什么需要三次握手？" class="headerlink" title="为什么需要三次握手？"></a>为什么需要三次握手？</h3><p>三次握手的设计是为了确保双方都能确认对方的接收和发送能力。它主要解决了以下几个问题：</p>
<ul>
<li>确保双方都知道对方准备好发送和接收数据。</li>
<li>避免旧的延迟连接初始化请求突然建立连接。</li>
<li>确保在连接开始时双方的序列号被正确初始化和同步。</li>
</ul>
<p>这个过程是建立一个可靠的 TCP 连接的基础，确保了数据传输的可靠性和顺序性。</p>
<h2 id="http-和-tcp-的-keep-alive-区别"><a href="#http-和-tcp-的-keep-alive-区别" class="headerlink" title="http 和 tcp 的 keep-alive 区别"></a>http 和 tcp 的 keep-alive 区别</h2><p>HTTP Keep-Alive 和 TCP Keep-Alive 是两种不同层次上的保持连接活跃的机制，它们的目的和实现方式有所不同：</p>
<h3 id="HTTP-Keep-Alive"><a href="#HTTP-Keep-Alive" class="headerlink" title="HTTP Keep-Alive"></a>HTTP Keep-Alive</h3><ol>
<li><p><strong>层次</strong>:</p>
<ul>
<li>HTTP Keep-Alive 工作在应用层，是 HTTP 协议的一部分。</li>
</ul>
</li>
<li><p><strong>目的</strong>:</p>
<ul>
<li>HTTP Keep-Alive 的主要目的是减少建立和关闭连接的频繁操作，提高 HTTP 传输效率。</li>
<li>它允许在一个 TCP 连接上发送和接收多个 HTTP 请求&#x2F;响应，而不需要为每个请求&#x2F;响应对重新建立新的 TCP 连接。</li>
</ul>
</li>
<li><p><strong>实现</strong>:</p>
<ul>
<li>在 HTTP 1.1 中，默认开启 Keep-Alive。</li>
<li>客户端和服务器在 HTTP 头部信息中通过 <code>Connection: keep-alive</code> 来通告对方它们希望保持连接打开。</li>
<li>连接会保持活跃直到客户端或服务器决定关闭，或者超过预定的超时时间。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>:</p>
<ul>
<li>HTTP Keep-Alive 特别适用于需要多个连续的 HTTP 请求&#x2F;响应的场景，如网页加载中包含多个资源（CSS、JavaScript、图片等）的情况。</li>
</ul>
</li>
</ol>
<h3 id="TCP-Keep-Alive"><a href="#TCP-Keep-Alive" class="headerlink" title="TCP Keep-Alive"></a>TCP Keep-Alive</h3><ol>
<li><p><strong>层次</strong>:</p>
<ul>
<li>TCP Keep-Alive 工作在传输层，是 TCP 协议的一部分。</li>
</ul>
</li>
<li><p><strong>目的</strong>:</p>
<ul>
<li>TCP Keep-Alive 的目的是检测死亡连接（即长时间无数据交换的连接），确保连接的双方仍然可达。</li>
<li>它用于维护和监控 TCP 连接的状态。</li>
</ul>
</li>
<li><p><strong>实现</strong>:</p>
<ul>
<li>TCP Keep-Alive 通过定期发送探测数据包来实现。如果在一定次数的探测后仍然没有收到响应，则认为连接已经断开，并关闭连接。</li>
<li>这个机制在某些操作系统中默认关闭，并且探测间隔和次数可以配置。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>:</p>
<ul>
<li>TCP Keep-Alive 适用于任何基于 TCP 的网络服务，特别是那些可能长时间空闲但需要保持连接的场景，如数据库连接。</li>
</ul>
</li>
</ol>
<h3 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h3><ul>
<li><strong>层次不同</strong>：HTTP Keep-Alive 是应用层协议，TCP Keep-Alive 是传输层协议。</li>
<li><strong>目的不同</strong>：HTTP Keep-Alive 用于提高 HTTP 效率，减少连接重建的开销；而 TCP Keep-Alive 用于检测和维护连接的活跃状态。</li>
<li><strong>适用范围</strong>：HTTP Keep-Alive 仅用于 HTTP 协议，而 TCP Keep-Alive 适用于所有基于 TCP 的通信。</li>
<li><strong>工作方式</strong>：HTTP Keep-Alive 通过重用连接进行多个请求&#x2F;响应交换，TCP Keep-Alive 通过发送探测数据包来检测连接状态。</li>
</ul>
<h2 id="js-闭包、原型、事件循环"><a href="#js-闭包、原型、事件循环" class="headerlink" title="js 闭包、原型、事件循环"></a>js 闭包、原型、事件循环</h2><h3 id="闭包（Closure）"><a href="#闭包（Closure）" class="headerlink" title="闭包（Closure）"></a>闭包（Closure）</h3><p>闭包是 JavaScript 中一个非常重要的特性，它允许一个函数访问并操作该函数外部的变量。</p>
<ol>
<li><p><strong>定义</strong>: 在 JavaScript 中，当一个函数嵌套在另一个函数内，并引用外层函数的变量时，就形成了闭包。</p>
</li>
<li><p><strong>作用</strong>:</p>
<ul>
<li><strong>访问外部函数的变量</strong>: 内部函数可以访问定义在外部函数中的变量，即使外部函数已经执行完毕。</li>
<li><strong>数据封装和私有性</strong>: 闭包可以用来创建私有变量，提供类似于面向对象编程中的封装和隐藏数据的功能。</li>
</ul>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> secret = <span class="string">&quot;I&#x27;m a secret!&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">innerFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(secret);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getSecret = <span class="title function_">outerFunction</span>();</span><br><span class="line"><span class="title function_">getSecret</span>(); <span class="comment">// 输出 &quot;I&#x27;m a secret!&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="原型（Prototype）"><a href="#原型（Prototype）" class="headerlink" title="原型（Prototype）"></a>原型（Prototype）</h3><p>原型是 JavaScript 中实现继承和共享属性或方法的一种机制。</p>
<ol>
<li><p><strong>原型对象</strong>: 每个 JavaScript 对象都有一个原型对象（<code>prototype</code>），对象从其原型继承属性和方法。</p>
</li>
<li><p><strong>原型链</strong>: 当访问一个对象的属性或方法时，如果该对象自身不包含这个属性或方法，JavaScript 会沿着原型链向上查找，直到找到或到达原型链的顶端（<code>Object.prototype</code>）。</p>
</li>
<li><p><strong>使用</strong>:</p>
<ul>
<li>常用于创建具有相似属性和方法的多个对象，提高代码复用性。</li>
<li>原型链是 JavaScript 中实现继承的基础。</li>
</ul>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">person1.<span class="title function_">sayHello</span>(); <span class="comment">// 输出 &quot;Hello, my name is Alice&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="事件循环（Event-Loop）"><a href="#事件循环（Event-Loop）" class="headerlink" title="事件循环（Event Loop）"></a>事件循环（Event Loop）</h3><p>事件循环是 JavaScript 中处理异步操作和保持单线程运行的机制。</p>
<ol>
<li><p><strong>单线程和异步</strong>: JavaScript 是单线程语言，但支持异步编程（例如，通过回调函数、Promises、async&#x2F;await）。</p>
</li>
<li><p><strong>任务类型</strong>:</p>
<ul>
<li><strong>宏任务（Macro Task）</strong>: 如 <code>setTimeout</code>, <code>setInterval</code>, I&#x2F;O 操作。</li>
<li><strong>微任务（Micro Task）</strong>: 如 Promise 回调、<code>process.nextTick</code>（在 Node.js 中）。</li>
</ul>
</li>
<li><p><strong>工作机制</strong>:</p>
<ul>
<li>事件循环不断检查是否有待执行的任务。</li>
<li>如果执行栈为空，事件循环会查看任务队列。如果队列中有宏任务，从队列中取出一个执行。</li>
<li>在每个宏任务执行之后，事件循环会处理所有的微任务队列，之后再执行下一个宏任务。</li>
<li>这个循环持续进行，直到所有任务完成。</li>
</ul>
</li>
<li><p><strong>示例</strong>:</p>
<ul>
<li>异步操作（如通过 <code>setTimeout</code> 设置的定时器）不会立即执行，而是被加入队列，在当前和其他微任务执行完毕后再执行。</li>
</ul>
</li>
</ol>
<h2 id="webpack-与-vite"><a href="#webpack-与-vite" class="headerlink" title="webpack 与 vite"></a>webpack 与 vite</h2><p>Webpack 和 Vite 是两种流行的前端构建工具，它们用于优化开发和生产环境下的前端项目。虽然两者的目标相似，但它们在实现方式和性能上有明显的区别：</p>
<h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><ol>
<li><p><strong>概念</strong>:</p>
<ul>
<li>Webpack 是一个模块打包器（bundler），主要用于 JavaScript 和相关资源文件（如 CSS、图片）的模块化构建和打包。</li>
</ul>
</li>
<li><p><strong>工作原理</strong>:</p>
<ul>
<li>Webpack 通过一个入口点开始，分析项目中的模块和资源依赖，将这些资源转换和打包成少数几个文件，通常用于生产环境。</li>
</ul>
</li>
<li><p><strong>特点</strong>:</p>
<ul>
<li><strong>灵活性和配置性</strong>：Webpack 提供了广泛的插件系统和配置选项，适用于复杂的项目需求。</li>
<li><strong>热模块替换（HMR）</strong>：在开发环境中，Webpack 支持热模块替换，允许应用在运行时更新模块而无需完全刷新。</li>
<li><strong>慢启动</strong>：由于需要分析整个项目的依赖和资源，Webpack 的启动和热更新可能比较慢。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>:</p>
<ul>
<li>适用于需要复杂配置和高度定制化构建流程的大型项目。</li>
</ul>
</li>
</ol>
<h3 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h3><ol>
<li><p><strong>概念</strong>:</p>
<ul>
<li>Vite 是一个更现代的前端构建工具，利用了最新的前端技术，如原生 ES 模块加载。</li>
</ul>
</li>
<li><p><strong>工作原理</strong>:</p>
<ul>
<li>在开发环境中，Vite 作为一个服务器运行，它利用浏览器原生的 ES 模块导入功能来服务模块请求。</li>
<li>在生产环境中，Vite 使用 Rollup 进行高效的打包。</li>
</ul>
</li>
<li><p><strong>特点</strong>:</p>
<ul>
<li><strong>快速启动</strong>：由于使用了原生 ES 模块，Vite 在开发环境中可以快速启动，无需等待打包过程。</li>
<li><strong>按需编译</strong>：Vite 只编译当前请求的模块，而不是整个应用，这使得热更新非常快。</li>
<li><strong>简化配置</strong>：Vite 设计理念倾向于减少配置，提供更简洁的开发体验。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>:</p>
<ul>
<li>适用于新项目，尤其是在追求快速开发和简化构建配置的场景下。</li>
</ul>
</li>
</ol>
<h3 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h3><ul>
<li><strong>启动速度</strong>：Vite 在开发环境中的启动速度通常比 Webpack 快，因为它不需要预先打包整个应用。</li>
<li><strong>热更新速度</strong>：Vite 的热更新通常比 Webpack 快，因为它只编译变更的模块。</li>
<li><strong>构建原理</strong>：Webpack 是一个传统的模块打包器，而 Vite 利用了现代浏览器的原生 ES 模块特性。</li>
<li><strong>兼容性</strong>：Webpack 支持更广泛的模块格式和浏览器兼容性，而 Vite 主要针对现代浏览器。</li>
<li><strong>配置复杂性</strong>：Webpack 的配置通常更复杂，而 Vite 旨在提供更简洁的配置。</li>
</ul>
<h2 id="vue2-和-vue3"><a href="#vue2-和-vue3" class="headerlink" title="vue2 和 vue3"></a>vue2 和 vue3</h2><p>Vue.js 是一个流行的 JavaScript 框架，用于构建用户界面和单页应用程序。Vue 3 是 Vue.js 的最新主要版本，相比于 Vue 2，它引入了许多新特性和改进。以下是 Vue 2 和 Vue 3 之间的主要区别：</p>
<h3 id="性能改进"><a href="#性能改进" class="headerlink" title="性能改进"></a>性能改进</h3><ol>
<li><p><strong>更快的虚拟 DOM</strong>:</p>
<ul>
<li>Vue 3 引入了一个全新的虚拟 DOM 实现，优化了渲染速度和内存消耗。</li>
</ul>
</li>
<li><p><strong>编译优化</strong>:</p>
<ul>
<li>Vue 3 的编译器进行了重写，提供了更好的编译优化，减少了运行时的开销。</li>
</ul>
</li>
<li><p><strong>树摇动（Tree-shaking）</strong>:</p>
<ul>
<li>Vue 3 支持树摇动，意味着在最终打包时可以去除未使用的代码，减小应用体积。</li>
</ul>
</li>
</ol>
<h3 id="组合式-API"><a href="#组合式-API" class="headerlink" title="组合式 API"></a>组合式 API</h3><p>Vue 3 引入了 Composition API（组合式 API），这是 Vue 3 最显著的新特性之一。</p>
<ol>
<li><p><strong>更好的逻辑复用和组织</strong>:</p>
<ul>
<li>Composition API 允许开发者更灵活地组织组件逻辑，特别是在处理复杂组件时。</li>
<li>使用 <code>setup</code> 函数和一系列新的 API（如 <code>ref</code>, <code>reactive</code>, <code>computed</code>, <code>watch</code> 等），可以更好地封装和重用逻辑。</li>
</ul>
</li>
<li><p><strong>与 Options API 的共存</strong>:</p>
<ul>
<li>Vue 3 依然支持 Vue 2 中的 Options API，两种风格可以共存。</li>
</ul>
</li>
</ol>
<h3 id="更好的-TypeScript-支持"><a href="#更好的-TypeScript-支持" class="headerlink" title="更好的 TypeScript 支持"></a>更好的 TypeScript 支持</h3><ul>
<li>Vue 3 从一开始就考虑到了 TypeScript 的支持，其代码基于 TypeScript 编写，提供了更好的类型推断和集成。</li>
</ul>
<h3 id="其他新特性和改进"><a href="#其他新特性和改进" class="headerlink" title="其他新特性和改进"></a>其他新特性和改进</h3><ol>
<li><p><strong>组合式 API</strong>:</p>
<ul>
<li>引入了更灵活的组合式 API，为组件逻辑提供了更强的组织能力。</li>
</ul>
</li>
<li><p><strong>更小的体积</strong>:</p>
<ul>
<li>Vue 3 的体积比 Vue 2 更小，主要得益于树摇动。</li>
</ul>
</li>
<li><p><strong>多根节点组件</strong>:</p>
<ul>
<li>Vue 3 允许组件有多个根节点，而 Vue 2 中每个组件只能有一个根节点。</li>
</ul>
</li>
<li><p><strong>响应式系统的重写</strong>:</p>
<ul>
<li>Vue 3 的响应式系统基于 Proxy API 重写，提供了更好的性能和兼容性。</li>
</ul>
</li>
<li><p><strong>全新的生命周期钩子</strong>:</p>
<ul>
<li>引入了新的生命周期钩子，如 <code>onMounted</code>, <code>onUpdated</code> 等。</li>
</ul>
</li>
<li><p><strong>Fragment, Teleport, Suspense</strong>:</p>
<ul>
<li>引入了新的内置组件，如 Fragment（允许多个根节点），Teleport（允许将子节点传送到 DOM 树的其他位置），Suspense（用于异步组件的数据获取和渲染）。</li>
</ul>
</li>
</ol>
<h3 id="兼容性和迁移"><a href="#兼容性和迁移" class="headerlink" title="兼容性和迁移"></a>兼容性和迁移</h3><ul>
<li>Vue 3 考虑到了向后兼容性，提供了从 Vue 2 迁移到 Vue 3 的工具和指南。</li>
</ul>
<h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><ol>
<li><p><strong>事件循环</strong>:</p>
<ul>
<li>Node.js 运行时基于事件循环。事件循环负责处理异步回调，如 I&#x2F;O 操作、计时器、网络请求等。</li>
</ul>
</li>
<li><p><strong>微任务队列</strong>:</p>
<ul>
<li><code>process.nextTick</code> 将回调函数放入微任务队列。这个队列在事件循环的每个阶段之间执行，甚至在事件循环的当前阶段完成之前。</li>
</ul>
</li>
<li><p><strong>优先级</strong>:</p>
<ul>
<li>通过 <code>process.nextTick</code> 调度的任务比通过 <code>setImmediate</code> 或 <code>setTimeout</code>、<code>setInterval</code> 调度的任务优先级更高。这意味着 <code>nextTick</code> 回调在任何 I&#x2F;O 事件（包括定时器）之前执行。</li>
</ul>
</li>
</ol>
<h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><ul>
<li>当调用 <code>process.nextTick</code> 时，传入的回调函数不会立即执行。而是在当前操作完成后、事件循环继续进行之前执行。</li>
<li>这意味着即使在 I&#x2F;O 操作或定时器触发之前，所有通过 <code>nextTick</code> 排队的回调都会首先执行。</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><p><strong>错误处理</strong>:</p>
<ul>
<li><code>process.nextTick</code> 经常用于异步 API 中的错误处理。这是因为它允许在堆栈被解构之前抛出异常，从而可以捕获和处理错误。</li>
</ul>
</li>
<li><p><strong>确保异步性</strong>:</p>
<ul>
<li>有时候，你可能需要确保代码总是以异步方式运行，即使是在同步代码块中。<code>process.nextTick</code> 可以用于确保回调总是异步调用，从而避免了同步操作和异步操作之间的潜在问题。</li>
</ul>
</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始&#x27;</span>);</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextTick 回调&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;计划的 nextTick&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，输出将会是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开始</span><br><span class="line">计划的 nextTick</span><br><span class="line">nextTick 回调</span><br></pre></td></tr></table></figure>

<p>即使 <code>process.nextTick</code> 的回调是在最后一行调用的，它仍然在当前事件循环的末尾执行，即在任何其他的 I&#x2F;O 事件或计时器之前执行。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>使用 <code>process.nextTick</code> 可能导致 I&#x2F;O 饿死，因为如果不断地添加 <code>nextTick</code> 回调，那么 I&#x2F;O 事件可能永远无法被处理。因此，适当地使用 <code>nextTick</code> 是非常重要的。</li>
<li>对于绝大多数场景，<code>setImmediate</code> 是处理异步操作的更好选择，因为它更加公平地对待事件循环中的所有类型的事件。</li>
</ul>
<h2 id="javascript-和-typescript"><a href="#javascript-和-typescript" class="headerlink" title="javascript 和 typescript"></a>javascript 和 typescript</h2><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><ol>
<li><p><strong>定义</strong>:</p>
<ul>
<li>JavaScript 是一种高级的、解释型的编程语言。它是 Web 的核心语言，几乎所有的现代网页都使用 JavaScript 来增加交互性。</li>
</ul>
</li>
<li><p><strong>特点</strong>:</p>
<ul>
<li><strong>动态类型</strong>: JavaScript 是一种动态类型语言，这意味着变量的类型是在运行时确定的。</li>
<li><strong>解释执行</strong>: 作为一种解释型语言，JavaScript 代码在运行时由浏览器或 Node.js 的解释器直接执行。</li>
<li><strong>灵活性</strong>: 它是一种非常灵活的语言，支持面向对象、命令式和函数式编程风格。</li>
</ul>
</li>
<li><p><strong>应用范围</strong>:</p>
<ul>
<li>用于浏览器端的脚本编写，也被广泛用于服务器端（Node.js），以及移动应用和桌面应用开发。</li>
</ul>
</li>
</ol>
<h3 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h3><ol>
<li><p><strong>定义</strong>:</p>
<ul>
<li>TypeScript 是 JavaScript 的一个超集，由 Microsoft 开发和维护。它在 JavaScript 的基础上添加了静态类型系统。</li>
</ul>
</li>
<li><p><strong>特点</strong>:</p>
<ul>
<li><strong>静态类型</strong>: TypeScript 提供了静态类型检查，这意味着类型错误可以在编译阶段被捕获，而不是在运行时。</li>
<li><strong>编译为 JavaScript</strong>: TypeScript 代码需要被编译成 JavaScript 代码，这样浏览器和 Node.js 才能执行。</li>
<li><strong>面向对象特性</strong>: TypeScript 支持更先进的面向对象编程特性，如类、接口、继承和泛型。</li>
</ul>
</li>
<li><p><strong>优势</strong>:</p>
<ul>
<li>提高了大型项目的可维护性和开发效率。</li>
<li>提供了编译时类型检查，有助于及早发现错误。</li>
<li>改善了代码质量和可读性。</li>
</ul>
</li>
<li><p><strong>应用范围</strong>:</p>
<ul>
<li>TypeScript 适用于需要高度维护性和可扩展性的大型项目，特别是在团队开发环境中。</li>
</ul>
</li>
</ol>
<h3 id="主要区别-1"><a href="#主要区别-1" class="headerlink" title="主要区别"></a>主要区别</h3><ul>
<li><strong>类型系统</strong>: TypeScript 的最大特点是它的静态类型系统，而 JavaScript 是动态类型的。</li>
<li><strong>错误检测</strong>: TypeScript 能够在编译期间检测到类型错误，而 JavaScript 中的类型错误通常在运行时出现。</li>
<li><strong>工具支持</strong>: TypeScript 由于其类型系统，提供了更好的自动完成、重构和接口文档。</li>
<li><strong>学习曲线</strong>: TypeScript 的学习曲线相对于 JavaScript 来说稍微陡峭一些，特别是对于不熟悉类型系统的开发者。</li>
</ul>
<p>总的来说，TypeScript 提供了更强大的工具和特性来帮助开发大型和复杂的应用，而 JavaScript 由于其广泛的应用和灵活性，仍然是最流行的前端开发语言之一。开发者可以根据项目的具体需求和团队的熟悉程度来选择使用 JavaScript 还是 TypeScript。</p>
<h2 id="Vue-双向绑定"><a href="#Vue-双向绑定" class="headerlink" title="Vue 双向绑定"></a>Vue 双向绑定</h2><p>Vue.js 中的双向绑定是一种机制，允许数据和 UI 界面之间建立一个响应式连接，使得数据的变化能够自动反映到 UI 上，同时用户对 UI 的操作也能自动更新到数据上。Vue 实现双向绑定主要依靠两个核心概念：响应式系统和 <code>v-model</code> 指令。</p>
<h3 id="响应式系统"><a href="#响应式系统" class="headerlink" title="响应式系统"></a>响应式系统</h3><ol>
<li><p><strong>观察者模式</strong>:</p>
<ul>
<li>Vue 使用观察者模式来跟踪数据的变化。当你把一个普通的 JavaScript 对象传入 Vue 实例作为 <code>data</code> 选项，Vue 会遍历它的所有属性，并使用 <code>Object.defineProperty</code> 把这些属性全部转为 getter&#x2F;setter。这是 Vue 响应式系统的核心。</li>
</ul>
</li>
<li><p><strong>依赖收集</strong>:</p>
<ul>
<li>当渲染函数被首次执行时，Vue 能够追踪到哪些属性被访问了，从而知道在哪些属性发生变化时需要重新渲染。</li>
</ul>
</li>
<li><p><strong>派发更新</strong>:</p>
<ul>
<li>当属性的 setter 被调用时（即属性值发生变化时），Vue 会通知那些依赖于这个属性的组件重新渲染。</li>
</ul>
</li>
</ol>
<h3 id="v-model-指令"><a href="#v-model-指令" class="headerlink" title="v-model 指令"></a><code>v-model</code> 指令</h3><ol>
<li><p><strong>基本用途</strong>:</p>
<ul>
<li><code>v-model</code> 在表单元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。</li>
</ul>
</li>
<li><p><strong>工作原理</strong>:</p>
<ul>
<li>对于输入框（<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>）和选择框（<code>&lt;select&gt;</code>），<code>v-model</code> 绑定的值通常是 <code>input</code> 事件中的 <code>value</code>。</li>
<li>在内部，<code>v-model</code> 实际上是一个语法糖，它相当于同时绑定了 <code>value</code> 属性和监听 <code>input</code> 事件，当控件的输入值变化时，更新数据。</li>
</ul>
</li>
</ol>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>假设有如下 Vue 实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;Hello Vue!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>和如下模板：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>&lt;input&gt;</code> 元素和 <code>message</code> 数据之间建立了双向绑定。用户在输入框中输入文本时，<code>message</code> 数据会实时更新，同时 <code>message</code> 数据的变化也会实时反映到输入框的值中。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>虽然 <code>v-model</code> 提供了方便的双向绑定，但它也可能导致数据流难以理解和追踪，特别是在复杂的应用中。因此，在一些场景下，推荐使用单向数据流（即数据的单向绑定和显式的事件处理）来保持数据流的清晰和可控。</li>
<li>在 Vue 3 中，响应式系统从 <code>Object.defineProperty</code> 改为了基于 ES6 的 Proxy，这使得 Vue 的响应式系统更加强大和高效，同时消除了一些 Vue 2 中存在的限制。</li>
</ul>
<h2 id="Cookie-Session-localStorage"><a href="#Cookie-Session-localStorage" class="headerlink" title="Cookie Session localStorage"></a>Cookie Session localStorage</h2><p><code>Cookie</code>、<code>Session</code> 和 <code>localStorage</code> 是用于存储和管理网站数据的三种不同技术，每种技术都有其特定的用途和限制。</p>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><ol>
<li><p><strong>定义</strong>:</p>
<ul>
<li>Cookie 是小段的数据，由服务器发送到用户浏览器，然后浏览器会将其存储，并在随后的每个请求中将其发送回服务器。</li>
</ul>
</li>
<li><p><strong>特点</strong>:</p>
<ul>
<li>体积小（通常限制为4KB）。</li>
<li>每次 HTTP 请求都会携带，包括静态资源请求，这可能影响性能。</li>
<li>可以设置过期时间。</li>
<li>支持同源策略。</li>
</ul>
</li>
<li><p><strong>用途</strong>:</p>
<ul>
<li>用户认证。</li>
<li>会话跟踪。</li>
<li>个性化设置。</li>
</ul>
</li>
<li><p><strong>安全性</strong>:</p>
<ul>
<li>支持设置为 HttpOnly（无法通过 JS 访问）和 Secure（只在 HTTPS 下传输）。</li>
</ul>
</li>
</ol>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><ol>
<li><p><strong>定义</strong>:</p>
<ul>
<li>Session 是服务器端用来存储用户信息的一种机制，通常用于识别用户和存储用户特定的数据。</li>
</ul>
</li>
<li><p><strong>特点</strong>:</p>
<ul>
<li>存储在服务器端，对客户端是透明的。</li>
<li>可以存储较大量的数据。</li>
<li>生命周期通常取决于用户的会话（浏览器关闭，Session 结束）。</li>
</ul>
</li>
<li><p><strong>用途</strong>:</p>
<ul>
<li>管理用户会话（如登录状态）。</li>
<li>存储用户相关的敏感信息。</li>
</ul>
</li>
<li><p><strong>安全性</strong>:</p>
<ul>
<li>相比于 Cookie，Session 更安全，因为数据存储在服务器端。</li>
</ul>
</li>
</ol>
<h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><ol>
<li><p><strong>定义</strong>:</p>
<ul>
<li>localStorage 是 HTML5 提供的一种在客户端存储数据的方式。</li>
</ul>
</li>
<li><p><strong>特点</strong>:</p>
<ul>
<li>存储容量较大（最多 5MB）。</li>
<li>仅在客户端存储，不随 HTTP 请求发送。</li>
<li>没有过期时间，数据永久保存，直到手动清除。</li>
</ul>
</li>
<li><p><strong>用途</strong>:</p>
<ul>
<li>存储不经常变化的大量数据。</li>
<li>保存用户偏好设置。</li>
<li>缓存应用程序数据以提高性能。</li>
</ul>
</li>
<li><p><strong>安全性</strong>:</p>
<ul>
<li>由于存储在客户端，可能受到跨站脚本攻击（XSS）。</li>
</ul>
</li>
</ol>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ul>
<li><p><strong>存储位置</strong>:</p>
<ul>
<li>Cookie 和 localStorage 存储在客户端。</li>
<li>Session 存储在服务器端。</li>
</ul>
</li>
<li><p><strong>安全性</strong>:</p>
<ul>
<li>Session 比 Cookie 更安全。</li>
<li>localStorage 适用于非敏感数据的存储。</li>
</ul>
</li>
<li><p><strong>生命周期</strong>:</p>
<ul>
<li>Cookie 可以设置过期时间。</li>
<li>Session 通常与用户会话绑定。</li>
<li>localStorage 永久存储，直到被清除。</li>
</ul>
</li>
<li><p><strong>容量</strong>:</p>
<ul>
<li>Cookie 容量最小。</li>
<li>localStorage 提供最大的存储空间。</li>
</ul>
</li>
<li><p><strong>性能</strong>:</p>
<ul>
<li>Cookie 每次请求都会发送，可能影响性能。</li>
<li>Session 和 localStorage 不影响网络性能。</li>
</ul>
</li>
</ul>
<h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><p>跨域是 Web 开发中常见的安全问题之一，它是由浏览器的同源策略引起的。同源策略是浏览器的一种安全措施，它限制了一个域的脚本与另一个域的资源进行交互。如果协议、端口（如果有指定）或主机对于两个页面不同，则这两个页面具有不同的源。</p>
<h3 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h3><p>当一个网页尝试请求另一个与自己域名、端口号或协议不同的网页的资源时，就会发生跨域。例如，由 <code>http://example.com</code> 发起的 AJAX 请求尝试访问 <code>https://api.anotherdomain.com</code> 的资源，由于协议和域名不同，这将是一个跨域请求。</p>
<h3 id="常见的解决方法"><a href="#常见的解决方法" class="headerlink" title="常见的解决方法"></a>常见的解决方法</h3><ol>
<li><p><strong>CORS（跨源资源共享）</strong>:</p>
<ul>
<li>最常用的解决跨域问题的方法是在服务器端设置 CORS。这种方法通过在服务器的响应头中添加 <code>Access-Control-Allow-Origin</code> 来允许特定的外部域访问资源。</li>
<li>例如，<code>Access-Control-Allow-Origin: *</code> 允许所有域名访问资源，而 <code>Access-Control-Allow-Origin: http://example.com</code> 只允许 <code>http://example.com</code> 访问资源。</li>
</ul>
</li>
<li><p><strong>JSONP（JSON with Padding）</strong>:</p>
<ul>
<li>早期解决跨域问题的一种技术，主要用于 GET 请求。</li>
<li>它通过动态创建 <code>&lt;script&gt;</code> 标签来向不同源的服务器请求数据。服务器端返回的数据被包装在一个函数调用中。</li>
<li>JSONP 的缺点是它只支持 GET 请求，并且安全性较低。</li>
</ul>
</li>
<li><p><strong>代理服务器</strong>:</p>
<ul>
<li>使用代理服务器进行跨域请求。在这种情况下，浏览器向代理服务器发送请求，代理服务器将请求发送到目标服务器，并将响应返回给浏览器。</li>
<li>这种方法的优点是可以控制和缓存请求，但缺点是增加了服务器端的复杂性和成本。</li>
</ul>
</li>
<li><p><strong>PostMessage</strong>:</p>
<ul>
<li><code>window.postMessage</code> 是 HTML5 引入的一种安全的跨源通信方法。</li>
<li>这种方法允许不同源之间的窗口相互通信，适用于在不同域之间传递信息。</li>
</ul>
</li>
<li><p><strong>服务器端配置</strong>:</p>
<ul>
<li>对于某些服务，如字体或一些 API，可以在服务器配置文件（如 <code>.htaccess</code> 或 Nginx 配置文件）中设置允许跨域。</li>
</ul>
</li>
<li><p><strong>WebSockets</strong>:</p>
<ul>
<li>WebSockets 本身不受同源策略的限制，可以用于跨域通信。</li>
</ul>
</li>
</ol>
<h3 id="选择合适的方法"><a href="#选择合适的方法" class="headerlink" title="选择合适的方法"></a>选择合适的方法</h3><p>在选择解决跨域问题的方法时，需要考虑安全性、易用性和环境兼容性。对于大多数现代 Web 应用程序，推荐使用 CORS，因为它既安全又灵活。JSONP 可以作为旧系统的一种后备方案，但应谨慎使用，因为它容易受到 XSS 攻击。代理服务器在需要控制或缓存请求时非常有效，但会增加复杂性和成本。</p>
<h2 id="XSS-攻击"><a href="#XSS-攻击" class="headerlink" title="XSS 攻击"></a>XSS 攻击</h2><h3 id="XSS-攻击是什么？"><a href="#XSS-攻击是什么？" class="headerlink" title="XSS 攻击是什么？"></a>XSS 攻击是什么？</h3><p>XSS（跨站脚本攻击，Cross-Site Scripting）是一种在网页上执行恶意脚本的攻击方式，主要目标是在用户的浏览器中执行未经授权的代码。它允许攻击者注入可执行的脚本代码到合法的网页中，这些脚本在其他用户的浏览器中运行时，攻击者可以窃取用户的会话令牌、登录凭证，或者对用户进行其他恶意操作。</p>
<p>XSS 攻击通常分为以下几种类型：</p>
<ol>
<li><p><strong>存储型 XSS</strong>:</p>
<ul>
<li>恶意脚本被永久地存储在目标服务器上（如数据库、消息论坛、访客留言等），当用户访问含有恶意脚本的页面时，脚本就会执行。</li>
</ul>
</li>
<li><p><strong>反射型 XSS</strong>:</p>
<ul>
<li>恶意脚本作为请求的一部分发送给服务器，然后服务器将其作为响应的一部分返回，脚本在用户浏览器执行。这通常涉及到欺骗用户点击一个恶意链接。</li>
</ul>
</li>
<li><p><strong>DOM 型 XSS</strong>:</p>
<ul>
<li>通过恶意脚本修改页面的 DOM 结构实现的攻击，这种攻击完全在客户端进行，不涉及到服务器端的数据处理。</li>
</ul>
</li>
</ol>
<h3 id="如何防范-XSS-攻击？"><a href="#如何防范-XSS-攻击？" class="headerlink" title="如何防范 XSS 攻击？"></a>如何防范 XSS 攻击？</h3><ol>
<li><p><strong>转义输入内容</strong>:</p>
<ul>
<li>对用户输入的内容进行适当的转义处理，特别是在插入到 HTML 页面、JavaScript 代码或 URL 中时。例如，转义 HTML 特殊字符（如 <code>&lt;</code> 变为 <code>&amp;lt;</code>、<code>&gt;</code> 变为 <code>&amp;gt;</code>）。</li>
</ul>
</li>
<li><p><strong>使用内容安全策略（CSP）</strong>:</p>
<ul>
<li>实施内容安全策略（CSP）是防止 XSS 的一种有效方法。CSP 允许网站管理员定义哪些内容源是可信的，可以有效阻止恶意脚本的加载和执行。</li>
</ul>
</li>
<li><p><strong>验证和过滤输入</strong>:</p>
<ul>
<li>对所有用户输入进行严格的验证和过滤，确保输入的内容不包含恶意脚本。</li>
</ul>
</li>
<li><p><strong>使用 HTTP 的 Cookie <code>HttpOnly</code> 属性</strong>:</p>
<ul>
<li>将敏感的 cookie 标记为 <code>HttpOnly</code>，可以阻止 JavaScript 访问这些 cookie，从而减少某些类型的 XSS 攻击。</li>
</ul>
</li>
<li><p><strong>避免直接在 JavaScript 中嵌入用户输入</strong>:</p>
<ul>
<li>避免在 JavaScript 代码中直接使用用户输入的数据，特别是在构建动态 HTML 或执行其他动态操作时。</li>
</ul>
</li>
<li><p><strong>框架的内置 XSS 防护</strong>:</p>
<ul>
<li>许多现代的 Web 开发框架提供了自动的 XSS 防护。了解并正确使用这些框架的安全特性是非常重要的。</li>
</ul>
</li>
<li><p><strong>正则表达式过滤</strong>:</p>
<ul>
<li>使用正则表达式或其他方法过滤可能的攻击向量。</li>
</ul>
</li>
</ol>
<h2 id="git-flow"><a href="#git-flow" class="headerlink" title="git flow"></a>git flow</h2><p>Git Flow 是一种基于 Git 的分支管理策略，由 Vincent Driessen 在 2010 年提出。它定义了一组规范化的分支操作，旨在帮助团队更有效地进行版本控制和软件发布。Git Flow 中的主要分支包括：<code>master</code>、<code>develop</code>、<code>feature</code>、<code>release</code> 和 <code>hotfix</code> 分支。</p>
<h3 id="主要分支"><a href="#主要分支" class="headerlink" title="主要分支"></a>主要分支</h3><ol>
<li><p><strong>Main 分支</strong>:</p>
<ul>
<li>用于存储正式发布的历史。</li>
<li>每次在 main 分支上进行提交，都应该对应一个版本发布。</li>
</ul>
</li>
<li><p><strong>Develop 分支</strong>:</p>
<ul>
<li>开发分支，是为了开发新功能、改进和日常工作而设置的。</li>
<li>通常所有新功能都会首先合并到这个分支。</li>
</ul>
</li>
</ol>
<h3 id="辅助分支"><a href="#辅助分支" class="headerlink" title="辅助分支"></a>辅助分支</h3><ol>
<li><p><strong>Feature 分支</strong>:</p>
<ul>
<li>从 <code>develop</code> 分支派生出来。</li>
<li>用于开发新功能。</li>
<li>完成开发后，会合并回 <code>develop</code> 分支。</li>
<li>分支命名通常遵循 <code>feature/</code> 的模式。</li>
</ul>
</li>
<li><p><strong>Release 分支</strong>:</p>
<ul>
<li>从 <code>develop</code> 分支派生出来，用于准备即将发布的版本。</li>
<li>允许进行最后的调整（如 bug 修复、文档编写等）。</li>
<li>完成后，应该合并到 <code>main</code> 和 <code>develop</code> 分支。</li>
<li>分支命名通常遵循 <code>release/</code> 的模式。</li>
</ul>
</li>
<li><p><strong>Hotfix 分支</strong>:</p>
<ul>
<li>从 <code>main</code> 分支派生出来，用于修复生产环境中的紧急问题。</li>
<li>修复完成后，应该合并到 <code>main</code> 和 <code>develop</code> 分支。</li>
<li>分支命名通常遵循 <code>hotfix/</code> 的模式。</li>
</ul>
</li>
</ol>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol>
<li><p><strong>新功能开发</strong>:</p>
<ul>
<li>从 <code>develop</code> 分支创建新的 <code>feature</code> 分支。</li>
<li>完成开发后，将 <code>feature</code> 分支合并回 <code>develop</code>。</li>
</ul>
</li>
<li><p><strong>发布准备</strong>:</p>
<ul>
<li>当 <code>develop</code> 分支达到一个稳定点，从中创建一个 <code>release</code> 分支。</li>
<li>在 <code>release</code> 分支上完成最后的测试和修订。</li>
<li>完成后，将 <code>release</code> 分支合并到 <code>main</code> 和 <code>develop</code>。</li>
</ul>
</li>
<li><p><strong>紧急修复</strong>:</p>
<ul>
<li>当在生产版本中发现紧急问题时，从 <code>main</code> 分支创建 <code>hotfix</code> 分支。</li>
<li>完成修复后，将 <code>hotfix</code> 分支合并到 <code>main</code> 和 <code>develop</code>。</li>
</ul>
</li>
<li><p><strong>发布</strong>:</p>
<ul>
<li>在 <code>main</code> 分支上的每次合并都应该对应一个新的版本发布。</li>
</ul>
</li>
</ol>
<h3 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h3><ul>
<li><p><strong>优点</strong>:</p>
<ul>
<li>清晰定义了不同类型的分支和它们的用途。</li>
<li>适合大型项目和需要严格发布管理的场景。</li>
</ul>
</li>
<li><p><strong>缺点</strong>:</p>
<ul>
<li>流程相对复杂，可能不适合小团队或轻量级项目。</li>
<li>需要团队成员理解并遵循规定的流程。</li>
</ul>
</li>
</ul>
<h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p>中间人攻击（Man-in-the-Middle Attack，简称 MITM ）是一种常见的网络安全威胁，其中攻击者秘密地拦截并可能更改通信双方之间的通信。在这种攻击中，攻击者插入自己到受害者之间的通信过程，使受害者认为他们正在直接与预期的通信对象进行通信。</p>
<h3 id="如何进行中间人攻击"><a href="#如何进行中间人攻击" class="headerlink" title="如何进行中间人攻击"></a>如何进行中间人攻击</h3><ol>
<li><p><strong>拦截通信</strong>:</p>
<ul>
<li>攻击者首先需要找到一种方式拦截双方之间的通信。这可以通过多种方式实现，比如在无线网络中拦截 Wi-Fi 信号，或者在网络路由中插入恶意设备。</li>
</ul>
</li>
<li><p><strong>监听和&#x2F;或篡改数据</strong>:</p>
<ul>
<li>一旦通信被拦截，攻击者就能够监听通信内容，并且在必要时更改传输的数据。</li>
</ul>
</li>
<li><p><strong>伪装和欺骗</strong>:</p>
<ul>
<li>攻击者可能会伪装成通信的一方，向另一方发送消息。在受害者看来，这些消息看起来是从他们预期的通信对象发送的。</li>
</ul>
</li>
</ol>
<h3 id="常见的中间人攻击类型"><a href="#常见的中间人攻击类型" class="headerlink" title="常见的中间人攻击类型"></a>常见的中间人攻击类型</h3><ol>
<li><p><strong>电子邮件劫持</strong>:</p>
<ul>
<li>攻击者拦截并更改电子邮件内容。</li>
</ul>
</li>
<li><p><strong>Wi-Fi 欺骗</strong>:</p>
<ul>
<li>在公共 Wi-Fi 中，攻击者可以创建一个假冒的 Wi-Fi 热点，诱使用户连接，并拦截通过该网络的数据。</li>
</ul>
</li>
<li><p><strong>HTTPS 欺骗</strong>:</p>
<ul>
<li>攻击者通过伪造证书来拦截和解密 HTTPS 加密的通信。</li>
</ul>
</li>
<li><p><strong>DNS 劫持</strong>:</p>
<ul>
<li>攻击者篡改 DNS 服务器的响应，将用户重定向到恶意网站。</li>
</ul>
</li>
<li><p><strong>会话劫持</strong>:</p>
<ul>
<li>攻击者窃取用户的会话令牌，以获取对用户账户的访问权限。</li>
</ul>
</li>
</ol>
<h3 id="如何防范中间人攻击"><a href="#如何防范中间人攻击" class="headerlink" title="如何防范中间人攻击"></a>如何防范中间人攻击</h3><ol>
<li><p><strong>使用加密协议</strong>:</p>
<ul>
<li>使用 HTTPS、SSL&#x2F;TLS 等加密协议可以保护数据传输的安全。</li>
</ul>
</li>
<li><p><strong>验证证书</strong>:</p>
<ul>
<li>确保网站的证书是有效的，并且由可信的证书颁发机构签发。</li>
</ul>
</li>
<li><p><strong>VPN 使用</strong>:</p>
<ul>
<li>使用虚拟私人网络（VPN）可以在公共网络上提供加密的通信通道。</li>
</ul>
</li>
<li><p><strong>强化 Wi-Fi 安全</strong>:</p>
<ul>
<li>使用强密码和最新的 Wi-Fi 安全协议（如 WPA3）。</li>
</ul>
</li>
</ol>
<h2 id="单点登录-SSO"><a href="#单点登录-SSO" class="headerlink" title="单点登录 SSO"></a>单点登录 SSO</h2><h3 id="单点登录（SSO）的理解"><a href="#单点登录（SSO）的理解" class="headerlink" title="单点登录（SSO）的理解"></a>单点登录（SSO）的理解</h3><p>单点登录（Single Sign-On，简称 SSO）是一种身份验证服务，它允许用户使用一组登录凭证（例如用户名和密码）来访问多个应用程序。目的是通过减少用户需要记住的密码数量和登录次数，来提高用户体验和安全性。</p>
<h3 id="SSO-的工作原理"><a href="#SSO-的工作原理" class="headerlink" title="SSO 的工作原理"></a>SSO 的工作原理</h3><ol>
<li><p><strong>中央认证</strong>:</p>
<ul>
<li>在 SSO 系统中，存在一个中央认证服务器。用户首次尝试访问应用时，会被重定向到这个认证服务器。</li>
</ul>
</li>
<li><p><strong>身份验证</strong>:</p>
<ul>
<li>用户在认证服务器上输入登录凭证（如用户名和密码）。如果凭证有效，认证服务器会创建一个认证令牌（通常是一个临时的、加密的令牌）。</li>
</ul>
</li>
<li><p><strong>令牌颁发</strong>:</p>
<ul>
<li>认证服务器将令牌发放给用户，令牌表明用户已被验证。</li>
</ul>
</li>
<li><p><strong>访问应用</strong>:</p>
<ul>
<li>用户再次尝试访问原来的应用或其他应用时，会携带这个令牌。应用会向认证服务器验证令牌的有效性。</li>
</ul>
</li>
<li><p><strong>授权访问</strong>:</p>
<ul>
<li>如果认证服务器确认令牌有效，用户将被授权访问应用。这一过程对用户来说是透明的，无需再次输入登录凭证。</li>
</ul>
</li>
<li><p><strong>会话创建</strong>:</p>
<ul>
<li>每个应用会为用户创建一个会话，允许用户在不再输入凭证的情况下访问。</li>
</ul>
</li>
</ol>
<h3 id="SSO-的流程"><a href="#SSO-的流程" class="headerlink" title="SSO 的流程"></a>SSO 的流程</h3><ol>
<li><p><strong>登录请求</strong>:</p>
<ul>
<li>用户首次访问某个应用时，会被重定向到 SSO 的认证服务器。</li>
</ul>
</li>
<li><p><strong>输入凭证</strong>:</p>
<ul>
<li>用户在认证服务器上输入登录凭证。</li>
</ul>
</li>
<li><p><strong>身份验证</strong>:</p>
<ul>
<li>认证服务器验证用户凭证。如果验证成功，则生成认证令牌。</li>
</ul>
</li>
<li><p><strong>重定向回应用</strong>:</p>
<ul>
<li>用户携带令牌返回应用。</li>
</ul>
</li>
<li><p><strong>令牌验证</strong>:</p>
<ul>
<li>应用向认证服务器验证令牌的有效性。</li>
</ul>
</li>
<li><p><strong>授权与访问</strong>:</p>
<ul>
<li>一旦令牌被确认有效，应用将允许用户访问，用户无需再次登录。</li>
</ul>
</li>
<li><p><strong>访问其他应用</strong>:</p>
<ul>
<li>当用户访问其他集成了 SSO 的应用时，只需重复令牌验证步骤，无需再次登录。</li>
</ul>
</li>
</ol>
<h3 id="SSO-的优势和挑战"><a href="#SSO-的优势和挑战" class="headerlink" title="SSO 的优势和挑战"></a>SSO 的优势和挑战</h3><ul>
<li><p><strong>优势</strong>:</p>
<ul>
<li>提高用户体验：用户只需记住一套凭证。</li>
<li>增加安全性：减少密码泄露的风险，便于集中管理。</li>
<li>减少管理工作：为管理员提供集中的用户管理和审计。</li>
</ul>
</li>
<li><p><strong>挑战</strong>:</p>
<ul>
<li>集成复杂性：对现有系统进行 SSO 集成可能复杂。</li>
<li>单点故障：认证服务器出现问题可能导致所有应用不可用。</li>
<li>安全风险：如果认证服务器被攻破，所有关联应用都可能受到影响。</li>
</ul>
</li>
</ul>
<h2 id="TypeScript-interface-type"><a href="#TypeScript-interface-type" class="headerlink" title="TypeScript interface type"></a>TypeScript interface type</h2><h3 id="语法和功能"><a href="#语法和功能" class="headerlink" title="语法和功能"></a>语法和功能</h3><ol>
<li><p><strong>扩展方式</strong>:</p>
<ul>
<li><code>interface</code> 可以被扩展和实现（extends 和 implements）。这使得它们非常适合定义对象的形状或类的契约。</li>
<li><code>type</code> 可以通过交集（<code>&amp;</code>）来组合现有类型，但不能使用 <code>extends</code> 或 <code>implements</code>。这使得 <code>type</code> 更适合联合类型或特定函数的签名。</li>
</ul>
</li>
<li><p><strong>声明合并</strong>:</p>
<ul>
<li><code>interface</code> 支持声明合并，即同名的 <code>interface</code> 会被自动合并为一个。</li>
<li><code>type</code> 不支持声明合并。</li>
</ul>
</li>
</ol>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li><p><strong>Interface</strong>:</p>
<ul>
<li>当定义对象的结构或类的契约时，推荐使用 <code>interface</code>。尤其是在定义库的类型或外部 API 的类型定义时，<code>interface</code> 由于其可扩展性，更加合适。</li>
<li>示例：<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Employee</span> <span class="keyword">extends</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">salary</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>Type</strong>:</p>
<ul>
<li>当需要使用联合类型或元组类型时，或者你的类型不适合通过一个简单的接口来表示时，应该使用 <code>type</code>。</li>
<li>示例：<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Operation</span> = <span class="string">&#x27;add&#x27;</span> | <span class="string">&#x27;subtract&#x27;</span> | <span class="string">&#x27;multiply&#x27;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = [<span class="built_in">boolean</span>, <span class="built_in">string</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="性能考虑"><a href="#性能考虑" class="headerlink" title="性能考虑"></a>性能考虑</h3><ul>
<li>在大多数情况下，<code>interface</code> 和 <code>type</code> 在性能上没有显著差异。</li>
<li>但在某些大型项目中，<code>interface</code> 由于其声明合并的特性，可能会稍微提高编译速度。</li>
</ul>
<h3 id="兼容性和扩展性"><a href="#兼容性和扩展性" class="headerlink" title="兼容性和扩展性"></a>兼容性和扩展性</h3><ul>
<li><code>interface</code> 更适合在声明 API 或库的类型定义时使用，因为它们更容易在不同的代码库中被扩展和维护。</li>
<li><code>type</code> 由于其能够表达更复杂的类型组合，提供了更多的灵活性。</li>
</ul>
<h2 id="函数入参实现类型映射"><a href="#函数入参实现类型映射" class="headerlink" title="函数入参实现类型映射"></a>函数入参实现类型映射</h2><p>在 TypeScript 中，你可以使用高级类型特性来实现函数入参的类型映射。这主要涉及到泛型和条件类型的使用。以下是一些实现类型映射的方法：</p>
<h3 id="1-使用泛型"><a href="#1-使用泛型" class="headerlink" title="1. 使用泛型"></a>1. 使用泛型</h3><p>泛型允许你定义一个函数，它可以适用于多种类型而不仅仅是一个。你可以在函数定义时声明一个泛型类型参数，然后在函数体内或作为参数类型使用它。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> output = identity&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;myString&quot;</span>);  <span class="comment">// 输出类型为 &#x27;string&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>T</code> 是一个泛型类型变量，它捕获传递给 <code>identity</code> 的参数类型。这样，你就可以使用这个类型来保证函数的输入和输出类型是一致的。</p>
<h3 id="2-条件类型"><a href="#2-条件类型" class="headerlink" title="2. 条件类型"></a>2. 条件类型</h3><p>条件类型（Conditional Types）允许你根据类型关系创建更复杂的类型表达式。它们在类型映射中非常有用，特别是当你想根据输入类型生成不同的输出类型时。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TypeName</span>&lt;T&gt; =</span><br><span class="line">    T <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="string">&quot;string&quot;</span> :</span><br><span class="line">    T <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="string">&quot;number&quot;</span> :</span><br><span class="line">    T <span class="keyword">extends</span> <span class="built_in">boolean</span> ? <span class="string">&quot;boolean&quot;</span> :</span><br><span class="line">    T <span class="keyword">extends</span> <span class="literal">undefined</span> ? <span class="string">&quot;undefined&quot;</span> :</span><br><span class="line">    T <span class="keyword">extends</span> <span class="title class_">Function</span> ? <span class="string">&quot;function&quot;</span> :</span><br><span class="line">    <span class="string">&quot;object&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> typeOf&lt;T&gt;(<span class="attr">arg</span>: T): <span class="title class_">TypeName</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> arg <span class="keyword">as</span> <span class="title class_">TypeName</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="title function_">typeOf</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// str 类型为 &quot;string&quot;</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="title function_">typeOf</span>(<span class="number">123</span>);     <span class="comment">// num 类型为 &quot;number&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>TypeName</code> 是一个条件类型，它根据传入的类型 <code>T</code> 返回不同的字符串字面量类型。</p>
<h3 id="3-映射类型"><a href="#3-映射类型" class="headerlink" title="3. 映射类型"></a>3. 映射类型</h3><p>映射类型（Mapped Types）允许你根据旧类型创建新类型。它们通过对一个已知的类型的每个属性应用某种变换来工作。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ReadOnly</span>&lt;T&gt; = &#123; <span class="keyword">readonly</span> [K <span class="keyword">in</span> keyof T]: T[K] &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> freeze&lt;T&gt;(<span class="attr">obj</span>: T): <span class="title class_">ReadOnly</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">freeze</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> original = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> frozen = <span class="title function_">freeze</span>(original); <span class="comment">// frozen 类型为 ReadOnly&lt;&#123; a: number; b: number; &#125;&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>ReadOnly</code> 是一个映射类型，它将 <code>T</code> 的所有属性标记为 <code>readonly</code>。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>根据你的具体需求，你可以选择使用泛型、条件类型或映射类型来实现函数参数的类型映射。这些高级类型特性提供了强大的工具，可以帮助你创建灵活且类型安全的代码。</p>
<h2 id="HTTPS-工作原理"><a href="#HTTPS-工作原理" class="headerlink" title="HTTPS 工作原理"></a>HTTPS 工作原理</h2><p>HTTPS（全称为 Hyper Text Transfer Protocol Secure）是 HTTP 的安全版本。它主要通过 SSL&#x2F;TLS 协议来提供身份验证和加密通信，以保护数据在互联网上的传输。以下是 HTTPS 的主要工作原理：</p>
<h3 id="1-加密"><a href="#1-加密" class="headerlink" title="1. 加密"></a>1. 加密</h3><p>HTTPS 使用对称加密和非对称加密相结合的方式来保护数据传输的安全：</p>
<ul>
<li><strong>非对称加密</strong>：在建立连接阶段使用，用于安全地交换对称密钥。</li>
<li><strong>对称加密</strong>：在交换密钥之后，对传输的数据进行加密。</li>
</ul>
<h3 id="2-SSL-x2F-TLS-握手"><a href="#2-SSL-x2F-TLS-握手" class="headerlink" title="2. SSL&#x2F;TLS 握手"></a>2. SSL&#x2F;TLS 握手</h3><p>当你的浏览器连接到一个 HTTPS 网站时，会发生一个叫做 SSL&#x2F;TLS 握手的过程，它包括以下步骤：</p>
<ol>
<li><p><strong>客户端发送加密偏好</strong>：</p>
<ul>
<li>浏览器（客户端）向服务器发送一个“Client Hello”消息，其中包含支持的 SSL&#x2F;TLS 版本、加密算法选项等。</li>
</ul>
</li>
<li><p><strong>服务器响应</strong>：</p>
<ul>
<li>服务器选择一组最合适的加密算法和 SSL&#x2F;TLS 版本，并且发送一个“Server Hello”消息给客户端。同时，服务器还会发送它的公钥和证书。</li>
</ul>
</li>
<li><p><strong>验证服务器证书</strong>：</p>
<ul>
<li>客户端验证服务器的 SSL&#x2F;TLS 证书（通常是由第三方证书机构 CA 颁发的）。证书验证包括检查证书是否过期、是否被撤销，以及是否由可信的 CA 签发。</li>
</ul>
</li>
<li><p><strong>客户端响应</strong>：</p>
<ul>
<li>一旦验证了服务器的证书，客户端生成一个随机的对称加密密钥，并使用服务器的公钥加密这个密钥，然后发送给服务器。</li>
</ul>
</li>
<li><p><strong>服务器解密密钥</strong>：</p>
<ul>
<li>服务器使用其私钥解密客户端发送的对称密钥。</li>
</ul>
</li>
<li><p><strong>加密通信</strong>：</p>
<ul>
<li>从这一步开始，客户端和服务器使用对称密钥来加密通信数据，确保数据传输的安全性。</li>
</ul>
</li>
</ol>
<h3 id="3-安全通信"><a href="#3-安全通信" class="headerlink" title="3. 安全通信"></a>3. 安全通信</h3><p>一旦 SSL&#x2F;TLS 握手完成，客户端和服务器之间的通信就会使用对称加密保护。这意味着即使通信被拦截，没有密钥的第三方也无法解读通信内容。</p>
<h3 id="4-会话结束"><a href="#4-会话结束" class="headerlink" title="4. 会话结束"></a>4. 会话结束</h3><p>当通信结束时，会话密钥会被丢弃。如果用户再次访问服务器，将进行新的握手过程和密钥交换。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>HTTPS 通过结合使用对称和非对称加密，以及通过可信的 CA 验证服务器的身份，有效保护了数据传输的安全性。虽然 HTTPS 在性能上有一定的开销，但它显著提升了网络通信的安全性，对于保护敏感数据，如登录凭据、支付信息等，是非常重要的。</p>
<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>在网络通信中，端口的作用主要是区分同一台主机上的不同服务或进程。端口是一种数字标记，它与 IP 地址一起使用，以标识主机上运行的特定应用程序或服务的实例。端口位于 OSI 七层模型的传输层（第四层），该层还包括定义传输协议，如 TCP（传输控制协议）和 UDP（用户数据报协议）。</p>
<h3 id="端口的作用"><a href="#端口的作用" class="headerlink" title="端口的作用"></a>端口的作用</h3><ol>
<li><p><strong>区分服务</strong>:</p>
<ul>
<li>在一台主机上可能运行着多种网络服务，如 HTTP 服务器、FTP 服务器、邮件服务器等。端口用于区分这些服务，例如，HTTP 默认使用端口 80，而 FTP 默认使用端口 21。</li>
</ul>
</li>
<li><p><strong>通信管理</strong>:</p>
<ul>
<li>端口允许同一物理网络上的多个应用程序同时进行通信，每个应用程序都可以有自己的端口号。</li>
</ul>
</li>
<li><p><strong>连接指定</strong>:</p>
<ul>
<li>在一个网络连接中，一个端口号与一个 IP 地址组合在一起，可以精确地指定通信的发送方和接收方。</li>
</ul>
</li>
</ol>
<h2 id="ESLint-Prettier-Husky-Lint-Staged"><a href="#ESLint-Prettier-Husky-Lint-Staged" class="headerlink" title="ESLint Prettier Husky Lint-Staged"></a>ESLint Prettier Husky Lint-Staged</h2><p>这些工具是现代前端开发中常用的代码质量和风格一致性工具。它们各自扮演着不同的角色：</p>
<h3 id="1-ESLint"><a href="#1-ESLint" class="headerlink" title="1. ESLint"></a>1. ESLint</h3><ul>
<li><strong>用途</strong>：ESLint 是一个静态代码分析工具，用于识别 JavaScript 中的问题。它不仅能找出错误，还能检测出代码风格的问题，如不一致的缩进、未使用的变量等。</li>
<li><strong>特点</strong>：<ul>
<li>可配置性高，可以根据项目需求自定义规则。</li>
<li>可以集成到多数编辑器和构建过程中。</li>
<li>支持 ES6+、React、Vue 等现代 JavaScript 特性。</li>
</ul>
</li>
</ul>
<h3 id="2-Prettier"><a href="#2-Prettier" class="headerlink" title="2. Prettier"></a>2. Prettier</h3><ul>
<li><strong>用途</strong>：Prettier 是一个代码格式化工具，它支持多种语言和文件格式。它强制执行一致的代码风格，确保整个团队的代码看起来和感觉一致。</li>
<li><strong>特点</strong>：<ul>
<li>重点关注代码的外观。</li>
<li>支持 JavaScript、TypeScript、CSS、HTML 等多种语言。</li>
<li>与 ESLint 不同，Prettier 不会检查代码错误。</li>
</ul>
</li>
</ul>
<h3 id="3-Husky"><a href="#3-Husky" class="headerlink" title="3. Husky"></a>3. Husky</h3><ul>
<li><strong>用途</strong>：Husky 是一个用于创建 Git 钩子（hooks）的工具。它可以在执行诸如提交（commit）或推送（push）等 Git 操作时自动运行脚本。</li>
<li><strong>特点</strong>：<ul>
<li>常用于在提交代码前自动运行 Lint 或测试。</li>
<li>防止不符合标准或有问题的代码被提交到仓库。</li>
</ul>
</li>
</ul>
<h3 id="4-Lint-Staged"><a href="#4-Lint-Staged" class="headerlink" title="4. Lint-Staged"></a>4. Lint-Staged</h3><ul>
<li><strong>用途</strong>：Lint-Staged 是一个在 Git 暂存文件（即即将被提交的文件）上运行 Linters 或其他工具的工具。</li>
<li><strong>特点</strong>：<ul>
<li>结合 Husky 使用，只对即将提交的更改执行 Lint 操作，而不是整个项目。</li>
<li>提高了代码质量，确保提交的代码符合预定义的规则。</li>
</ul>
</li>
</ul>
<h3 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h3><p>这些工具常常一起使用，以提高代码质量和提升开发效率：</p>
<ul>
<li>使用 ESLint 来检测代码中的问题和不一致性。</li>
<li>使用 Prettier 来格式化代码，确保一致的风格。</li>
<li>使用 Husky 创建 Git 钩子，在代码提交前自动运行 Lint 和测试。</li>
<li>使用 Lint-Staged 确保只检查和格式化被修改并准备提交的文件，而不是整个代码库。</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>JavaScript 中的迭代器是一个对象，它定义了一个 <code>next()</code> 方法，返回一个包含 <code>done</code> 和 <code>value</code> 属性的对象。当 <code>done</code> 为 <code>true</code> 时，表示迭代器已经遍历完所有元素。</p>
<p>以下是一个简单的迭代器实现示例，它迭代一个数字数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createIterator</span>(<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">next</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> currentIndex &lt; array.<span class="property">length</span> ?</span><br><span class="line">                &#123; <span class="attr">value</span>: array[currentIndex++], <span class="attr">done</span>: <span class="literal">false</span> &#125; :</span><br><span class="line">                &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">const</span> myArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> myIterator = <span class="title function_">createIterator</span>(myArray);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myIterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myIterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myIterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myIterator.<span class="title function_">next</span>()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>createIterator</code> 函数接收一个数组并返回一个迭代器。迭代器的 <code>next</code> 方法在每次被调用时返回数组的下一个元素，直到数组被完全遍历。</p>
<p>请注意，这个迭代器是手动实现的，用于展示迭代器的基本原理。在实际的 JavaScript 开发中，你通常可以使用 ES6 提供的内置迭代器，比如通过 <code>for...of</code> 循环、展开操作符 <code>...</code> 或 <code>Array.prototype.entries()</code> 方法等来遍历可迭代对象。</p>
<h2 id="防抖（Debouncing）"><a href="#防抖（Debouncing）" class="headerlink" title="防抖（Debouncing）"></a>防抖（Debouncing）</h2><p>防抖（Debouncing）是一种优化技术，用于确保一个函数在特定时间内不被频繁调用。它是通过在指定时间内延迟函数的执行来实现的。如果在这段延迟时间内再次触发该函数，那么原来的延迟调用会被取消，并重新开始计算延迟时间。这对于一些需要频繁触发但执行成本较高的操作（如窗口大小调整、输入框内容变化等）非常有用。</p>
<p>下面是一个简单的防抖函数的实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">const</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">onResize</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;窗口大小变化了！&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> debouncedResize = <span class="title function_">debounce</span>(onResize, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, debouncedResize);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>debounce</code> 函数接受两个参数：一个要执行的函数 <code>func</code> 和延迟时间 <code>wait</code>。返回的函数会在调用后等待指定的 <code>wait</code> 毫秒数，然后执行 <code>func</code>。如果在这个等待时间内再次被调用，之前的等待就会被清除，并重新开始计时。</p>
<p>这个防抖函数的应用示例是窗口调整大小事件的处理函数 <code>onResize</code>。通过使用 <code>debounce</code>，我们可以确保在窗口调整大小的过程中，<code>onResize</code> 函数不会被频繁调用，而是在调整结束后的 500 毫秒才执行一次。</p>
<h2 id="js原型链和利用原型链实现集成"><a href="#js原型链和利用原型链实现集成" class="headerlink" title="js原型链和利用原型链实现集成"></a>js原型链和利用原型链实现集成</h2><p>在JavaScript中，原型链是实现继承的主要机制。每个对象都有一个内部链接到另一个对象，即其“原型”，该原型对象自身也有一个原型，以此类推，形成了一个“原型链”。当试图访问一个对象的属性或方法时，如果对象本身没有这个属性或方法，JavaScript引擎就会沿着原型链向上查找，直到找到该属性或方法或到达原型链的末端（<code>null</code>）。</p>
<h3 id="JavaScript的原型"><a href="#JavaScript的原型" class="headerlink" title="JavaScript的原型"></a>JavaScript的原型</h3><p>每个JavaScript对象在创建时都会关联另一个对象，这个关联的对象就是我们所说的“原型”。对象可以通过其原型继承属性和方法。在JavaScript中，几乎所有的对象都是<code>Object</code>的实例，它们在默认情况下都会继承<code>Object.prototype</code>的属性和方法，除非明确地将对象的原型设置为<code>null</code>。</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>原型链的基础是原型继承。每个构造函数都有一个<code>prototype</code>属性，指向一个对象，这个对象包含了可以由该构造函数的所有实例继承的属性和方法。当创建一个对象实例时（使用<code>new</code>操作符），这个实例内部的<code>[[Prototype]]</code>（或<code>__proto__</code>，虽然后者是非标准的，但在大多数浏览器中可以使用）会被赋值为构造函数的<code>prototype</code>对象。</p>
<p>当访问对象的一个属性或方法时，如果对象本身没有这个属性或方法，JavaScript会继续在对象的原型（即<code>__proto__</code>指向的对象）中查找，如果还没找到，就去原型的原型中查找，依此类推，直到找到该属性或方法，或者在原型链的末端（<code>Object.prototype.__proto__</code>，其值为<code>null</code>）停止查找。</p>
<h3 id="实现继承"><a href="#实现继承" class="headerlink" title="实现继承"></a>实现继承</h3><p>在JavaScript中，可以通过原型链来实现继承。这里是一个基本的例子，展示如何使用原型链实现继承：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="title class_">Animal</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name); <span class="comment">// 调用父类构造函数，继承属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// 设置Dog的原型为Animal的实例，继承方法</span></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Dog</span>; <span class="comment">// 修复构造函数指向</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bark</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Woof!&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myDog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Rex&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myDog.<span class="title function_">getName</span>()); <span class="comment">// 输出: Rex</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myDog.<span class="title function_">bark</span>()); <span class="comment">// 输出: Woof!</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Dog</code>继承自<code>Animal</code>。首先，通过<code>Animal.call(this, name)</code>继承属性。接着，通过<code>Dog.prototype = Object.create(Animal.prototype)</code>让<code>Dog</code>的原型指向<code>Animal</code>的原型的一个实例，从而继承<code>Animal</code>原型上的方法。最后，修复<code>Dog.prototype.constructor</code>指向，确保它指回<code>Dog</code>本身，而不是<code>Animal</code>。</p>
<p>通过这种方式，我们能够利用原型链在JavaScript中实现继承，让不同的对象共享方法，同时保持各自的属性。</p>
<h2 id="HTTP-amp-amp-TCP"><a href="#HTTP-amp-amp-TCP" class="headerlink" title="HTTP &amp;&amp; TCP"></a>HTTP &amp;&amp; TCP</h2><p>HTTP（超文本传输协议）和TCP（传输控制协议）是互联网中常用的两种协议，它们在网络通信中扮演着不同的角色。</p>
<h3 id="TCP（传输控制协议）"><a href="#TCP（传输控制协议）" class="headerlink" title="TCP（传输控制协议）"></a>TCP（传输控制协议）</h3><p>TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议。它的主要特点和功能包括：</p>
<ul>
<li><strong>面向连接</strong>：在数据传输开始之前，TCP会在两端建立一个稳定的连接，这一过程通常称为“三次握手”。</li>
<li><strong>可靠传输</strong>：TCP通过序列号、确认应答、重传机制等确保数据完整性和顺序性。即使在网络条件不佳的情况下，TCP也能保证数据包的正确传输。</li>
<li><strong>流量控制</strong>：TCP使用滑动窗口机制来控制发送方的数据传输速率，防止接收方因来不及处理而丢失数据。</li>
<li><strong>拥塞控制</strong>：TCP还有一系列拥塞控制算法，如慢启动、拥塞避免、快速重传和快速恢复，用以在整个网络中避免或控制拥塞情况。</li>
</ul>
<h3 id="HTTP（超文本传输协议）"><a href="#HTTP（超文本传输协议）" class="headerlink" title="HTTP（超文本传输协议）"></a>HTTP（超文本传输协议）</h3><p>HTTP是应用层的协议，用于在网络中传输超文本（如HTML文档）从Web服务器到本地浏览器。HTTP的主要特点包括：</p>
<ul>
<li><strong>无连接</strong>：HTTP协议自身是无状态的，意味着每次请求之间相互独立，服务器不会保留任何数据（状态）来关联两个请求。不过，现代Web应用通常使用Cookies等机制来维护状态。</li>
<li><strong>简单快速</strong>：客户向服务器请求服务时只需传送请求方法和路径。HTTP的简单性使得它非常快速。</li>
<li><strong>灵活</strong>：HTTP允许传输任意类型的数据对象，只需在头部字段中加入内容类型即可。</li>
<li><strong>无状态但可使用Cookie维持会话</strong>：虽然HTTP本身是无状态的，但引入Cookie后，可以在客户端保留状态信息，以支持诸如用户登录状态、购物车等功能。</li>
</ul>
<h3 id="关系和区别"><a href="#关系和区别" class="headerlink" title="关系和区别"></a>关系和区别</h3><ul>
<li><strong>层级关系</strong>：TCP位于传输层，为HTTP等应用层协议提供稳定可靠的数据传输服务。HTTP建立在TCP提供的连接基础上，HTTP的请求和响应过程都是通过TCP连接完成的。</li>
<li><strong>用途区别</strong>：TCP是一种通用的连接协议，提供可靠的数据传输功能，而HTTP专注于规范客户端和服务器之间的通信格式和规则，用于传输超文本等数据。</li>
</ul>
<p>简而言之，TCP为HTTP提供了可靠的传输基础，而HTTP定义了如何通过这种传输方式来交换超文本等信息。</p>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTPS（安全超文本传输协议）是HTTP的安全版本，在HTTP和TCP之间加入了SSL&#x2F;TLS协议层，用以加密数据传输。HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性，防止数据在传输过程中被窃听、篡改或伪造。</p>
<h3 id="HTTPS如何实现安全"><a href="#HTTPS如何实现安全" class="headerlink" title="HTTPS如何实现安全"></a>HTTPS如何实现安全</h3><ol>
<li><p><strong>加密</strong>：HTTPS使用对称加密和非对称加密相结合的方式来加密数据。在握手阶段，使用非对称加密算法交换对称密钥，一旦密钥交换成功，之后的通信就使用对称加密算法进行，这样既保证了加密的安全性，又提高了数据传输的效率。</p>
</li>
<li><p><strong>认证</strong>：HTTPS利用证书认证机构（CA）颁发的SSL&#x2F;TLS证书对服务器进行身份验证。这确保了客户端与真正的服务器建立连接，而不是被中间人攻击者所欺骗。当用户访问一个HTTPS网站时，浏览器会自动检查服务器的SSL证书是否由受信任的CA签发、是否已过期、是否被撤销，以及证书中的域名是否与正在访问的网站域名一致。</p>
</li>
<li><p><strong>数据完整性</strong>：通过消息摘要（如SHA）和消息认证码（MAC）等技术，HTTPS可以检测数据传输过程中是否被篡改。即使数据被截获，攻击者也无法不被察觉地修改数据，因为任何改动都会导致接收方验证失败。</p>
</li>
</ol>
<h3 id="HTTPS的工作流程"><a href="#HTTPS的工作流程" class="headerlink" title="HTTPS的工作流程"></a>HTTPS的工作流程</h3><ol>
<li><p><strong>客户端发送HTTPS请求</strong>：用户在浏览器中输入一个HTTPS网址，浏览器向服务器发起一个安全连接请求。</p>
</li>
<li><p><strong>服务器回应并提供证书</strong>：服务器将自己的SSL证书（包括公钥）发送给客户端。</p>
</li>
<li><p><strong>客户端验证证书</strong>：客户端验证证书的合法性，包括证书是否由受信任的CA签发、是否过期或撤销，以及证书的域名是否与网站匹配。</p>
</li>
<li><p><strong>密钥交换</strong>：一旦证书验证通过，客户端会生成一个随机的对称加密密钥（会话密钥），并使用服务器的公钥加密这个密钥，发送给服务器。</p>
</li>
<li><p><strong>服务器解密并建立加密会话</strong>：服务器使用自己的私钥解密接收到的会话密钥，然后双方便利用这个会话密钥进行对称加密通信。</p>
</li>
<li><p><strong>安全通信</strong>：此时，客户端和服务器间的通信都是加密的，第三方无法直接读取或篡改传输的数据。</p>
</li>
</ol>
<p>通过这种方式，HTTPS为网络通信提供了一层强大的安全保护，使得用户数据在互联网上的传输变得更加安全可靠。</p>
<h2 id="前端缓存技术"><a href="#前端缓存技术" class="headerlink" title="前端缓存技术"></a>前端缓存技术</h2><p>前端缓存技术是一种重要的性能优化手段，它可以减少服务器的负载，加快网页的加载速度，提升用户体验。前端缓存大体上可以分为两大类：HTTP缓存和浏览器存储。</p>
<h3 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h3><p>HTTP缓存利用的是HTTP头信息中的缓存控制指令来实现的，主要分为强缓存和协商缓存：</p>
<ol>
<li><p><strong>强缓存</strong>：浏览器不会向服务器发送请求，直接从缓存中读取资源。它主要通过<code>Cache-Control</code>的<code>max-age</code>指令和<code>Expires</code>头实现。如果缓存的资源还未过期，浏览器就会直接使用缓存的资源。</p>
</li>
<li><p><strong>协商缓存</strong>：浏览器会向服务器发送请求，询问资源是否有更新。主要通过<code>Last-Modified</code>&#x2F;<code>If-Modified-Since</code>和<code>ETag</code>&#x2F;<code>If-None-Match</code>这两对头信息来控制。如果服务器上的资源没有变化，服务器会返回304状态码，告诉浏览器可以从缓存中加载资源。</p>
</li>
</ol>
<h3 id="浏览器存储"><a href="#浏览器存储" class="headerlink" title="浏览器存储"></a>浏览器存储</h3><p>浏览器提供了几种客户端存储数据的方法，可以用于缓存更多类型的数据，包括应用程序的数据、用户信息等：</p>
<ol>
<li><p><strong>Cookie</strong>：最古老的客户端存储技术。由于大小限制（每个域名下约4KB）、每次HTTP请求都会携带Cookie等缺点，现在多用于存储识别用户身份的小块数据。</p>
</li>
<li><p><strong>Web Storage（本地存储）</strong>：包括<code>localStorage</code>和<code>sessionStorage</code>，提供更大的存储空间（约5MB），并且只在客户端进行数据的保存和访问。<code>localStorage</code>用于长期存储数据，浏览器关闭后数据不会被清除；<code>sessionStorage</code>的数据在页面会话结束时被清除（即浏览器关闭时）。</p>
</li>
<li><p><strong>IndexedDB</strong>：是一种低级API，用于客户端存储大量结构化数据。这个API提供丰富的查询功能，并能够创建和维护一个数据库。IndexedDB适合存储大量数据和进行复杂查询，存储空间比Web Storage大得多。</p>
</li>
<li><p><strong>Service Worker缓存</strong>：Service Workers提供了一个可编程的网络代理，在客户端浏览器背后，允许你控制页面上的网络请求。通过使用Service Workers，可以截取网络请求，从缓存中提供资源，即使在离线时也能加载页面。</p>
</li>
</ol>
<h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><ul>
<li><strong>可缓存性</strong>：决定哪些资源可以被缓存。</li>
<li><strong>过期机制</strong>：设置资源过期时间，控制缓存多久需要更新。</li>
<li><strong>缓存验证</strong>：检查缓存的资源是否仍然有效。</li>
<li><strong>重新验证</strong>：更新过期的缓存资源。</li>
</ul>
<p>前端缓存的合理应用能显著提高应用性能，降低延迟，减少服务器负担。开发者需要根据实际需求选择合适的缓存策略和技术。</p>
<h2 id="虚拟-dom"><a href="#虚拟-dom" class="headerlink" title="虚拟 dom"></a>虚拟 dom</h2><p>虚拟DOM（Virtual DOM）是一个编程概念，其中UI的状态被保留在内存中，通过一个轻量级的JS对象来表示，而不是直接与真实的DOM同步。当状态变化时，虚拟DOM提供了一种计算出最小变更的方法来更新真实DOM，这种机制旨在提高前端应用的性能和效率。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>虚拟DOM的工作原理可以分为三个主要步骤：</p>
<ol>
<li><p><strong>创建虚拟DOM树</strong>：应用的UI结构用JavaScript对象形式创建，这些对象结构构成了一个虚拟DOM树。相比于真实DOM操作，操作JavaScript对象要快得多。</p>
</li>
<li><p><strong>比较虚拟DOM树</strong>：当应用状态变化时，会创建一个新的虚拟DOM树。然后，新旧虚拟DOM树通过一个“差异对比”算法（diffing algorithm）进行比较，以确定实际发生变化的部分。这个过程称为“对比”。</p>
</li>
<li><p><strong>更新真实DOM</strong>：一旦找出变化的部分，这些最小的变更将应用于真实的DOM树上，从而使其与虚拟DOM的最新状态同步。这个过程称为“重绘”。</p>
</li>
</ol>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>虚拟DOM提供了几个关键优势：</p>
<ul>
<li><strong>性能提升</strong>：操作真实DOM是昂贵的（性能开销大），因为它涉及到浏览器的布局计算和重绘。虚拟DOM通过批量和最小化DOM操作减少这些开销，从而提高性能。</li>
<li><strong>跨平台</strong>：虚拟DOM不依赖真实DOM，可以在服务器、移动设备等环境下运行，实现跨平台应用。</li>
<li><strong>简化编程模型</strong>：开发者可以像操作普通JavaScript对象那样操作虚拟DOM，无需担心后台的复杂DOM操作和性能问题，简化了前端开发的复杂性。</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>React是最早采用虚拟DOM概念的前端库之一，它通过虚拟DOM来提升渲染性能。Vue和Angular等其他现代前端框架也采用了类似的机制来优化DOM操作和更新过程。</p>
<p>总之，虚拟DOM通过在JavaScript和真实DOM之间提供一个抽象层，使得前端开发更高效、更简单，并且能够提高应用的性能。</p>
<h2 id="MVC-MVVM"><a href="#MVC-MVVM" class="headerlink" title="MVC MVVM"></a>MVC MVVM</h2><p>React和Vue是目前最流行的前端JavaScript库和框架之一，它们分别采用了不同的架构模式——React通常与MVC（模型-视图-控制器）模式结合使用，而Vue则基于MVVM（模型-视图-视图模型）模式。理解这两种架构模式有助于深入理解React和Vue的设计理念及其在实际应用中的差异。</p>
<h3 id="React与MVC模式"><a href="#React与MVC模式" class="headerlink" title="React与MVC模式"></a>React与MVC模式</h3><p>React是一个用于构建用户界面的库，它主要关注视图层。在React应用中，可以将React视为MVC模式中的“V”（视图），而数据（模型）和逻辑（控制器）通常通过其他库或框架（如Redux、MobX等）来管理。</p>
<ul>
<li><strong>模型（Model）</strong>：代表应用的数据。在React中，模型通常是以状态（state）和属性（props）的形式存在。</li>
<li><strong>视图（View）</strong>：用户界面。React组件构成了应用的视图层，负责渲染数据模型到UI。</li>
<li><strong>控制器（Controller）</strong>：业务逻辑和数据操作。在React中，组件本身或使用Redux等状态管理库承担了部分控制器的角色，负责响应用户输入，处理事件，以及更新模型。</li>
</ul>
<p>React的特点是声明式编程和组件化结构，使得构建大型应用时能够保持高效的更新和渲染。</p>
<h3 id="Vue与MVVM模式"><a href="#Vue与MVVM模式" class="headerlink" title="Vue与MVVM模式"></a>Vue与MVVM模式</h3><p>Vue是一个渐进式JavaScript框架，设计上采用了MVVM模式，目的是通过数据绑定和DOM的抽象来简化开发者编写交互逻辑的复杂度。</p>
<ul>
<li><strong>模型（Model）</strong>：代表JavaScript对象中的数据。</li>
<li><strong>视图（View）</strong>：HTML模板，用户看到和与之交互的界面。</li>
<li><strong>视图模型（ViewModel）</strong>：Vue实例。Vue的核心是<code>ViewModel</code>，它是连接视图和数据的桥梁。通过响应式和双向数据绑定，<code>ViewModel</code>自动将数据模型的变更反映到视图上，同时将视图上的更改（如用户输入）同步回数据模型。</li>
</ul>
<p>Vue的MVVM模式使得开发者几乎不需要直接操作DOM，只需要关注数据的状态，框架会负责渲染和更新视图。</p>
<h3 id="比较-1"><a href="#比较-1" class="headerlink" title="比较"></a>比较</h3><ul>
<li><strong>数据绑定</strong>：Vue在MVVM模式下提供了双向数据绑定，即视图的变化能自动更新到数据模型，数据模型的更新也能即时反映到视图上。React则采用单向数据流，组件状态（state）更新后，会重新渲染组件和子组件。</li>
<li><strong>模板vs JSX</strong>：Vue使用基于HTML的模板语法，它使得定义组件的结构更加直观。React采用JSX，一个看起来类似HTML的JavaScript扩展，通过JSX可以在JavaScript中以声明方式描述UI组件。</li>
<li><strong>灵活性和学习曲线</strong>：React提供了更多的JavaScript表达能力，给开发者带来了更高的灵活性，但相应的学习成本也更高。Vue的学习曲线通常认为更平滑，尤其是对于那些熟悉HTML和JavaScript基础的开发者。</li>
</ul>
<p>两者都提供了高效的方式来构建现代Web应用，选择哪一个主要取决于项目需求、团队熟悉度和个人偏好。</p>
]]></content>
      <categories>
        <category>note</category>
      </categories>
  </entry>
  <entry>
    <title>npm install 的不同方式</title>
    <url>/2023/08/05/npm-install-ways/</url>
    <content><![CDATA[<h2 id="npm-install-g-–save"><a href="#npm-install-g-–save" class="headerlink" title="npm install -g –save ?"></a>npm install -g –save ?</h2><span id="more"></span>

<ul>
<li><code>npm install</code>（在包目录中）<br>根据<code>package.json</code>文件，将依赖安装到包目录中<code>node_modules</code>文件夹</li>
<li><code>npm install &quot;module-name&quot;</code><br>安装特定依赖到包目录下</li>
<li><code>npm install -g &quot;module-name&quot;</code><br><code>-g</code>表明将模块安装到全局，将包安装到<code>prefix</code>文件夹而不是当前工作目录，<code>&#123;prefix&#125;/lib/node_modules</code><br>可通过以下命令查看 npm 相关配置：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>
<img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308051125123.png"></li>
<li><code>npm install --save &quot;module-name&quot;</code><br><code>--save</code>表明模块安装并写入<code>package.json</code>的<code>dependencies</code>节点。<code>--save</code>等同于<code>-S</code>。</li>
<li><ul>
<li><code>npm install --save-prod &quot;module-name&quot;</code><br>包将出现在<code>dependencies</code>中，这是默认值</li>
</ul>
</li>
<li><ul>
<li><code>npm install --save-dev &quot;module-name&quot;</code><br>包将出现在<code>devDependencies</code>中，运行<code>npm install --production</code>或<code>NODE_ENV</code>值为<code>production</code>时<strong>不会</strong>自动下载模块。<code>--save-dev</code>等同于<code>-D</code>。</li>
</ul>
</li>
</ul>
<p><code>npm uninstall &quot;module_name&quot;</code>删除依赖同理。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>devDependencies</code>节点下模块是开发时需要使用的，如辅助开发的压缩，部署后不需要，所以使用<code>--save-dev</code>形式安装。<br><code>dependencies</code>节点下模块是运行时必备的，故采用<code>--save</code>（等同于<code>--save-prod</code>）安装。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly9ucG0ubm9kZWpzLmNuL2NsaS92OS9jb21tYW5kcy9ucG0taW5zdGFsbA==">npm中文网——npm-install<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbGltaXRjb2RlL3AvNzkwNjQ0Ny5odG1s">NPM install -save 和 -save-dev 傻傻分不清<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>frontend</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>中南云麓谷研发部2023招新面试题</title>
    <url>/2023/08/04/recruitment-2023/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>请不要被以下的内容吓走，也许从目前的你看来是太过困难；请放心，只要愿意学习，你会做的比图示更好。</p>
<h2 id="理论学习"><a href="#理论学习" class="headerlink" title="理论学习"></a>理论学习</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="html"><a href="#html" class="headerlink" title="html"></a>html</h4><h5 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h5><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXZzNDExTTdhVA==">为初学者准备的：HTML 速成<i class="fa fa-external-link-alt"></i></span></p>
<h5 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h5><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRNTA==">MDN Web docs<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9odG1sL2h0bWwtdHV0b3JpYWwuaHRtbA==">HTML教程|菜鸟教程<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cudzNzY2hvb2wuY29tLmNuL3RhZ3MvaW5kZXguYXNw">W3school HTML<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>

<h4 id="css"><a href="#css" class="headerlink" title="css"></a>css</h4><h5 id="视频-1"><a href="#视频-1" class="headerlink" title="视频"></a>视频</h5><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWJXNDExUjdoZw==">为初学者准备的：CSS 速成<i class="fa fa-external-link-alt"></i></span></p>
<h5 id="文档-1"><a href="#文档-1" class="headerlink" title="文档"></a>文档</h5><p>与HTML站点相同，不再复述。</p>
<h4 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h4><h5 id="视频-2"><a href="#视频-2" class="headerlink" title="视频"></a>视频</h5><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMUp0NDExRDdqNg==">为初学者准备的：JavaScript 速成<i class="fa fa-external-link-alt"></i></span></p>
<h5 id="文档-2"><a href="#文档-2" class="headerlink" title="文档"></a>文档</h5><p>与HTML站点相同，不再复述。<br><span class="exturl" data-url="aHR0cHM6Ly96aC5qYXZhc2NyaXB0LmluZm8v">现代JavaScript教程<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="提高"><a href="#提高" class="headerlink" title="提高"></a>提高</h3><p><a href="%22https://zhuanlan.zhihu.com/p/260177225%22">HTML5 + CSS3</a></p>
<h2 id="招新作业"><a href="#招新作业" class="headerlink" title="招新作业"></a>招新作业</h2><h3 id="基础题"><a href="#基础题" class="headerlink" title="基础题"></a>基础题</h3><p>请设计并完成如下页面：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308021013086.jpeg"></p>
<h3 id="提高题"><a href="#提高题" class="headerlink" title="提高题"></a>提高题</h3><p>请根据<strong>HTML5和CSS3规范</strong>复现如下页面，其中图片资源在<strong>文末</strong>提供。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308050951824.jpeg"></p>
<h4 id="基础要求"><a href="#基础要求" class="headerlink" title="基础要求"></a>基础要求</h4><p>了解并合理使用<strong>盒子模型</strong>、<strong>flex 布局</strong>以及其他 CSS 知识完成网页布局，各模块布局合理。</p>
<h4 id="提高部分"><a href="#提高部分" class="headerlink" title="提高部分"></a>提高部分</h4><p>在基础要求的基础上，自主完善网页功能，包括但不限于网页间的联动、表单的使用等。请大胆发挥你的创意。</p>
<h3 id="进阶题"><a href="#进阶题" class="headerlink" title="进阶题"></a>进阶题</h3><p>请在以下二题中<mark class="label success">任选其一</mark>完成。</p>
<h4 id="微信小程序（推荐选做）"><a href="#微信小程序（推荐选做）" class="headerlink" title="微信小程序（推荐选做）"></a>微信小程序（推荐选做）</h4><p>利用相关知识完成一个主题为<strong>个人博客</strong>的微信小程序，示例如下（仅作参考）：</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://img1.imgtp.com/2023/08/01/PasamiB3.png"></div><div class="group-picture-column"><img data-src="https://img1.imgtp.com/2023/08/01/rpPMYMzf.png"></div><div class="group-picture-column"><img data-src="https://img1.imgtp.com/2023/08/01/vhRFbkzJ.png"></div></div></div>

<h5 id="基础要求-1"><a href="#基础要求-1" class="headerlink" title="基础要求"></a>基础要求</h5><p>自主完成小程序页面的设计，美观、简洁，且要求符合主题，各元素设置符合<strong>个人博客</strong>的要求。小程序组件功能齐全，可在本地调试环境流畅、正常运行。</p>
<h5 id="提高部分-1"><a href="#提高部分-1" class="headerlink" title="提高部分"></a>提高部分</h5><p>在完成基础要求的前提下，可以选择实现以下功能：</p>
<ol>
<li>完成一篇自己的博客并展示在首页上，并且可以通过主页转跳到对应博客</li>
<li>完成个人签名的编辑与保存功能</li>
<li>完成点赞数、浏览数等的统计功能</li>
<li>实现前后端分离设计</li>
</ol>
<h4 id="个人网站"><a href="#个人网站" class="headerlink" title="个人网站"></a>个人网站</h4><p>利用<span class="exturl" data-url="aHR0cHM6Ly9jbi52dWVqcy5vcmcv">Vue<i class="fa fa-external-link-alt"></i></span>或<span class="exturl" data-url="aHR0cHM6Ly9yZWFjdC5kb2NzY2hpbmEub3JnLw==">React<i class="fa fa-external-link-alt"></i></span>等流行前端框架完成主题为<strong>个人博客</strong>的网站。</p>
<h5 id="基础要求-2"><a href="#基础要求-2" class="headerlink" title="基础要求"></a>基础要求</h5><p>自主完成网页页面的设计，美观、简洁，且要求符合主题，各元素设置符合<strong>个人博客</strong>的要求。网页元素功能齐全，可在本地环境流畅、正常运行。</p>
<h5 id="提高部分-2"><a href="#提高部分-2" class="headerlink" title="提高部分"></a>提高部分</h5><p>与微信小程序提高部分相同。</p>
<h2 id="图片资源"><a href="#图片资源" class="headerlink" title="图片资源"></a>图片资源</h2><p>提高题所需要的图片资源请前往<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2plcnJ5NzY1L3JlY3J1aXRtZW50LWltYWdlcy5naXQ=">github<i class="fa fa-external-link-alt"></i></span>下载，如不能访问请使用<strong>科学上网</strong>方式。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308021036634.png"><br>其余题目所有图片素材自行寻找即可，不做统一规定。</p>
<p>可能用上的素材及工具网站：<br><span class="exturl" data-url="aHR0cHM6Ly93d3cucGV4ZWxzLmNvbS96aC1jbi8=">Pexels<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWNvbmZvbnQuY24v">阿里巴巴矢量图<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWxvdmVpbWcuY29tL3poLWNuL2Nyb3AtaW1hZ2U=">iLoveIMG免费图片裁剪<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="仍有疑问？"><a href="#仍有疑问？" class="headerlink" title="仍有疑问？"></a>仍有疑问？</h2><p>请通过本网站的评论系统（科学上网）提出，后续统一更新在本博客中。保持关注！</p>
]]></content>
      <categories>
        <category>recruitment</category>
      </categories>
      <tags>
        <tag>csu</tag>
        <tag>university</tag>
        <tag>software engineering</tag>
        <tag>frontend</tag>
      </tags>
  </entry>
  <entry>
    <title>SOA复习大纲</title>
    <url>/2024/01/12/soa-review-key/</url>
    <content><![CDATA[<h2 id="SOA技术简述"><a href="#SOA技术简述" class="headerlink" title="SOA技术简述"></a>SOA技术简述</h2><h3 id="为什么要引入SOA、SOA要解决的问题"><a href="#为什么要引入SOA、SOA要解决的问题" class="headerlink" title="为什么要引入SOA、SOA要解决的问题"></a>为什么要引入SOA、SOA要解决的问题</h3><p>为什么要引入SOA：需求拉动、技术推动</p>
<ol>
<li><strong>Internet环境下的企业交互</strong>：现代企业已经不再是封闭的企业，市场分工的日益专业化使得<strong>企业之间可能存在大量频繁的交互行为</strong>，以发挥各自的竞争优势。这种业务上的交互体现为<strong>企业业务流程的交互&#x2F;互操作</strong>，同时一定需要企业信息系统的支持，因此体现为<strong>软件系统之间的集成与互操作</strong></li>
<li><strong>异构系统的集成与互操作</strong>：技术平台不同、软件体系结构不同、数据格式不同</li>
<li><strong>频繁变化的互操作与集成需求</strong>：企业的业务是频繁变化的，IT应用系统要能够快速支持这种变化的需求，需要迅速、敏捷、高效的调整业务应用系统</li>
</ol>
<p>SOA要解决的问题：</p>
<ol>
<li>分布式企业间业务的协同</li>
<li>通过Internet连接在一起的异构企业应用软件系统的集成、交互与互操作</li>
<li>当业务(Business)发生变化时，IT系统能够快速响应</li>
</ol>
<span id="more"></span>

<h3 id="什么是SOA、核心要素及其理解"><a href="#什么是SOA、核心要素及其理解" class="headerlink" title="什么是SOA、核心要素及其理解"></a>什么是SOA、核心要素及其理解</h3><p><strong>SOA&#x3D;Service(服务)+体系结构(Architecture)</strong></p>
<ul>
<li>业务模型：企业向其客户暴露的一系列<strong>业务</strong>——服务</li>
<li>体系结构：一组<strong>体系结构设计原则与模式</strong>，强调模块化、封装、松散耦合、分离关注点、可复用、可组合性、接口与实现分离等特性</li>
<li>软件实现方式：一种<strong>编程模式</strong>，包括一系列的标准、开发工具、开发过程指南、运行时基础架构</li>
</ul>
<p><strong>SOA三要素：标准化封装、复用、松耦合可编排</strong><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401121738410.png"></p>
<h3 id="SOA的典型优势"><a href="#SOA的典型优势" class="headerlink" title="SOA的典型优势"></a>SOA的典型优势</h3><ol>
<li><strong>分布式异构系统的集成与互操作</strong></li>
<li><strong>完全的松散耦合</strong><ul>
<li>位置透明</li>
<li>与具体的实现细节无关(通过接口调用)</li>
<li>标准化的通讯协议（XML-Based）</li>
</ul>
</li>
<li><strong>大数据量低频率访问</strong></li>
<li><strong>基于文本的消息传递</strong>：基于文本的消息本身不包含任何处理逻辑和数据类型，因此服务间只传递文本，双方不存在兼容性问题</li>
<li><strong>上下文无关</strong>：在SOA中，在设计阶段，服务不需要了解它们将来可能被复用的环境，即独立于服务使用者的上下文</li>
<li><strong>大粒度复用</strong>：更多的关注诸如业务过程&#x2F;业务活动级别的复用，复用效率更高</li>
</ol>
<h3 id="SOA适合应用的场景"><a href="#SOA适合应用的场景" class="headerlink" title="SOA适合应用的场景"></a>SOA适合应用的场景</h3><p><strong>协同—交互—异构—分布式环境—可能频繁变化</strong></p>
<h3 id="10种SOA应用场景及相应体系结构模式"><a href="#10种SOA应用场景及相应体系结构模式" class="headerlink" title="10种SOA应用场景及相应体系结构模式"></a>10种SOA应用场景及相应体系结构模式</h3><ul>
<li><strong>硬连线(Hard-wired)</strong></li>
<li><strong>点对点的服务发布与调用(P2P)</strong></li>
<li><ul>
<li>发布(Publish)：为了使服务可访问，需要发布服务描述以使服务使用者可以发现它。</li>
</ul>
</li>
<li><ul>
<li>发现(Find)：服务请求者定位服务，方法是查询服务注册中心来找到满足其标准的服务。</li>
</ul>
</li>
<li><ul>
<li>绑定(Bind)和调用(invoke)：在检索到服务描述之后，服务使用者继续根据服务描述中的信息来调用服务。</li>
</ul>
</li>
<li><strong>服务适配器(Service adaptor)</strong></li>
<li><ul>
<li>企业中存在若干遗留系统(legacy system)采用较传统的技术开发，无法提供清晰的接口(interface)，但其他系统仍然需要访问这些遗留系统的功能。通过构造**适配器(adaptor)**，将遗留系统中的功能进行二次包装，从而开放出接口供其他系统使用。</li>
</ul>
</li>
<li><strong>服务代理(Service proxy)</strong><ol>
<li>客户端直接绑定服务接口(WSDL&#x2F;URI)</li>
<li>客户端通过“service registry”来访问服务，当希望访问其他服务时，只要手工修改该registry即可——相当于一个配置文件</li>
<li>客户端通过“service broker”来动态决定需访问那个服务。完全动态的服务选择，很困难，需要用到服务语义的相关技术</li>
</ol>
</li>
<li><strong>远程服务策略(Remote service strategy)</strong></li>
<li><strong>单点访问(Single point of access)</strong></li>
<li><strong>虚拟服务提供者(Virtual provider)</strong></li>
<li><strong>服务集成器(Service integrator)</strong><ol>
<li>将remote service strategy的思想进一步发挥，客户端不去逐一调用服务，而是首先将这些被调用的服务按逻辑关系集成起来，形成一个集成的、大粒度的服务</li>
<li>客户端只需调用这一个服务即可</li>
<li>当该服务执行时，集成器(integrator)依靠配置信息来分别调用一个个小粒度的服务</li>
<li>对这些配置信息进行修改，即可方便的做到变更</li>
</ol>
</li>
<li><strong>企业服务总线(Enterprise service bus)</strong></li>
<li><ul>
<li><strong>路由</strong>服务间的消息</li>
</ul>
</li>
<li><ul>
<li><strong>转化</strong>请求者和服务之间的传输协议</li>
</ul>
</li>
<li><ul>
<li><strong>转换</strong>请求者和服务之间的消息格式</li>
</ul>
</li>
<li><ul>
<li><strong>处理</strong>分离资源间的业务事件</li>
</ul>
</li>
<li><strong>集成化的服务生态系统(Integrated service ecosystem)</strong></li>
</ul>
<h2 id="Web服务基础"><a href="#Web服务基础" class="headerlink" title="Web服务基础"></a>Web服务基础</h2><h3 id="Web服务概念"><a href="#Web服务概念" class="headerlink" title="Web服务概念"></a>Web服务概念</h3><p>传统上，我们把<strong>计算机后台程序提供的功能</strong>，称为“服务”（service）。通俗地说，“服务”就是计算机可以提供的某一种功能。</p>
<ul>
<li><p>本地服务：使用同一台机器提供的服务，不需要网络。</p>
</li>
<li><p>网络服务：使用另一台计算机提供的服务，必须通过网络才能完成</p>
</li>
<li><p>Web服务是一种面向服务的架构的技术，通过<strong>标准的Web协议</strong>提供服务，目的是保<strong>证不同平台的应用服务可以互操作</strong></p>
</li>
<li><p>根据W3C的定义，<strong>Web服务应当是一个软件系统，用以支持网络间不同机器的互动操作。网络服务通常是许多应用程序接口（API）所组成的，它们透过网络，例如国际互联网（Internet）的远程服务器端，执行客户所提交服务的请求</strong></p>
</li>
<li><p>Web Service架构的基本思想，就是尽量把非核心功能交给其他人去做，自己全力开发核心功能。</p>
</li>
</ul>
<p>简单来说，Web Service就是一个<strong>向外界暴露出接口的能够通过网络进行远程调用</strong>的应用程序。更准确地说：</p>
<ul>
<li>一方面<strong>Web Service是一种部署在Web上的对象</strong></li>
<li>另一方面<strong>Web Service是建立在以XML为主的、开放的Web标准协议规范的基础上的分布式应用新平台</strong></li>
</ul>
<p>Web Services（Web服务）定义：</p>
<ul>
<li>Web Service是一种<strong>新的 Web 应用程序分支</strong>，它们是自包含、自描述、模块化的应用，可以在网络(通常为 Web)中被描述、发布、查找以及通过 Web 来调用</li>
<li>使用标准的互联网协议，像超文本传输协议 HTTP 和 XML</li>
<li>Web service平台是一套标准，它定义了应用程序如何在Web上实现互操作性。你可以用任何你喜欢的语言，在任何你喜欢的平台上写Web service</li>
</ul>
<h3 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h3><p>什么是SOAP？</p>
<ul>
<li>SOAP 指<strong>简易对象访问协议(Simple Object Access Protocol)</strong></li>
<li>SOAP 是一种<strong>通信协议</strong></li>
<li>SOAP 用于<strong>应用程序之间</strong>的通信</li>
<li>SOAP 是一种用于<strong>发送消息</strong>的格式</li>
<li>SOAP 被设计用来<strong>通过因特网</strong>进行通信</li>
<li>SOAP <strong>独立于平台</strong></li>
<li>SOAP <strong>独立于语言</strong></li>
<li>SOAP <strong>基于 XML</strong></li>
<li>SOAP <strong>很简单并可扩展</strong></li>
<li>SOAP 允许您<strong>绕过防火墙</strong></li>
<li>SOAP 将被作为 <strong>W3C 标准</strong>来发展</li>
</ul>
<p>SOAP(Simple Object Access Protocol)：</p>
<ul>
<li><strong>基于XML实现了一种消息格式以交换请求和使用</strong>，使用XML作为SOAP消息的基础使得任何实现基本的网络通信服务的系统都能处理和传送这类消息</li>
<li>SOAP的整个消息结构非常简单。除了消息结构外，SOAP没有定义额外的表述结构标准，没有定义自己的编码标准，没有定义自己的传输协议</li>
<li>SOAP可以使用任意的模式定义方式来定义内部传输内容的结构（编码方式一般使用XML Schema），可以与任意的网络传输方式来完成传</li>
</ul>
<p>一条 SOAP 消息就是一个普通的 XML 文档，包含下列元素：</p>
<ul>
<li>必需的 Envelope 元素，可把此 XML 文档标识为一条 SOAP 消息</li>
<li>可选的 Header 元素，包含头部信息</li>
<li>必需的 Body 元素，包含所有的调用和响应信息</li>
<li>可选的 Fault 元素，提供有关在处理此消息所发生错误的信息</li>
</ul>
<p>SOAP消息基本结构</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">soap:Envelope</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:soap</span>=<span class="string">&quot;http://www.w3.org/2001/12/soap-envelope&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">soap:encodingStyle</span>=<span class="string">&quot;http://www.w3.org/2001/12/soap-encoding&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">soap:Header</span>&gt;</span></span><br><span class="line"> ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Header</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">soap:Body</span>&gt;</span></span><br><span class="line"> ...</span><br><span class="line"> <span class="tag">&lt;<span class="name">soap:Fault</span>&gt;</span></span><br><span class="line"> ...</span><br><span class="line"> <span class="tag">&lt;/<span class="name">soap:Fault</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>SOAP Envelop 元素：必需的 SOAP 的 Envelope 元素是 SOAP 消息的根元素。它可把 XML 文档定义为 SOAP 消息</li>
<li><ul>
<li>xmlns:soap 命名空间：SOAP 消息必须拥有与命名空间 “<span class="exturl" data-url="aHR0cDovL3d3dy53My5vcmcvMjAwMS8xMi9zb2FwLWVudmVsb3Bl">http://www.w3.org/2001/12/soap-envelope<i class="fa fa-external-link-alt"></i></span>“ 相关联的一个 Envelope 元素</li>
</ul>
</li>
<li><ul>
<li>encodingStyle 属性：定义在文档中使用的数据类型</li>
</ul>
</li>
<li>SOAP Header 元素：可选的 SOAP Header 元素可包含有关 SOAP 消息的应用程序专用信息（比如认证、支付等）。如果 Header 元素被提供，则它必须是 Envelope 元素的第一个子元素</li>
<li>SOAP Body 元素：必需的 SOAP Body 元素可包含打算传送到消息最终端点的实际 SOAP 消息</li>
<li>SOAP Fault 元素：SOAP Fault 元素用于存留 SOAP 消息的错误和状态信息。如果已提供了 Fault 元素，则它必须是 Body 元素的子元素。在一条 SOAP 消息中，Fault 元素只能出现一次</li>
</ul>
<p><strong>HTTP请求方法：</strong></p>
<ul>
<li>GET 请求获取Request-URI所标识的资源</li>
<li>POST 在Request-URI所标识的资源后附加新的数据</li>
<li>HEAD 请求获取由Request-URI所标识的资源的响应消息报头</li>
<li>PUT 请求服务器存储一个资源，并用Request-URI作为其标识</li>
<li>DELETE 请求服务器删除Request-URI所标识的资源</li>
<li>TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断</li>
<li>CONNECT 保留将来使用</li>
<li>OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求</li>
</ul>
<p>HTTP 在 TCP&#x2F;IP 之上进行通信。HTTP 客户机使用 TCP 连接到 HTTP 服务器。在<br>建立连接之后，客户机可向服务器发送 HTTP 请求消息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /item HTTP/1.1</span><br><span class="line">Host: 189.123.345.239</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 200</span><br></pre></td></tr></table></figure>
<p>随后服务器会处理此请求，然后向客户机发送一个 HTTP 响应。此响应包含了可指示请求状态的状态代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">200 OK</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 200</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，服务器返回了一个 200 的状态代码。这是 HTTP<br>的标准成功代码。假如服务器无法对请求进行解码，它可能会返回<br>类似这样的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">400 Bad Request</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure>

<p>SOAP 方法指的是遵守 SOAP 编码规则的 HTTP 请求&#x2F;响应（<strong>HTTP + XML &#x3D; SOAP</strong><br>）。SOAP 请求可能是 HTTP POST 或 HTTP GET 请求。HTTP POST 请求规定至少两个 HTTP 头：Content-Type 和 Content-Length。</p>
<ul>
<li>Content-Type：SOAP 的请求和响应的 Content-Type 头可定义消息的 MIME 类型，以及用于请<br>求或响应的 XML 主体的字符编码（可选）。</li>
<li>Content-Length：SOAP 的请求和响应的 Content-Length 头规定请求或响应主体的字节数。</li>
</ul>
<p>SOAP请求：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">POST /InStock HTTP/1.1</span><br><span class="line">Host: www.example.org</span><br><span class="line">Content-Type: application/soap+xml; charset=utf-8</span><br><span class="line">Content-Length: nnn</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">soap:Envelope</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:soap</span>=<span class="string">&quot;http://www.w3.org/2001/12/soap-envelope&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">soap:encodingStyle</span>=<span class="string">&quot;http://www.w3.org/2001/12/soap-encoding&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> <span class="tag">&lt;<span class="name">soap:Body</span> <span class="attr">xmlns:m</span>=<span class="string">&quot;http://www.example.org/stock&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">m:GetStockPrice</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">m:StockName</span>&gt;</span>IBM<span class="tag">&lt;/<span class="name">m:StockName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">m:GetStockPrice</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">soap:Body</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>SOAP 响应：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/soap+xml; charset=utf-8</span><br><span class="line">Content-Length: nnn</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">soap:Envelope</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:soap</span>=<span class="string">&quot;http://www.w3.org/2001/12/soap-envelope&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">soap:encodingStyle</span>=<span class="string">&quot;http://www.w3.org/2001/12/soap-encoding&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">soap:Body</span> <span class="attr">xmlns:m</span>=<span class="string">&quot;http://www.example.org/stock&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">m:GetStockPriceResponse</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">m:Price</span>&gt;</span>34.5<span class="tag">&lt;/<span class="name">m:Price</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">m:GetStockPriceResponse</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">soap:Body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>客户发送请求时，不管客户是什么平台，首先把请求<strong>转换成XML格式</strong>，<strong>SOAP网关</strong>可自动执行这个转换。为了保证传送时参数、方法名、返回值的唯一性，SOAP协议使用了一个私有标记表，从而服务器的SOAP网关可以正确地解析；<strong>而使用XML作为编码表现形式，提供了更高层次上的抽象，从而实现与平台和环境的无关</strong><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401121639930.png"></p>
<h3 id="WSDL"><a href="#WSDL" class="headerlink" title="WSDL"></a>WSDL</h3><p>什么是WSDL：</p>
<ul>
<li>WSDL 指<strong>网络服务描述语言(Web Service Description Language)</strong></li>
<li>WSDL 使用 XML 编写</li>
<li>WSDL 是一种 XML 文档</li>
<li>WSDL 用于<strong>描述网络服务</strong></li>
<li>WSDL 也可用于<strong>定位网络服务</strong></li>
<li><strong>这种文档可描述某个 Web service，它可规定服务的位置，以及此服务提供的操作（或方法）</strong></li>
</ul>
<p><strong>WSDL(Web Service Description Language)定义了一套基于XML的语法，将Web服务描述为能够进行消息交换的服务访问点的集合。是Web服务的接口描述语言</strong>，包含以下内容：</p>
<ul>
<li>What：<strong>Web服务做什么</strong>——所提供的操作</li>
<li>Where：<strong>Web服务位于哪里</strong>——协议相关的地址，如URL</li>
<li>How：<strong>怎样调用</strong>——和服务交互的数据格式以及必要协议</li>
</ul>
<p>WSDL主要元素：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401121642188.png"></p>
<p>WSDL文档实例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="meta">&lt;definitions name=<span class="string">&quot;urn:AddressFetcher2&quot;</span> ...&gt;</span></span><br><span class="line"><span class="meta">    &lt;types&gt;</span></span><br><span class="line"><span class="meta">        //定义服务使用的任何复杂数据类型</span></span><br><span class="line"><span class="meta">    &lt;/types&gt;</span></span><br><span class="line"><span class="meta">    &lt;message name=<span class="string">&quot; GetLastTradePriceInput &quot;</span>&gt;</span></span><br><span class="line"><span class="meta">        //调用者和服务之间传递的一条消息，要用到前面定义的数据类型</span></span><br><span class="line"><span class="meta">    &lt;/message&gt;</span></span><br><span class="line"><span class="meta">    &lt;portType name=<span class="string">&quot; StockQuotePortType &quot;</span>&gt;</span></span><br><span class="line"><span class="meta">        //定义服务提供什么操作，要用到前面定义的消息</span></span><br><span class="line"><span class="meta">    &lt;/portType&gt;</span></span><br><span class="line"><span class="meta">    &lt;binding name=<span class="string">&quot;StockQuoteSoapBinding &quot;</span></span></span><br><span class="line"><span class="meta">        //定义服务如何被调用</span></span><br><span class="line"><span class="meta">    &lt;/binding&gt;</span></span><br><span class="line"><span class="meta">    &lt;service name=<span class="string">&quot;StockQuoteService &quot;</span>&gt;</span></span><br><span class="line"><span class="meta">        //描述服务位于哪里</span></span><br><span class="line"><span class="meta">    &lt;/service&gt;</span></span><br><span class="line"><span class="meta">&lt;/definitions&gt;</span></span><br></pre></td></tr></table></figure>

<p>WSDL概念模型：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401121645549.png"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401121645307.png"></p>
<h3 id="UDDI"><a href="#UDDI" class="headerlink" title="UDDI"></a>UDDI</h3><p>什么是UDDI：</p>
<ul>
<li>UDDI 是一个独立于平台的框架，用于通过使用 Internet 来描述服务，发现企业，并对企业服务进行集成。</li>
<li>UDDI 指的是通用描述、发现与集成服务</li>
<li>UDDI 是一种用于存储有关 web services 的信息的目录。</li>
<li>UDDI 是一种由 WSDL 描述的 web services 界面的目录。</li>
<li>UDDI 经由 SOAP 进行通信</li>
<li>UDDI 被构建入了微软的 .NET 平台</li>
</ul>
<p><strong>UDDI是统一描述、发现和集成（Universal Description, Discovery, and Integration）的缩写。它是一个基于XML的跨平台的描述规范，可以使世界范围内的企业在网络上发布自己所提供的服务。</strong><br><strong>UDDI计划是一个广泛的，开放的行业计划</strong>，它使得商业实体能够：</p>
<ul>
<li>彼此发现</li>
<li>定义他们怎样在internet上互相作用，并在一个全球的注册体系架构中共享信息</li>
</ul>
<p>UDDI数据表类型：</p>
<ul>
<li>白页：包含了基本的企业信息</li>
<li>黄页：按分类法对企业信息进行分类</li>
<li>绿页：包含了如何与企业进行电子交互的信息</li>
</ul>
<p>UDDI的信息模型：</p>
<ol>
<li>businessEntity元素：支持对UDDI商业注册的商业信息发布和发现的核心XML元素都包含在该结构中，这个结构是商业实体专属信息集的最高层的数据容器，位于整个信息结构的最上层</li>
<li>businessService元素：将一系列有关商业流程或分类目录的Web服务的描述组合到一起。businessService和下面要提到的bindingTemplate一起构成了”绿页”信息</li>
<li>bindingTemplate元素：对于每一个businessService，存在一个或多个Web服务的技术描述bindingTemplate</li>
<li>tModel元素：是一个技术规范的超类，tModel能够描述商业标示符数据库、分类方法、技术规范、网络协议等各类的技术规范，是UDDI Web服务元数据管理的基础</li>
</ol>
<p>UDDI的工作原理：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401121653066.png"></p>
<h2 id="Web服务实现【实验1指导书及任务】"><a href="#Web服务实现【实验1指导书及任务】" class="headerlink" title="Web服务实现【实验1指导书及任务】"></a>Web服务实现【实验1指导书及任务】</h2><h3 id="如何开发自己的Web服务-Java平台为例"><a href="#如何开发自己的Web服务-Java平台为例" class="headerlink" title="如何开发自己的Web服务(Java平台为例)"></a>如何开发自己的Web服务(Java平台为例)</h3><h3 id="如何访问调用已有的Web服务（生成代理类）"><a href="#如何访问调用已有的Web服务（生成代理类）" class="headerlink" title="如何访问调用已有的Web服务（生成代理类）"></a>如何访问调用已有的Web服务（生成代理类）</h3><h2 id="REST基础"><a href="#REST基础" class="headerlink" title="REST基础"></a>REST基础</h2><h3 id="REST是什么、有何关键特性、如何理解、无状态性的设计方式及优缺点"><a href="#REST是什么、有何关键特性、如何理解、无状态性的设计方式及优缺点" class="headerlink" title="REST是什么、有何关键特性、如何理解、无状态性的设计方式及优缺点"></a>REST是什么、有何关键特性、如何理解、无状态性的设计方式及优缺点</h3><p>REST是英文<strong>REpresentational State Transfer</strong>的缩写，<strong>表象化状态转变</strong>，或者<strong>表述性状态转移</strong></p>
<p>REST架构风格以<strong>资源</strong>为核心进行设计，从资源的角度来观察整个网络。网络上的所有事物都是资源，分布在各处的资源由URI确定，而客户端的应用通过URI来获取资源的表述。</p>
<ul>
<li>资源（Resources）：任何寄宿于Web可供操作的“事物”均可视为资源</li>
<li>表现层（Representation）：把”资源”具体呈现出来的形式，叫做它的”表现层”</li>
<li>状态转化（State Transfer）：互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”</li>
</ul>
<p>三者关联</p>
<ul>
<li>每一个URI代表一种资源</li>
<li>客户端和服务器之间，传递这种资源的某种表现层</li>
<li>客户端通过四个HTTP动词，对服务器端资源进行操作，实现“表现层状态转化”</li>
</ul>
<p><strong>REST的关键特性</strong>：</p>
<ul>
<li><strong>采用URL标识资源</strong>：标志性、可读性、可寻址性（Addressability）</li>
<li><strong>使用统一的接口</strong>：是针对不同资源的Web API定义一致性的操作来操作它们</li>
<li><strong>使用标准的HTTP方法</strong>：Web API分别针对CRUD的操作只能接受具有对应HTTP方法的请求</li>
<li><strong>支持多种资源表示方式</strong>：我们一般利用请求的Content-Type报头携带的媒体类型来判断其采用的表示类型</li>
<li><ul>
<li>让请求URI包含资源表示类型</li>
</ul>
</li>
<li><ul>
<li>采用“内容协商（Content Negotiation）”根据请求相关报头来判断它所希望的资源表示类型，比如“Accept”和“Accept-language”报头可以体现请求可以接受的响应媒体类型和语言</li>
</ul>
</li>
</ul>
<p>REST架构六个特点：客户端——服务器的、无状态的、可缓存的、统一接口、分层系统、按需编码</p>
<p>RESTful无状态性：</p>
<ol>
<li><strong>客户端-服务器通信中的每个请求必须包含所有必要信息</strong>：服务器不会存储关于客户端状态的信息（如会话信息）。这意味着每个请求都应当独立，服务器通过请求中的信息来理解并处理该请求。</li>
<li><strong>服务器不保存任何客户端请求的历史记录</strong>：每个请求都是独立的，服务器不依赖之前的请求或响应来处理当前的请求。</li>
<li><strong>认证和授权数据随每次请求发送</strong>：由于服务器不保存会话状态，所以每次请求都需要包含认证信息（如果需要的话），比如令牌或API密钥。</li>
</ol>
<ul>
<li>优点：简化服务器设计、提高可伸缩性、改善可靠性和可用性、便于缓存处理</li>
<li>缺点：可能增加网络负担、客户端复杂性增加、性能开销、安全风险</li>
</ul>
<h3 id="Why-REST"><a href="#Why-REST" class="headerlink" title="Why REST"></a>Why REST</h3><p>为什么要基于API开发：</p>
<ul>
<li>API让web，手机客户端，桌面多种操作成为可能，程序员分工更加明确，切降低了开发成本</li>
<li>软件开发依赖解耦</li>
<li>让编程语言发挥各自的优势</li>
</ul>
<p>REST优势：</p>
<ul>
<li>将用户界面和数据存储分离，提高用户界面跨多个服务平台</li>
<li>一个好的架构应该可以很轻松的为不同的请求返回不同格式的数据</li>
<li>使用REST的最佳的场景是对外提供公开的服务，也就是所谓的OpenAPI，也有的人认为REST更适合资源导向的网站，像youtube这样的网站</li>
<li>REST 的真正价值在于 Web Services，而不是通过浏览器操作的应用程序</li>
</ul>
<ol>
<li><strong>轻量级、HTTP</strong></li>
<li><strong>无状态请求可以由任何可用服务器回答，分布式、缓存、云计算</strong></li>
<li><strong>资源唯一URL、标准接口</strong></li>
<li><strong>基于成熟HTTP的安全模型</strong></li>
<li>简单、人类友好…</li>
</ol>
<h3 id="REST与MVC的关联对比、与RPC的对比"><a href="#REST与MVC的关联对比、与RPC的对比" class="headerlink" title="REST与MVC的关联对比、与RPC的对比"></a>REST与MVC的关联对比、与RPC的对比</h3><p>REST与MVC：</p>
<ul>
<li>MVC风格将模型、视图、控制解耦，其结构整洁、逻辑清晰，易于扩展和增强。MVC偏重于解决服务器端的逻辑分层问题，以及客户端是逻辑分层的延伸问题。但是MVC很难实现跨语言解耦。</li>
<li>REST风格偏重于统一接口，具体实现可以跨平台和跨语言。REST使用纯HTML作为客户端，没有服务器端和客户端的耦合。</li>
<li>MVC和REST并不是互斥的，如Spring的MVC模块已经开始支持REST式的开发，Jersery也实现了MVC的功能。</li>
</ul>
<p>REST与RPC：</p>
<ul>
<li>REST服务是一种ROA（Resource Oriented Architecture）应用，其主要特点是方法信息存在于HTTP协议的方法中，作用域存在于URI中，风格更轻量和快速。</li>
<li>从方法信息角度，REST采用标准的HTTP方法，RPC请求都是HTTP协议的POST方法，其方法信息包含于SOAP协议包或HTTP协议包中，方法名称不具有通用性。</li>
<li>从作用域角度看，REST采用URI显示定义作用域，而RPC这一信息同样包含于协议包中，不能直观呈现。</li>
<li>RPC风格的开发关注于服务器-客户端之间的方法调用，是面向方法调用过程的，而REST是面向资源状态的。</li>
<li>备注：PRC风格的两个代表是XML-RPC和SOAP Service</li>
</ul>
<h2 id="REST-API设计"><a href="#REST-API设计" class="headerlink" title="REST API设计"></a>REST API设计</h2><h3 id="统一接口、安全性幂等性"><a href="#统一接口、安全性幂等性" class="headerlink" title="统一接口、安全性幂等性"></a>统一接口、安全性幂等性</h3><p>HTTP方法基本特性：安全性、幂等性</p>
<ul>
<li><p><strong>安全性</strong>是指<strong>外系统对该接口的访问，不会使服务器资源的状态发生改变</strong></p>
</li>
<li><p><strong>幂等性（Idempotent）</strong>是一个数学上的概念，在这里是指<strong>外系统对同一REST接口的多次访问，得到的资源状态是相同的</strong>。在网速不够快的情况下，客户端发送一个请求后不能立即得到响应，由于不能确定是否请求是否被成功提交，所以它有可能会再次发送另一个相同的请求，幂等性决定了第二个请求是否有效。</p>
</li>
<li><p>GET：HTTP的GET方法用于读取资源。GET方法是幂等的，因为读取同一个资源，总是得到相同的数据。GET方法也是安全的，因为读取资源不会对其状态做改动。JAX-RS2.0指出了@GET注释对资源方法的定义，使得该方法用于处理GET请求。</p>
</li>
<li><p>PUT：PUT方法是幂等的，即多次或者更新统一份数据，在服务器端对资源状态所产生的改变是相同的。<strong>PUT方法不是安全的</strong>，有写动作的HTTP方法都不是安全的。</p>
</li>
<li><p>DELETE：方法是幂等的，即多次删除同一份数据（通常请求中传递的参数是数据的主键值），在服务端产生的改变是相同的。JAX-RS 2.0定义了 @DELETE注释来定义相关资源方法。</p>
</li>
<li><p>POST：定义为POST的REST接口用于写数据。POST方法的特性是<strong>既不幂等也不安全</strong>。因为请求会改变服务器端资源的状态，因此不是安全的；每次请求对服务器资源状态的改变并不是相同的，因此不是幂等的</p>
</li>
</ul>
<h3 id="资源定位、资源路径设计"><a href="#资源定位、资源路径设计" class="headerlink" title="资源定位、资源路径设计"></a>资源定位、资源路径设计</h3><p><strong>对外提供REST式的Web服务的接口就是公布一系列的URI及其参数</strong></p>
<p>资源地址的设计过程是面向资源的，<strong>资源名称应是准确描述该资源的名词，资源地址应具有直观的描述性</strong>。比如一个班级的资源地址可以是：学校&#x2F;学院&#x2F;年级&#x2F;班级。值得注意的是，一个URI资源地址唯一对应一个资源，但是一个资源可以拥有多个URI资源地址。比如Jersey最新版本的文档地址和Jersey2.9版本的文档地址指向同一个资源。</p>
<p>资源路径概览：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401121944651.png"><br>注意：资源地址相同，但HTTP方法不同的两个方法是两个不同的REST接口。HTTP方法和资源地址结合在一起才可以完成对资源的定位。</p>
<p>@RequestMapping：</p>
<ul>
<li>用来处理请求地址映射，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</li>
<li>默认请求方法是GET</li>
<li><ul>
<li>@GetMapping 等同于 @RequestMapping(method &#x3D;</li>
</ul>
</li>
<li><ul>
<li>RequestMethod.GET)</li>
</ul>
</li>
<li><ul>
<li>@PostMapping 等同于 @RequestMapping(method &#x3D;</li>
</ul>
</li>
<li><ul>
<li>RequestMethod.POST)</li>
</ul>
</li>
<li><ul>
<li>@PutMapping 等同于 @RequestMapping(method &#x3D;</li>
</ul>
</li>
<li><ul>
<li>RequestMethod.PUT)</li>
</ul>
</li>
<li><ul>
<li>@DeleteMapping 等同于 @RequestMapping(method &#x3D;<br>RequestMethod.DELETE)</li>
</ul>
</li>
</ul>
<p>@PathVariable：</p>
<ul>
<li>获取url中的数据</li>
<li>通过@PathVariable注解来获取URL中的参数时的前提条件是我们知道url的格式时怎么样的。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 url=localhost:8080/hello/id/name 中的id、name值</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/hello/&#123;id&#125;/&#123;name&#125;&quot;,method= RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id,<span class="meta">@PathVariable(&quot;name&quot;)</span> String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;id:&quot;</span>+id+<span class="string">&quot; name:&quot;</span>+name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>@RequestParam：获取请求参数的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 url=localhost:8080/hello?id=98 中的id值</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/hello&quot;,method= RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(<span class="meta">@RequestParam(&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;id:&quot;</span>+id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Controller请求与URL重构</strong>：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401121952190.png"></p>
<h3 id="【实验2指导书和任务】：如何开发和调用Restful-API-services"><a href="#【实验2指导书和任务】：如何开发和调用Restful-API-services" class="headerlink" title="【实验2指导书和任务】：如何开发和调用Restful API services"></a>【实验2指导书和任务】：如何开发和调用Restful API services</h3><h2 id="服务组合技术"><a href="#服务组合技术" class="headerlink" title="服务组合技术"></a>服务组合技术</h2><h3 id="服务编排"><a href="#服务编排" class="headerlink" title="服务编排"></a>服务编排</h3><p><strong>服务编排（Orchestration）：将多个小粒度的Web服务按照特定的业务逻辑规则构造为一个可执行的业务过程，同时又可以看作是一个大粒度的复合Web服务。</strong></p>
<ul>
<li>执行时需要有中心控制机制</li>
<li>由一个组织所拥有</li>
<li>侧重点：<strong>如何使用已有的服务来构造新的服务</strong><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401121958499.png"></li>
</ul>
<p>BPEL能够实现基于WSDL的Web Services之间的流程编排和服务协同，它提供了一种XML注释和语义，用于指定对Web Services进行编排并确定Web服务之间的业务流程，实现Web Services之间的协同。</p>
<ul>
<li><strong>过程中的基本功能单元：活动<activity></strong></li>
<li>活动之间的次序关系：</li>
<li><ul>
<li>先后次序<sequence></li>
</ul>
</li>
<li><ul>
<li>多分支<switch></li>
</ul>
</li>
<li><ul>
<li>循环<while></li>
</ul>
</li>
<li><ul>
<li>并发与同步<flow></li>
</ul>
</li>
<li><ul>
<li>非确定性选择<pick></li>
</ul>
</li>
<li><strong>过程的相关数据：容器<container></strong></li>
<li><strong>错误处理机制：<catching>、<handling faults></strong></li>
<li><strong>补偿机制：<compensation handler></strong></li>
</ul>
<p>运行模式：</p>
<ul>
<li>集中式的执行引擎<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401122003992.png"></li>
<li>基于Hub的分布式引擎<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401122003950.png"></li>
<li>无Hub的分布式引擎<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401122003359.png"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401122003864.png"></li>
</ul>
<h3 id="服务协同"><a href="#服务协同" class="headerlink" title="服务协同"></a>服务协同</h3><p><strong>服务协同（Choreography）：将多个零散的、分别由多方提供的服务&#x2F;业务流程按照彼此之间的协同关系组织起来，支持多方的交互行为。</strong></p>
<ul>
<li>侧重于不同服务之间的消息传递的次序与规则，以保证期望的协同行为。</li>
<li>无需中心控制；</li>
<li>无需完全由一个组织所拥有；<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401122006841.png"></li>
</ul>
<p>分类：</p>
<ul>
<li>链式协同模式（Chained）</li>
<li>同步协同模式（Synchronized）</li>
<li>嵌套协同模式（Nested）<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401122007287.png"></li>
<li>复合模式<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401122007745.png"></li>
</ul>
<h3 id="两者比较"><a href="#两者比较" class="headerlink" title="两者比较"></a>两者比较</h3><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401122008981.png"></p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401122008680.png"></p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401122009928.png"></p>
<p>二者在协议栈中的位置（协同位于编排之上）：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401122009651.png"></p>
<h2 id="服务业务流程"><a href="#服务业务流程" class="headerlink" title="服务业务流程"></a>服务业务流程</h2><h3 id="BPEL规范"><a href="#BPEL规范" class="headerlink" title="BPEL规范"></a>BPEL规范</h3><p>业务流程执行语言（Business Process Execution Language, BPEL, 发音为’bipple’或’bee-pell’），也叫业务过程执行语言，是一种基于XML的，用来描写业务流程的编程语言，被描写的业务流程的每个单一步骤则由Web服务来实现。</p>
<ul>
<li>BPEL是基于Web服务的，并且依赖于WSDL。</li>
<li>一个BPEL流程可以发布为一个WSDL定义的服务，并像其它Web服务一样被调用。而且，BPEL希望一个Web服务合成所包含的全部外部Web服务，都是用WSDL服务契约定义的，这令BPEL流程可以调用其它BPEL流程，甚至可以递归的调用自己。</li>
<li>值得注意的是BPEL不直接支持人机对话，BPEL所描写的过程仅与Web服务通信，而这些Web服务却可以提供与用户的信息交换，但它们不是用户本身。</li>
<li>用BPEL编写的流程可以在任何支持BPEL规范的平台或产品上运行。</li>
</ul>
<p>协议基础：</p>
<ul>
<li>WS—BPEL是基于XML定义的流程描述语言，它位于几个XML规范之上：WSDLl.1、XML Schemal.0和XPathl.0。</li>
<li>其中WSDL消息和XML Schema类型定义提供了BPEL流程所用的数据模型;XPath为数据处理提供支持;所有的外部资源和伙伴被表示成WSDL服务。</li>
</ul>
<p>BPEL包含的范围：</p>
<ul>
<li>处理活动的顺序，特别是网络服务互操作。</li>
<li>消息和处理实例之间的关系。</li>
<li>在发生错误和例外情况下的恢复行为。</li>
<li>处理角色之间的基于网络服务关系的双面性</li>
</ul>
<p>BPEL引入元素：</p>
<ol>
<li><strong>伙伴链接</strong></li>
</ol>
<ul>
<li>BPEL把与流程交互的其他服务称为伙伴。一个流程可以调用其他服务，也可以响应来自客户端的请求。一个流程既可以作为服务的请求者，也可以扮演服务的提供者。在异步通信环境中，流程与伙伴之间的会话可能是双向的，它们会扮演不同的角色。因此，为了消除在通信过程中的多义性，我们需要明确服务和流程所扮演的角色</li>
<li>伙伴链接用于实现Web服务长期稳定的交互，描述伙伴之间的关联。这种动态伙伴关系为流程带来了极大的灵活性，也增强了流程的可复用性</li>
<li>伙伴链接类型<strong>声明了两个或多个服务之间的关系</strong></li>
<li>伙伴链接类型定义了一组角色，其中每个角色指明一组Port Type，即明确了该角色所提供的服务接口，一边接收会话的上下文消息。 如果partnerLinkType仅有一个角色，那么将根据需要省略其中一个属性</li>
</ul>
<ol start="2">
<li><strong>变量</strong></li>
</ol>
<ul>
<li>在BPEL中，可以使用变量来保存和传递流程的状态信息。它们通常是从合作伙伴那里接收到消息，或者是被发送给合作伙伴的消息。同时，它们还有可能是与流程有关的状态消息，这些消息并不与合作伙伴进行交换</li>
<li>由WSDL文件所定义的消息类型(message type)，表示允许变量包含WSDL定义的整个信息；由XML Schema所定义的简单类型(simple type)，表示一个XSD元素结构;由XML Schema所定义的元素(element)，表示一个XSD简单结构，比如：string ,integer</li>
<li>变量是有作用域的。属于全局流程作用域的变量称为全局变量；属于流程作用域的变量称为局部变量</li>
</ul>
<ol start="3">
<li>活动</li>
</ol>
<ul>
<li>BPEL是由一系列步骤组成，这些步骤称为活动</li>
<li><strong>基本活动</strong>描述了<strong>流程内的一个具体步骤</strong>，如接受请求、调用伙伴服务、变量赋值等，是与外界进行交互最简单的形式，活动内不会嵌套其它活动。它们是无序的个别步骤，与服务进行交互、操作、传输数据或者处理异常等</li>
<li><strong>结构化活动</strong>描述了如何组织和管理流程的控制流，规定了<strong>一组活动发生的顺序</strong>。他们描述了业务流程是怎样通过把它执行的基本活动组成结构而被创建的，这些结构表达了涉及业务协议的流程实例间的控制形式、数据流程、故障和外部事件的处理以及消息交换的协调。结构化的活动可以被任意地嵌套和组合</li>
<li>关联集合</li>
<li>事件处理程序</li>
<li>BPEL事务与补偿机制</li>
<li>BPEL异常管理</li>
</ul>
<p>部分元素之间关系：</p>
<ul>
<li>流程是由一系列的活动组成的；</li>
<li>流程通过伙伴链接来定义与流程交互的其他服务；</li>
<li>服务中可以定义一些变量；</li>
<li>流程可以是有状态的长时间运行过程，流程引擎可以通过关联集合将一条消息关联到特定的流程实现。</li>
</ul>
<h3 id="BPEL引擎"><a href="#BPEL引擎" class="headerlink" title="BPEL引擎"></a>BPEL引擎</h3><p>活动详解：Receive(接收)&#x2F;Reply(回答)</p>
<p><Receive>活动从流程的外部伙伴那获得数据，并将其保存到流程变量。</p>
<ul>
<li>通常一个Receive是一个流程的初始点，它会阻塞执行直到匹配的消息的到达。</li>
<li>在异步信息交换时，receive也可以接收回收信息。</li>
</ul>
<p><receive>元素有5个属性：</p>
<ul>
<li>partnerLink:在通信过程中识别伙伴</li>
<li>portType:从伙伴方接收请求消息的接口</li>
<li>operation:接收请求消息</li>
<li>variable:用来存储接收到的请求消息</li>
<li>createInstance:当该属性设置为”yes”时，它指明了当前流程接收到匹配消息是会创建新的流程实例来处理该请求</li>
</ul>
<p><Reply>活动发送消息给伙伴来应答通过Receive活动所接收到的消息。</p>
<ul>
<li>Receive和Reply的组合对应着WSDL portType上定义的一个请求—响应操作。</li>
<li>如果receive活动对应着一个单向操作，则不能在流程中定义对应的reply活动。</li>
</ul>
<p><Reply>元素也有5个属性：</p>
<ul>
<li>其中，partnerLink，portType和operation含义同receive元素的属性含义相同。</li>
<li>variable:用来存储从伙伴返回的消息</li>
<li>messageExchange：这是一个WS-BPEL2.0新增加的可选的属性。它使得reply元素可以精确的关联到一个能够接收信息的活动（比如 receive元素）</li>
</ul>
<p>包含receive&#x2F;reply活动的片段：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receive</span> <span class="attr">name</span>=<span class="string">&quot;receiveInput&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">partnerLink</span>=<span class="string">&quot;client&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">portType</span>=<span class="string">&quot;tns:TimesheetSubmissionInterface&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">operation</span>=<span class="string">&quot;Submit&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">variable</span>=<span class="string">&quot;ClientSubmission&quot;</span> <span class="attr">createInstance</span>=<span class="string">&quot;yes&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">reply</span> <span class="attr">partnerLink</span>=<span class="string">&quot;client&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">portType</span>=<span class="string">&quot;tns:TimesheetSubmissionInterface&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">operation</span>=<span class="string">&quot;Submit&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">variable</span>=<span class="string">&quot;TimesheetSubmissionResponse&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li>在实例4中：receive和reply活动中都是通过partnerLink来引导预定义伙伴关系的，而且需要设置portType和operation属性来声明流程实现的WSDL portType和操作</li>
<li>如果将receive活动作为流程的起始点，则需要将receive活动的createInstance属性设置为”yes”，它指明了当前流程接收到匹配消息是会创建系的流程实例来处理该请求</li>
</ol>
<h3 id="【实验3-4指导书及任务】编排微服务及运行监控实例流程"><a href="#【实验3-4指导书及任务】编排微服务及运行监控实例流程" class="headerlink" title="【实验3-4指导书及任务】编排微服务及运行监控实例流程"></a>【实验3-4指导书及任务】编排微服务及运行监控实例流程</h3>]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>university</tag>
        <tag>soa</tag>
      </tags>
  </entry>
  <entry>
    <title>教程其三之常用git命令</title>
    <url>/2023/08/16/tutorial-git-command/</url>
    <content><![CDATA[<blockquote>
<p>本文由部长代写形成，赞美 youyiBYSKY</p>
</blockquote>
<h1 id="git的仓库管理"><a href="#git的仓库管理" class="headerlink" title="git的仓库管理"></a>git的仓库管理</h1><p>git在工程实践中起着举足轻重的作用，能够大大提高开发时版本迭代的效率。<br>接下来，本文将简单介绍一下git管理仓库的一些方法。希望阅读这篇博客的萌新能够看懂。<br><strong><del>毕竟不会用git要担心被开除了</del></strong><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/noob01.png" alt="0"><br><strong>（图来自runoob.com）</strong><br>本文从三个方面介绍仓库的管理  </p>
<ul>
<li>本地仓库</li>
<li>外部仓库</li>
<li>仓库的分支管理</li>
</ul>
<span id="more"></span>

<p>本文所用到的代码总览</p>
<blockquote>
<p><code>$ git init //仓库初始化  </code><br><code>$ git status //仓库状态  </code><br><code>$ git add //将工作区文件添加到缓存区  </code><br><code>$ git commit -m &quot;(日志内容)&quot;//提交更改到版本库 </code><br><code>$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; //push代码到远程仓库</code><br><code>$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; //从远程仓库上pull下代码</code><br><code>$ git fetch //从远程仓库下载新分支与数据</code><br><code>$ git clone &lt;repo&gt; &lt;directory&gt; //从现有 Git 仓库中拷贝项目</code><br><code>$ git branch //查看当前git中的分支列表</code><br><code>$ git checkout (branchname) //切换当前所在分支</code><br><code>$ git merge (branchname) //将指定分支合并到当前分支</code><br><code>$ git branch -d (branchname) //删除指定分支</code>  </p>
</blockquote>
<blockquote>
<p><code>$ git log //查看git日志 </code>  </p>
</blockquote>
<h2 id="git本地仓库的基础操作"><a href="#git本地仓库的基础操作" class="headerlink" title="git本地仓库的基础操作"></a>git本地仓库的基础操作</h2><h3 id="本地仓库的初始化"><a href="#本地仓库的初始化" class="headerlink" title="本地仓库的初始化"></a>本地仓库的初始化</h3><p>初始化git本地仓库的命令格式如下</p>
<blockquote>
<p><code>$ git init</code><br>在所选定的文件夹下启动git，在cmd中输入<br><code>$ git init</code>  </p>
</blockquote>
<p>之后返回提示</p>
<pre><code>Initialized empty Git repository in &quot;仓库所在文件夹的路径&quot;
</code></pre>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/1.png" alt="1"><br>即可完成仓库的初始化，同时，在该文件夹下会生成一个 <strong>.git</strong> 文件夹。</p>
<p>此时要查看仓库状态，可以输入  </p>
<blockquote>
<p><code> git status</code>  </p>
</blockquote>
<p>此时会看到已经被初始化的仓库<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/2.png" alt="2"><br><strong>这只是一个空仓库</strong></p>
<h3 id="本地仓库的管理"><a href="#本地仓库的管理" class="headerlink" title="本地仓库的管理"></a>本地仓库的管理</h3><h4 id="文件的工作区导入"><a href="#文件的工作区导入" class="headerlink" title="文件的工作区导入"></a>文件的工作区导入</h4><p>在原来的文件夹下面新增一个 <strong>“GitTest”</strong> 文件夹<br>在所选定的文件夹下导入你所要保存的项目，启动git，在cmd中输入  </p>
<blockquote>
<p><code>$ git status</code>   </p>
</blockquote>
<p>此时可以看到导入的项目文件未提交的git仓库  </p>
<pre><code class="bash">On branch master

No commits yet

Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
        GitTest/ (.git同级文件)

nothing added to commit but untracked files present (use &quot;git add&quot; to track)
</code></pre>
<h4 id="文件的暂存区导入"><a href="#文件的暂存区导入" class="headerlink" title="文件的暂存区导入"></a>文件的暂存区导入</h4><p>git中将工作区文件导入到暂存区的命令格式如下：  </p>
<blockquote>
<p><code>git add &lt;文件名&gt;</code>  </p>
</blockquote>
<p>在cmd中输入<br><code>$ git add GitTest/（所要添加到暂存区的文件）</code><br><code>（输入$ git add . 可将当前目录下的所有文件都添加到暂存区）</code>  </p>
<p>此时再查看仓库状态<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/5.png" alt="5"><br>可以看到工作区中的文件已经添加到了暂存区  </p>
<h4 id="提交文件到版本库"><a href="#提交文件到版本库" class="headerlink" title="提交文件到版本库"></a>提交文件到版本库</h4><p>git中将暂存区文件提交到版本库的命令格式如下：  </p>
<blockquote>
<p><code>git commit -m &quot;(日志内容)&quot;</code>  </p>
</blockquote>
<p>在cmd中输入  </p>
<blockquote>
<p><code>$ git commit -m &quot;提交到版本库&quot; </code>  </p>
</blockquote>
<p>然后可以看到暂存区的文件已经被更新到版本库  </p>
<pre><code class="bash">[master (root-commit) c868616] &quot;提交到版本库&quot;
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 GitTest/introduction.md
</code></pre>
<p>在cmd中再次输入  </p>
<blockquote>
<p><code>$ git status</code>  </p>
</blockquote>
<p>此时可以看到在版本库更新后，缓存区中的内容已经被清空<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/3.png" alt="3"></p>
<h4 id="提交更改到版本库"><a href="#提交更改到版本库" class="headerlink" title="提交更改到版本库"></a>提交更改到版本库</h4><p>打开上例中的 &#x2F;GitTest&#x2F;introduction.md 文件进行如下修改</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/7.png" alt="7"></p>
<p>查看仓库状态，可以看到git检测到introduction.md已被修改<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/8.png" alt="8"><br>按照上一段的步骤再次操作（工作区-&gt;暂存区-&gt;提交更改）即可将项目保存的修改提交到版本库  </p>
<h2 id="git远程仓库的基础操作"><a href="#git远程仓库的基础操作" class="headerlink" title="git远程仓库的基础操作"></a>git远程仓库的基础操作</h2><p>前言：这里稍稍加速一下，本地仓库的分支管理、版本库回溯等操作暂且跳过，就先优先讲解一写远程仓库的基础操作（pull、push）  </p>
<p><del>说实话，这种很不负责任的做法，但为了快速上手，我还是把分支管理放在了这一节之后<br><strong>原谅我</strong></del>    </p>
<h3 id="新建远程仓库"><a href="#新建远程仓库" class="headerlink" title="新建远程仓库"></a>新建远程仓库</h3><p>登录GitHub ,在主页导航栏找到新建，选中“New repository”,<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/9.png" alt="9"><br>根据引导创建远程仓库  </p>
<h3 id="关联远程仓库"><a href="#关联远程仓库" class="headerlink" title="关联远程仓库"></a>关联远程仓库</h3><p>在github中找到远程仓库的地址<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/11.png" alt="11"><br>新建仓库后复制仓库地址，在git中输入  </p>
<blockquote>
<p><code>$ git remodte add origin &quot;远程仓库地址&quot;</code>  </p>
</blockquote>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/12.png" alt="12">  </p>
<h4 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h4><p>git中push代码的命令格式如下：</p>
<blockquote>
<p><code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code>  </p>
</blockquote>
<p>现在来开始push我们已有的代码<br>此时尝试直接输入<code>git push</code>来push本地代码，会出现以下情况<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/13.png" alt="13"><br>这里提示当前master分支没有上传分支，并且提示输入  <code>git push --set-upstream origin master</code> 来建立origin和master之间的流通道<br><em><strong>（origin是远程仓库的默认名称，master是本地分支的默认名称）</strong></em><br>如上建立流通道后，打开github中的远程仓库，可以看到本地代码已经上传至远程仓库<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/14.png" alt="14">  </p>
<h4 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h4><p>git中pull代码的命令格式如下：  </p>
<blockquote>
<p><code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code>  </p>
</blockquote>
<p>打开GitHub，将先前上传的introduction.md 文件做一些改动后保存<br><strong>（在GitHub上直接修改代码时记得选择分支，这个会在之后细说）</strong><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/15.png" alt="15"><br>在git中直接输入<code>git pull</code><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/16.png" alt="16"><br>打开本地的introduction.md ，可以看见GitHub上的更改已经同步到本地<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/17.png" alt="17">  </p>
<h2 id="git的分支管理"><a href="#git的分支管理" class="headerlink" title="git的分支管理"></a>git的分支管理</h2><p>分支，是将修改的项目整体分叉保存，每个分叉后的分支相互独立，互不影响。<br>git的分支模型是git的一大 <strong>“绝学”</strong>，几乎每一种版本控制系统都以某种形式支持分支，一个分支代表一条独立的开发线。<br>利用分支，可以让多个人同时为同一个项目进行开发。在自己完成工作后，将自己分支上的修改合并到主分支。  </p>
<h3 id="查看与新建git分支"><a href="#查看与新建git分支" class="headerlink" title="查看与新建git分支"></a>查看与新建git分支</h3><p>git中查看分支的命令格式如下：  </p>
<blockquote>
<p><code>git branch</code>  </p>
</blockquote>
<p>在默认情况下，本地仓库只有一个 <strong>master</strong>分支，并且该分支是当前分支。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/18.png" alt="18">  </p>
<p>git中新建分支的命令格式如下：  </p>
<blockquote>
<p><code>git branch (branchname)</code>  </p>
</blockquote>
<p>现在我们要新建一个 <strong>“moke”</strong> 分支，只需输入：<code>git branch moke</code><br>然后再次输入<code>git branch</code>来查看所有分支。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/19.png" alt="19">  </p>
<p>现在我们可以看到，我们有了一个新的分支 <strong>“moke”</strong>。  </p>
<h3 id="切换git分支"><a href="#切换git分支" class="headerlink" title="切换git分支"></a>切换git分支</h3><p>git中切换分支的命令格式如下：  </p>
<blockquote>
<p><code>git checkout (branchname)</code>  </p>
</blockquote>
<p>现在我们要切换到方才创建的<strong>“moke”</strong> 分支，就只需要输入<code>git checkout moke</code><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/20.png" alt="20">  </p>
<p>可以看到，我们现在已经切换到了 <strong>“moke”</strong> 分支。  </p>
<p>现在打开 introduction.md ，删除第二行的内容，然后更新到版本库。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/21.png" alt="21"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/22.png" alt="22">   </p>
<p>此时输入<code>git checkout mmaster</code>切换到默认的master分支。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/23.png" alt="23">  </p>
<p>再打开 introduction.md ，可以看到在 <strong>“moke”</strong> 中被删除的第二行回来了。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/24.png" alt="24">  </p>
<p>这里证明了不同的分支下，同一个项目可以同时开发，而且互不影响。  </p>
<h3 id="合并git分支"><a href="#合并git分支" class="headerlink" title="合并git分支"></a>合并git分支</h3><p>git中合并分支的命令格式如下：  </p>
<blockquote>
<p><code>git merge (branchname)</code>  </p>
</blockquote>
<p><strong>首先先解释一下这个命令：</strong><br>这个分支合并命令是将指定分支合（上面命令格式中的参数）并到当前分支。</p>
<p>上文中master分支与 <strong>“moke”</strong> 中的内容并不相同，这里我们要把这<strong>“moke”</strong>分支合并到master分支。<br>在git中输入<code>git merge moke</code>,可以看到<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/25.png" alt="25"><br>再打开 introduction.md ，可以看到在master分支中第二行继承了 <strong>“moke”</strong>的状态，也就是被删除了。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/21.png" alt="21">    </p>
<h3 id="删除git分支"><a href="#删除git分支" class="headerlink" title="删除git分支"></a>删除git分支</h3><p>git中删除分支的命令格式如下：  </p>
<blockquote>
<p><code>git branch -d (branchname)</code>  </p>
</blockquote>
<p>上面我们将 <strong>“moke”</strong>分支合并到了master中，那么现在 <strong>“moke”</strong>分支没用了，我们就要准备删除这个分支了。<br>在git中输入<code>git branch -d moke</code>,可以看到 <strong>“moke”</strong>分支已经被删除了<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-BYSKY/26.png" alt="26">  </p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ul>
<li>合并冲突分支</li>
<li>git clone 与 pull、fetch之间的区别</li>
<li>git log命令的使用</li>
<li>git blame命令的使用</li>
<li>git diff命令的使用</li>
<li>远程仓库的使用进阶</li>
<li>git版本回溯</li>
</ul>
]]></content>
      <categories>
        <category>recruitment</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>software-engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试复习</title>
    <url>/2024/01/10/software-test-review/</url>
    <content><![CDATA[<h1 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h1><h2 id="第一章-概述及基础"><a href="#第一章-概述及基础" class="headerlink" title="第一章 概述及基础"></a>第一章 概述及基础</h2><h3 id="对软件测试的理解"><a href="#对软件测试的理解" class="headerlink" title="对软件测试的理解"></a>对软件测试的理解</h3><ul>
<li><p>正向思维：以功能验证为导向，证明软件是正确的</p>
</li>
<li><p>逆向思维：以破坏性检测为导向，为了找到软件中的错误（<strong>发现错误</strong>）</p>
</li>
<li><p>软件 &#x3D; 程序 + 文档</p>
</li>
<li><p>软件测试 ≠ 程序测试</p>
</li>
</ul>
<p><strong>软件测试标准定义</strong>：</p>
<ul>
<li>使用人工或自动手段，来运行或测试某个系统的过程。其目的在于检验它是否满足规定的需求或弄清预期结果与实际结果之间的差别</li>
<li>软件测试是以检验是否满足需求为目标</li>
</ul>
<span id="more"></span>

<h3 id="对缺陷的理解"><a href="#对缺陷的理解" class="headerlink" title="对缺陷的理解"></a>对缺陷的理解</h3><p>Bug：Bug是软件中（包括程序和文档）不符合用户需求的问题</p>
<ul>
<li><p>完全没有实现的功能</p>
</li>
<li><p>功能或性能问题或差异</p>
</li>
<li><p>多余的功能</p>
</li>
<li><p>差错Error：计算的、观测的、测量的值或条件与真实的、规定的、理论上正确的值或条件之间的差异。</p>
</li>
<li><ul>
<li>可由系统或组件的内部缺陷（fault）引起。</li>
</ul>
</li>
<li><p>失效Failure：由于缺陷而导致要素（element）或相关项(item)预期功能的终止。</p>
</li>
<li><p>缺陷Fault：可引起要素（element）或相关项(item) 失效（fail）的异常情况。</p>
</li>
<li><ul>
<li>当一个子系统处于差错（error）状态时，可能导致系统缺陷（fault）。<br>缺陷（fault）可能导致差错（error），差错（error）可能导致缺陷（fault）。</li>
</ul>
</li>
</ul>
<h3 id="软件质量保证"><a href="#软件质量保证" class="headerlink" title="软件质量保证"></a>软件质量保证</h3><p><strong>软件质量保证（Software Quality Assurance，SQA）</strong>: 为确保软件开发过程和结果符合预期要求而建立的<strong>一系列规程</strong>，以及依照规程和计划采取的<strong>一系列活动及其结果评价</strong>。</p>
<ul>
<li>SQA：管理工作，预防问题，侧重对流程的评审和监控</li>
<li>ST：技术工作，发现问题，侧重对产品进行评估和验证</li>
<li>ST是SQA重要手段之一</li>
<li>充分的测试不能保障软件产品质量，是高质量的必要非充分条件</li>
</ul>
<h3 id="软件测试的基本原则"><a href="#软件测试的基本原则" class="headerlink" title="软件测试的基本原则"></a><em>软件测试的基本原则</em></h3><p><strong>软件测试工程的目标</strong>：尽可能早地找出软件缺陷，确保其得以修复</p>
<ol>
<li>测试应该尽早启动，尽早介入</li>
<li>测试应该追溯需求</li>
<li>不可能进行穷尽测试</li>
<li>Zero Bug与Good Enough</li>
<li>缺陷存在群集现象</li>
<li>缺陷具有免疫性（杀虫剂悖论）</li>
<li>不存在缺陷的理论（测试无法显示潜伏的软件缺陷）</li>
</ol>
<h3 id="软件测试的分类"><a href="#软件测试的分类" class="headerlink" title="软件测试的分类"></a>软件测试的分类</h3><ul>
<li><p>黑盒测试</p>
</li>
<li><ul>
<li>功能测试</li>
</ul>
</li>
<li><ul>
<li>数据驱动测试</li>
</ul>
</li>
<li><p>白盒测试</p>
</li>
<li><ul>
<li>结构测试</li>
</ul>
</li>
<li><ul>
<li>逻辑驱动测试</li>
</ul>
</li>
<li><p>静态测试：不实际运行被测软件，只是静态地检查程序代码、界面或文档中可能存在错误的过程。</p>
</li>
<li><p>动态测试：通过真正运行程序发现错误，通过观察代码运行过程，来获取系统信息，对系统行为进行验证。</p>
</li>
</ul>
<p>不同测试级别的任务：</p>
<ol>
<li>实现（编码）：调试</li>
<li>组件测试：组件功能、健壮性、效率</li>
<li>集成测试：组件之间的接口</li>
<li>系统测试：系统功能、安全性、健壮性、效率</li>
<li>验收测试：功能及用户界面、安全性、效率、用户的可接受性</li>
</ol>
<ul>
<li>系统非功能性测试：系统非功能性测试是将软件放在整个计算机环境下，包括软硬件平台、某些支持软件、数据和人员等，在实际运行环境下进行一系列的测试。包括恢复测试、安全测试、强度测试、性能测试。</li>
<li>系统功能测试：功能测试一般须在完成集成测试后进行，而且是针对应用系统进行测试。功能测试是基于产品功能说明书，是在已知产品所应具有的功能，从用户角度来进行功能验证，以确认每个功能是否都能正常使用。</li>
</ul>
<h3 id="软件测试的过程模型"><a href="#软件测试的过程模型" class="headerlink" title="软件测试的过程模型"></a>软件测试的过程模型</h3><p>软件生命周期（Systems Development Life Cycle, SDLC）：软件开始研制到最终被废弃不用的整个过程。整个生命周期包括问题<strong>定义及规划、需求分析、系统设计、软件编程、软件测试、软件维护等阶段。</strong></p>
<h4 id="V模型"><a href="#V模型" class="headerlink" title="V模型"></a>V模型</h4><p>与软件开发瀑布模型相对应</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401072029581.png"></p>
<p>局限性：测试是设计及编码之后的一个阶段，需求分析阶段隐藏的问题一直到后期的验收测试才被发现</p>
<ul>
<li>验证 (Verification)：Are we building the product right？</li>
<li><ul>
<li>是否正确地构造了软件？即是否正确地做事，验证开发过程是否遵守已定义好的内容。验证产品满足规格设计说明书的一致性</li>
</ul>
</li>
<li>确认（Validation）： Are we building the right product?</li>
<li><ul>
<li>是否构造了正是用户所需要的软件？即是否正在做正确的事。验证产品所实现的功能是否满足用户的需求</li>
</ul>
</li>
</ul>
<h4 id="W模型"><a href="#W模型" class="headerlink" title="W模型"></a>W模型</h4><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401072350659.png"></p>
<ul>
<li>两个V：开发过程&#x2F;测试过程</li>
<li>测试过程：静态测试&#x2F;动态测试</li>
<li>局限性：与V模型一样，软件开发和测试之间保持一种线性的前后关系，需要严格的质量，无法支持代、自发性以及变更调整。对于很多文档事后补充、或者根本没有文档的做法下，令人困惑。</li>
</ul>
<h4 id="H模型"><a href="#H模型" class="headerlink" title="H模型"></a>H模型</h4><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401072352186.png"></p>
<ul>
<li>软件测试是一个独立的流程，贯穿于产品的整个生命周期，与其他流程并发地进行</li>
<li>软件测试原则“尽早准备，尽早执行”</li>
</ul>
<h4 id="X模型"><a href="#X模型" class="headerlink" title="X模型"></a>X模型</h4><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401072353919.jpg"></p>
<ul>
<li>左边描述的是针对单独程序片段所进行的相互分离的编码和测试单独程序片段再进行频繁交接，通过集成最终合成可执行的程序已通过集成测试的成品可以进行封版并提交给用户</li>
<li>探索性测试：未计划的特殊测试</li>
</ul>
<h3 id="实体产品的测试实例——作业"><a href="#实体产品的测试实例——作业" class="headerlink" title="实体产品的测试实例——作业"></a>实体产品的测试实例——作业</h3><p>矿泉水瓶测试实例:</p>
<ol>
<li>外观界面</li>
</ol>
<ul>
<li>视觉检查：检查矿泉水瓶的外观是否有明显缺陷，如裂痕、变色或异物。</li>
<li>标签信息验证：检查生产日期、有效期、容积标记是否清晰、准确。</li>
</ul>
<ol start="2">
<li>功能测试</li>
</ol>
<ul>
<li>泄漏测试：对瓶子进行倒置、侧放、挤压等动作，观察是否有水滴漏出。</li>
<li>容积验证：用已知容积的容器倒入水进行比对，或者使用测量工具测量瓶身尺寸后计算理论容积。</li>
</ul>
<ol start="3">
<li>性能测试</li>
</ol>
<ul>
<li>耐压测试：使用专业设备或方法对瓶子施加压力，记录变形和破裂点。</li>
<li>耐温测试：将瓶子置于不同温度环境中，观察其物理性能和外观变化。</li>
</ul>
<ol start="4">
<li>安全性测试</li>
</ol>
<ul>
<li>材质检测：送检实验室进行有害物质溶出测试。</li>
<li>边缘处理测试：用手指沿瓶口、瓶盖边缘滑动，感受是否有刮手感。</li>
</ul>
<ol start="5">
<li>易用性测试</li>
</ol>
<ul>
<li>开启闭合测试：多次开启和关闭瓶盖，检查顺畅度和密封性。</li>
<li>手持感测试：不同用户握持瓶子，收集手感反馈。</li>
</ul>
<ol start="6">
<li>兼容性测试</li>
</ol>
<ul>
<li>条码扫描测试：使用不同品牌和型号的扫描器扫描条码，验证识别率。</li>
<li>环境兼容性测试：将瓶子置于高温、低温、高海拔等环境，检查其物理和功能性能。</li>
</ul>
<h2 id="第二章-基础测试过程"><a href="#第二章-基础测试过程" class="headerlink" title="第二章 基础测试过程"></a>第二章 基础测试过程</h2><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401081908929.png"></p>
<ol start="0">
<li>制定测试的目标和依据</li>
<li>测试需求分析</li>
<li>制定测试计划</li>
<li>设计测试用例、开发测试工具或脚本</li>
<li>执行测试</li>
<li>测试结果分析</li>
<li>提交测试报告</li>
</ol>
<h3 id="测试需求分析（软件需求评审）"><a href="#测试需求分析（软件需求评审）" class="headerlink" title="测试需求分析（软件需求评审）"></a>测试需求分析（软件需求评审）</h3><p>测试进入的准则：</p>
<ul>
<li>清楚了解项目的整体计划<strong>框架</strong></li>
<li><strong>完成需求规格说明书评审</strong></li>
<li><ul>
<li>消除歧义、完善细节、达成共识</li>
</ul>
</li>
<li>技术<strong>知识</strong>或业务知识的储备</li>
<li>标准环境技术设计<strong>文档</strong></li>
<li>足够的<strong>资源</strong></li>
<li><strong>人员</strong>组织结构及其责任已确定</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401081911242.png"></p>
<ul>
<li>产品人员：需求文档</li>
<li>开发人员：概要&#x2F;详细设计文档，编码</li>
<li>测试人员：测试计划、测试用例</li>
</ul>
<p>静态测试包括对软件产品的需求和设计规格说明书的<strong>评审</strong>、对程序代码的<strong>审查</strong>以及<strong>静态分析</strong>等。将需求和设计的评审纳入测试的范畴，可看作是广义测试。</p>
<ul>
<li><strong>代码测试</strong>：测试代码是否符合相应的标准和规范</li>
<li><strong>界面测试</strong>：测试软件的实际界面与需求中的说明是否相符合</li>
<li><strong>文档测试</strong>：测试用户手册和需求说明是否真正符合用户的实际需求</li>
</ul>
<p>评审的形式&#x2F;方法：代码检查与走查、互为评审、会议评审</p>
<p>测试人员参与产品需求分析和系统设计，认真阅读有关文档，真正理解客户的需求和技术上的设计，检查需求说明书对产品描述的准确性、一致性等，检查系统设计的合理性和可测试性等。</p>
<p>需求文档测试原则：</p>
<ul>
<li>完整性：每一项需求都必须将所要实现的功能描述清楚，以使开发人员获得设计和实现这些功能所需的所有必要信息。</li>
<li>正确性</li>
<li>一致性</li>
<li>可行性</li>
<li>无二义性</li>
<li>健壮性：需求的说明中是否对可能出现的异常进行了分析，并且对这些异常进行了容错处理。</li>
<li>必要性：“必要性”可以理解为每项需求都是用来授权编写文档的“根源”。要使每项需求都能回溯至某项客户的输入，如Use Case或别的来源。</li>
<li>可测试性：每一项需求都必须将所要实现的功能描述清楚，以使开发人员获得设计和实现这些功能所需的所有必要信息。</li>
<li>可修改性：每一项需求都必须准确地陈述其要开发的功能。</li>
<li>可跟踪性：应能在每项软件需求与它的根源和设计元素、源代码、测试用例之间建立起链接链，这种可跟踪性要求每项需求以一种结构化的，粒度好 (fine-grained)的方式编写并单独标明，而不是大段大段的叙述。</li>
</ul>
<p>测试需求分析是测试设计和开发测试用例的基础：</p>
<ul>
<li>确定测试范围</li>
<li>测试项和测试子项</li>
<li>测试优先级</li>
<li>测试风险</li>
</ul>
<ol>
<li>测试需求主要解决“测什么”的问题，应全部覆盖已定义的业务流程</li>
<li>软件测试需求是设计测试用例的依据，有助于保证测试的质量和进度，是衡量测试覆盖率的重要指标</li>
<li>测试需求分析的主要目的：依据需求文档<strong>提取测试点</strong>，根据测试点来编写测试用例<ul>
<li><strong>单独功能测试</strong>：通过分析需求描述中的输入、输出、处理、限制、约束等，给出对应的验证内容</li>
<li><strong>功能交互测试</strong>：通过分析各个功能模块之间的业务顺序，和各个功能模块之间传递的信息和数据，对存在功能交互的功能项，给出对应的验证内容</li>
<li><strong>界面、易用性、安全性、性能压力</strong></li>
</ul>
</li>
</ol>
<p>测试需求分析项：</p>
<ul>
<li>项目背景</li>
<li><strong>业务（流程、用户角色）</strong>：观察、分析用户的心理、行为和预期</li>
<li><strong>用例、场景</strong></li>
<li>支撑业务的功能</li>
<li>功能优先级</li>
<li>非功能特性：性能需求（清楚而量化），充分的安全性测试、容错性测试和负载测试</li>
</ul>
<p>软件需求的层次：</p>
<ul>
<li><strong>业务需求</strong>反映组织机构或客户对系统、产品的概括性要求，包括所要达到的业务目标，由项目视图与范围文档说明</li>
<li><strong>用户角色需求</strong>描述用户使用系统而要完成的各种任务，由用例（use case）文档或方案脚本说明。<strong>用户角色需求可以扩展到涉众（干系人）需求</strong></li>
<li><strong>功能需求</strong>定义开发人员必须实现的软件功能，它源于用户需求，是软件需求说明书中重要的组成部分</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401081927727.png"></p>
<p><strong>编写测试用例</strong>：</p>
<ul>
<li>测试用例编号：Input_001</li>
<li>测试优先级：中</li>
<li>测试目的：验证业务单据数据的查询正确性</li>
<li>标题：业务单据查询</li>
<li>步骤：<ol>
<li>打开查询界面</li>
<li>输入查询条件</li>
<li>确定并提交查询</li>
<li>查看并验证返回的信息</li>
</ol>
</li>
</ul>
<h3 id="测试计划"><a href="#测试计划" class="headerlink" title="测试计划"></a>测试计划</h3><p>软件测试计划的重点工作：</p>
<ul>
<li>明确测试目标</li>
<li>分析与确定测试范围</li>
<li>识别测试项及其优先级<ul>
<li>以上为测试需求分析阶段</li>
</ul>
</li>
<li>测试阶段出入准则</li>
<li>测试工作量估算</li>
<li>测试资源、进度等安排</li>
<li>识别测试风险，采取相应对策</li>
</ul>
<p>测试目标和准则：确测试目标是测试需求分析和测试计划的前提</p>
<ul>
<li>提供<strong>哪些质量风险</strong>信息</li>
<li>新改动的<strong>业务</strong>是否正确实现，对已有业务是否有负面影响</li>
<li>是否满足<strong>功能性要求和非功能性要求</strong></li>
<li>在测试<strong>覆盖率</strong>、测试<strong>效率</strong>上的具体要求</li>
</ul>
<p>测试资源安排：</p>
<ul>
<li>人力资源、系统资源（硬件和软件资源）以及环境资源</li>
<li>由于每个人的思维存在局限性，每项测试最后安排不少于2个人测试，以便交叉测试</li>
</ul>
<p>测试计划内容：软件测试计划是指导测试过程的纲领性文件，描述测试活动的范围、方法、策略、资源、任务安排和进度等，并确定测试项、哪些功能特性将被测试、哪些功能特性将无需测试，识别测试过程中的风险。</p>
<p>测试范围：</p>
<ul>
<li>新功能</li>
<li>升级测试（兼容性）</li>
<li>已解决的故障再次验证</li>
<li>基本功能（加入新功能之后）</li>
<li>可靠性、性能是否达标</li>
<li>文档的测试验证</li>
</ul>
<p>软件测试<strong>每个阶段</strong>需要控制进入&#x2F;退出标准以保障测试的质量</p>
<ul>
<li>进入准则：对软件测试切入点的确立，即满足什么条件，才启动测试</li>
<li>退出标准：满足某个阶段结束&#x2F;里程碑达到的事先定义的要求</li>
</ul>
<p>测试工作量是根据测试范围、策划任务和开发阶段来确定的，测试范围和测试任务是测试工作量估算的主要依据。<br>测试工作量的估算依赖于测试任务的细化，对每项测试任务进行分解，然后根据分解的子任务进行估算。通常分解粒度越小，估算精度越高。</p>
<p>软件测试总是存在较高的风险，测试风险管理就是设法降低或缓解测试过程中的风险</p>
<ul>
<li>项目计划变更、测试资源不能到位可能产生风险</li>
<li>实际操作时的建议：建立后备机制，让后备测试人员参与项目例会，评审，培训，交流等活动</li>
</ul>
<p>测试计划是一个过程</p>
<ul>
<li>确认测试目标、范围和需求</li>
<li>识别测试风险，制订相应的测试策略</li>
<li>对测试任务和工作量进行估算</li>
<li>确定所需的时间和资源</li>
<li><strong>进度安排和资源分派，包括团队角色、责任和培训</strong></li>
<li>测试阶段划分，包括阶段性任务和成果</li>
<li><strong>计划评审与批准</strong></li>
<li>跟踪和控制机制</li>
</ul>
<h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><p>测试用例：</p>
<ul>
<li>定义：在测试执行之前设计的一套详细的测试方案，包括测试环境、测试步骤、测试数据和预期结果。</li>
<li><ul>
<li>测试用例&#x3D;输入（测试步骤和操作步骤）+输出（期望结果）+ <strong>测试环境</strong>（系统环境设置）</li>
</ul>
</li>
<li>时机：通常在测试设计阶段来写，即在《需求规格说明书》和《测试计划》都已完成之后。</li>
<li>唯一标准：用户的需求，具体参考资料就是《系统需求规格规格说明书》和软件原型。</li>
<li>作用：在已知软件产品功能的基础上：</li>
<li><ul>
<li>便于团队交流</li>
</ul>
</li>
<li><ul>
<li>便于重复测试</li>
</ul>
</li>
<li><ul>
<li>便于跟踪统计</li>
</ul>
</li>
<li><ul>
<li>便于用户自测</li>
</ul>
</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401081939134.png"></p>
<p>现代黑盒测试是从一种从软件外部对软件实施的测试，也称<strong>基于规格说明</strong>的测试。</p>
<ul>
<li>任何程序都可以看作是<strong>从输入定义域到输出值域的映射</strong>，将被测程序看作一个打不开的黑盒，黑盒里面的内容(实现)是完全不知道的，只知道<strong>软件要做什么</strong>。</li>
</ul>
<p>黑盒测试是从用户观点出发的测试，其目的是尽可能发现软件的<strong>外部</strong>行为错误。<br>在已知软件产品功能的基础上，</p>
<ul>
<li>检测软件功能能否按照需求规格说明书的规定正常工作，是否有功能遗漏；</li>
<li>检测是否有人机交互错误，是否有数据结构和外部数据库访问错误，是否能恰当地接收数据并保持外部信息（如数据库或文件）等的完整性；</li>
<li>检测行为、性能等特性是否满足要求等；</li>
<li>检测程序初始化和终止方面的错误等。</li>
</ul>
<p>显著优点：</p>
<ul>
<li>黑盒测试与软件具体实现无关，所以如果软件实现发生了变化，测试用例仍然可以使用；</li>
<li>设计黑盒测试用例可以和软件实现同时进行，因此可以压缩项目总的开发时间。</li>
</ul>
<p>黑盒测试用例设计方法：</p>
<ul>
<li>等价类划分法</li>
<li>边界值分析法</li>
<li>因果图法</li>
<li>判定表法</li>
<li>正交分解法</li>
<li>基本路径分析法</li>
<li>场景设计法</li>
<li>错误推测法</li>
</ul>
<h4 id="等价类划分法"><a href="#等价类划分法" class="headerlink" title="等价类划分法"></a>等价类划分法</h4><p>定义：</p>
<ul>
<li><p>等价类划分法是一种典型的黑盒测试方法，它完全不考虑程序的内部结构，只根据程序规格说明书对输入范围进行划分。</p>
</li>
<li><p>把所有可能的输入数据，即程序输入域划分为若干个互不相交的子集，称为<strong>等价类</strong>，然后从每个等价类中选取少数具有代表性的数据作为测试用例，进行测试</p>
</li>
<li><p>在分析需求规格说明的基础上划分等价类，列出<strong>等价类表</strong>。</p>
</li>
<li><p>等价类是某个输入域的子集，在<strong>该子集中每个输入数据的作用是等效的</strong>。</p>
</li>
<li><p>分为<strong>有效等价类</strong>和<strong>无效等价类</strong></p>
</li>
<li><ul>
<li>对于程序的规格说明来说是合理的、有意义的输入数据构成的集合。利用有效等价类可以检验程序是否实现了规格说明中所规定的功能和性能。</li>
</ul>
</li>
<li><ul>
<li>反之为无效等价类</li>
</ul>
</li>
<li><ul>
<li>设计测试用例时，要同时考虑这两种等价类。因为软件不仅要能接收合理的数据，也要能经受异常数据的考验。经过正反的测试才能确保软件具有更高的可靠性。</li>
</ul>
</li>
</ul>
<p>确定等价类的原则：</p>
<ol>
<li>输入条件规定了<strong>取值范围</strong>或<strong>值的个数</strong>的情况下，则可以确立一个有效等价类和两个无效等价类。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401081944247.png"></li>
<li>在输入条件规定了输入值的集合或者规定了“必须如何”的条件的情况下，可以确立一个有效等价<br>类和一个无效等价类。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401081946137.png"></li>
<li>在输入条件是一个布尔量的情况下，可确定一个有效等价类和一个无效等价类。</li>
<li>在规定了输入数据的一组值(假定n个)，并且程序要对每一个输入值分别处理的情况下，可确立n个有效等价类和一个无效等价类。（<strong>多输入的或关系</strong>）</li>
<li>在规定了输入数据必须遵守的规则的情况下，可确立一个有效等价类(符合规则)和若干个无效等价类(从不同角度违反规则)。（<strong>多输入的且关系</strong>）</li>
<li>在确知已划分的等价类中，各元素在程序处理中的方式不同的情况下，则应再将该等价类进一步地划分为更小的等价类。（<strong>细分等价类</strong>）</li>
</ol>
<p>根据等价类创建测试用例的步骤</p>
<ol>
<li>建立等价类表，列出所有划分出的等价类<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401081949839.png"></li>
<li>为每个等价类规定一个唯一的编号</li>
<li>设计一个新的测试用例，使其<strong>尽可能多地</strong>覆盖<strong>尚未覆盖的有效等价类</strong></li>
<li>重复3，最后使得所有有效等价类均被测试用例所覆盖</li>
<li>设计一个新的测试用例，使其<strong>只覆盖一个无效等价类</strong></li>
<li>重复5使所有无效等价类均被覆盖。</li>
</ol>
<p>规格说明往往<strong>没有定义无效测试用例的期望输出</strong>应该是什么样的。因此，测试人员需要花费大量时间来定义这些测试用例的期望输出。</p>
<ul>
<li>边界值和等价类<strong>密切相关</strong>，输入等价类和输出等价类的边界是要着重测试的边界情况。在等价类的划分过程中就产生了许多等价类边界。边界是最容易出错的地方，所以，从等价类中选取测试数据时应该关注边界值。</li>
<li>在等价类划分基础上进行边界值分析测试的<strong>基本思想</strong>是，选取正好等于、刚刚大于或刚刚小于等价类边界的值作为测试数据，而不是选取等价类中的典型值或任意值做为测试数据。</li>
</ul>
<h4 id="边界值分析法"><a href="#边界值分析法" class="headerlink" title="边界值分析法"></a>边界值分析法</h4><p>大量的软件测试实践表明，故障往往出现在定义域或值域的边界上，而不是在其内部。为检测边界附近的处理专门设计测试用例，通常都会取得很好的测试效果。</p>
<ul>
<li>边界值分析法是一种很实用的黑盒测试用例方法，它具有很强的发现故障的能力。</li>
<li>很多错误发生在<strong>输入或输出范围的边界</strong>上，因此针对各种边界情况设置测试用例，可以更有效地发现缺陷。</li>
<li>边界条件就是软件计划的操作界限所在的边缘条件。</li>
</ul>
<p>边界是指相当于输入等价类和输出等价类而言，稍高于边界值及稍低于其边界值的一些特定情况。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 任意的正常值: 随机选择几个选项</span><br><span class="line"><span class="bullet">-</span> 边界值: 选择所有选项</span><br><span class="line"><span class="bullet">-</span> 边界值: 一个都不选</span><br><span class="line"><span class="bullet">-</span> 边界值: 选择一个选项</span><br></pre></td></tr></table></figure>

<p>次边界条件：</p>
<ul>
<li>普通边界条件最容易找到，在产品说明书中有定义，或者在使用软件的过程中确定。</li>
<li>有些边界在软件的内部，最终用户几乎看不到，但是软件测试仍有必要检查。这种边界条件称为<strong>次边界条件</strong>或者<strong>内部边界条件</strong>。</li>
</ul>
<p>确定边界值的原则：</p>
<ol>
<li>如果输入条件规定了<strong>值的范围</strong>，则应取刚达到这个范围的边界的值，以及刚刚超越这个范围边界的值作为测试输入数据。</li>
<li>如果输入条件规定了<strong>值的个数</strong>，则用最大个数、最小个数、比最小个数少、比最大个数多1的数作为测试数据。</li>
<li>很多如果程序的规格说明给出的<strong>输入域或输出域是有序集合</strong>，则应选取集合的第一个元素和最后一个元素作为测试用例。</li>
<li>如果程序中使用了一个<strong>内部数据结构</strong>，则应当选择这个内部数据结构的边界上的值作为测试用例。</li>
</ol>
<ul>
<li>加法器边界测试用例（等价类）<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401081957992.png"></li>
<li>加法器边界测试用例（边界值）<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401081958934.png"></li>
</ul>
<p>健壮性边界测试：变量除了取min，min＋，nom，max－，max五个边界值外，还要考虑采用一个略超过最大值（max+）以及一个略小于最小值 (min-) 的取值。健壮性测试最有意义的部分不是输入，而是预期的输出，观察例外情况如何处理。</p>
<ul>
<li>对于一个n变量的程序，边界值分析测试会产生4n+1个测试用例。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092132168.png"></li>
<li>对于一个n变量的程序，健壮性边界值测试将产生6n+1个测试用例<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092133878.png"></li>
</ul>
<h4 id="等价类、边界值分析法习题"><a href="#等价类、边界值分析法习题" class="headerlink" title="等价类、边界值分析法习题"></a>等价类、边界值分析法习题</h4><p>【例】某商店的货品价格（P）都不大于20元（且为整数），假设顾客每次付款为20元且每次限购一件商品，现有一个软件能在每位顾客购物后给出找零钱的最佳组合（找给顾客货币张数最少）。<br>假定此商店的找零货币面值只包括：10元（N10）、5元（N5）、1元（N1）3种。请采用等价类划分法为该软件设计测试用例（不考虑P 为非整数的情况）并填入到下表中。（&lt;&lt;N1,2&gt;&gt;表示2 张1 元，若无输出或输出非法，则填入N&#x2F;A）</p>
<p>答案：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>输入（商品价格P）</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>20（P&#x3D;20）</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>2</td>
<td>18（任意15&lt;P&lt;20）</td>
<td>&lt;&lt;N1, 2&gt;&gt;</td>
</tr>
<tr>
<td>3</td>
<td>15（P&#x3D;15）</td>
<td>&lt;&lt;N5, 1&gt;&gt;</td>
</tr>
<tr>
<td>4</td>
<td>10（P&#x3D;10）</td>
<td>&lt;&lt;N10, 1&gt;&gt;</td>
</tr>
<tr>
<td>5</td>
<td>5（P&#x3D;5）</td>
<td>&lt;&lt;N5, 3&gt;&gt;</td>
</tr>
<tr>
<td>6</td>
<td>1（P&#x3D;1）</td>
<td>&lt;&lt;N1, 19&gt;&gt;</td>
</tr>
<tr>
<td>7</td>
<td>0（P&#x3D;0）</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>8</td>
<td>19（任意15&lt;P&lt;20）</td>
<td>&lt;&lt;N1, 1&gt;&gt;</td>
</tr>
<tr>
<td>9</td>
<td>14（任意10&lt;P&lt;15）</td>
<td>&lt;&lt;N5, 1&gt;, &lt;N1, 1&gt;&gt;</td>
</tr>
<tr>
<td>10</td>
<td>9（任意5&lt;P&lt;10）</td>
<td>&lt;&lt;N10, 1&gt;, &lt;N1, 1&gt;&gt;</td>
</tr>
<tr>
<td>11</td>
<td>4（任意0&lt;P&lt;5）</td>
<td>&lt;&lt;N5, 1&gt;, &lt;N1, 16&gt;&gt;</td>
</tr>
</tbody></table>
<h4 id="判定表-x2F-决策表方法"><a href="#判定表-x2F-决策表方法" class="headerlink" title="判定表&#x2F;决策表方法"></a>判定表&#x2F;决策表方法</h4><p>判定表是把作为条件的所有输入的<strong>各种组合值</strong>以及对应输出值都罗列出来而形成的表格。</p>
<ul>
<li>条件桩：列出问题的所有条件。通常认为列出的条件的次序无关紧要。</li>
<li>条件项：针对所列条件的具体取值，在所有可能情况下的真假值。</li>
<li>动作桩：列出可能针对问题所采取的操作。这些操作的排列顺序没有约束。</li>
<li>动作项：列出在条件项（各种取值）组合情况下应该采取的动作。<br><em>在所有的黑盒测试方法中，基于判定表的测试是最严格，最具有逻辑性的测试方法。</em></li>
</ul>
<p>适合使用判定表设计测试用例的条件：</p>
<ul>
<li>规则说明以判定表的形式给出，或很容易转换成判定表</li>
<li><strong>条件的顺序无关</strong>：条件（C）的排列顺序不影响执行哪些操作（A）</li>
<li><strong>操作&#x2F;活动的顺序无关</strong>：如果某一规则要执行多个操作，这些操作的执行顺序无关紧要</li>
<li><strong>规则之间的无关联</strong>：规则（R）的排列顺序不影响执行哪些操作；当某一条规则（R）的条件（C）已经满足，并确定要执行的操作（A）后，不必检验别的规则</li>
</ul>
<p>步骤：</p>
<ol>
<li>列出条件桩</li>
<li>列出动作桩</li>
<li>填入条件项及其组合</li>
<li>填入动作项，制定初始判定表</li>
<li>简化、合并相似规则或者相同动作</li>
</ol>
<p>示例：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092144500.png"></p>
<h4 id="因果图法"><a href="#因果图法" class="headerlink" title="因果图法"></a>因果图法</h4><p><strong>组合之间有关系</strong>：多种输入条件的组合，输入之间有关系，例如，约束关系、组合关系，需要进行因果分析，不可直接采用判定表方法。因果图不擅长处理较大的规格说明。</p>
<p>因果图基本符号：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092147335.png"></p>
<p>步骤：</p>
<ol>
<li>分析软件规格说明文档描述的哪些是原因（输入条件），哪些是结果（输出条件）。原因常是输入条件或输入条件的等价类，结果是输出条件；</li>
<li>分析程序规格说明的描述中的语义内容，将其表示成连接各个原因与各个结果的“因果图”；</li>
<li>标明约束条件。在因果图上标上哪些<strong>不可能发生的因果关系</strong>，表明约束或限制条件；</li>
<li>根据因果图，创建判定表，将复杂的逻辑关系和多种条件组合很具体明确的表示出来；</li>
<li>把判定表的每一列作为依据设计测试用例。</li>
</ol>
<p>示例：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092151022.png"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092152692.png"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092153239.png"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092153957.png"></p>
<p>建立有限项的判定表：跟踪图中的状态变化情况，将因果图转换成一个有限项的判定表。表中的每一列代表一个测试用例。</p>
<ul>
<li>选择一个果作为当前状态</li>
<li><strong>对因果图进行回溯，查找导致该果为1的所有因的组合</strong></li>
<li>在判定表中为每个因的组合生成一列</li>
<li>对于每种“因”的组合，判断所有其他“果”的状态，并放置在每一列中。</li>
</ul>
<p>回溯：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092157031.png"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092157818.png"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092158817.png"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092158927.png"></p>
<ul>
<li>因果图没有考虑边界条件。测试用例将边界条件一并考虑；</li>
<li>难点在将因果图转化为判定表，有相关的算法实现及商业软件。</li>
</ul>
<h4 id="两两组合测试"><a href="#两两组合测试" class="headerlink" title="两两组合测试"></a>两两组合测试</h4><ul>
<li>假如一个软件系统由N个构件组成（或者说由N个因素决定），大部分的软件错误是由一个构件的错误所导致，或者由2个构件之间的交互错误导致。</li>
<li><strong>大部分缺陷是在两个变量取值冲突的测试时被发现的</strong></li>
<li>构造测试用例需要涵盖每个因素的所有状态，并且涵盖每2个因素之间的所有交互。</li>
<li>不仅仅是在所有的组合情况下才会发现所有的测试缺陷</li>
<li>没有必要构造覆盖所有因素的所有组合的测试用例集合，<strong>只需要构造覆盖每个因素的所有状态，覆盖任意2个因素所有状态的测试用例集合。</strong></li>
</ul>
<h5 id="正交试验法（Orthogonal-Test-Design-Method-OTDM）"><a href="#正交试验法（Orthogonal-Test-Design-Method-OTDM）" class="headerlink" title="正交试验法（Orthogonal Test Design Method, OTDM）"></a>正交试验法（Orthogonal Test Design Method, OTDM）</h5><p>正交表法（Orthogonal Array Testing Strategy, OATS ）：正交表的两大优越性，即“均匀分散，整齐可比”。特性中有任意一条不满足，就不是正交表。</p>
<ul>
<li>每列中不同数字出现的次数相等</li>
<li>任意两列，其横向组成的数字对，每种数字对出现的次数相等</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092206485.png"></p>
<ul>
<li>m: 因子</li>
<li>n : 水平 </li>
<li>试验次数 ：m*(n-1)+1</li>
<li>eg: 4*（3-1）+1&#x3D;9<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092208902.png"></li>
</ul>
<h5 id="正交表法练习"><a href="#正交表法练习" class="headerlink" title="正交表法练习"></a>正交表法练习</h5><p>【例】考察5个3水平因子、以及一个2水平因子，选择合适的正交表。</p>
<p>考察5个3水平因子和一个2水平因子时，选择合适的正交表需要考虑因子的水平数和实验的总次数。正交表通常用符号“L[实验次数]([水平数]^[因子数])”来表示。</p>
<p>在您的案例中，有5个因子各有3个水平，一个因子有2个水平。首先，我们需要一个能容纳3水平因子的正交表。由于最高水平数是3，我们选择以3为基础的正交表。接下来，需要考虑总的实验次数，它应该足够容纳所有因子的组合。</p>
<!-- TODO：计算 -->

<h5 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h5><ul>
<li>在因子水平数比较少的情况下，采用配对测试方法。因为测试组合数更加全面一些，当然在某些因子水平数时，两者最后筛选出的结果可能是一致的。</li>
<li>在因子水平数比较多的情况下，采用正交表测试，因为可以得到更加精炼的测试组合，从而使测试效率得到提升</li>
</ul>
<h5 id="组合分析方法作业"><a href="#组合分析方法作业" class="headerlink" title="组合分析方法作业"></a>组合分析方法作业</h5><p>某一在线购物网站，有多种条件影响操作界面或操作功能，主要有以下几个方面：</p>
<ul>
<li>登录方式（LOGIN）：未登录、第一次登录、正常登录；</li>
<li>会员状态（MEMBERSHIP）：非会员、会员、VIP、雇员；</li>
<li>折扣（DISCOUNT）：没有、假日95折、会员9折、VIP会员8折</li>
<li>物流方式（SHIP）：标准、快递、加急。<br>设计测试组合。可以考虑增加一些约束条件，进一步优化或减少组合。<br>IF [LOGIN]&#x3D;’未登录’ THEN [MEMBERSHIP]&#x3D;’非会员’<br>IF [LOGIN]&#x3D;’第一次登录’ THEN [MEMBERSHIP]&lt;&gt;’ VIP会员’<br>IF [MEMBERSHIP]&#x3D;’会员’ THEN [DISCOUNT]&#x3D;’会员9折’<br>IF [MEMBERSHIP]&#x3D;’VIP会员’ THEN [DISCOUNT]&#x3D;’会员8折’<br>采用微软PICT和正交表构造法生成测试用例，比较两种方法的结果。</li>
</ul>
<!-- TODO：做 -->

<h4 id="功能图法"><a href="#功能图法" class="headerlink" title="功能图法"></a>功能图法</h4><ul>
<li><p>每个程序的功能通常由静态说明和<strong>动态说明</strong>组成</p>
</li>
<li><p>静态说明描述了输入条件和输出条件之间的对应关系</p>
</li>
<li><p>动态说明描述了输入数据的次序或者转移的次序</p>
</li>
<li><p>功能图法就是为了解决动态说明问题的一种测试用例的设计方法</p>
</li>
<li><p>功能图由状态迁移图（state transition diagram，STD）和逻辑功能模型（logic function model，LFM）构成</p>
</li>
<li><p>状态迁移图</p>
</li>
<li><ul>
<li>表示<strong>输入数据序列</strong>以及相应的输出数据。</li>
</ul>
</li>
<li><ul>
<li>由状态和迁移来描述，状态指出数据输入的位置（或时间），而迁移则指明状态的改变。</li>
</ul>
</li>
<li><ul>
<li>在STD中，输入数据和当前状态决定输出数据和后续状态。</li>
</ul>
</li>
<li><p>状态逻辑功能模型</p>
</li>
<li><ul>
<li>表示状态中输入条件和输出条件之间的对应关系。逻辑功能模型只适合于描述静态说明，输出数据仅由输入数据决定。</li>
</ul>
</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092229092.png"></p>
<p>功能图生成测试用例的过程：</p>
<ul>
<li>测试用例是由测试中经过的一系列状态和在每个状态中必须依靠输入&#x2F;输出数据满足的一对条件组成。</li>
<li><strong>生成局部测试用例</strong>：在每个状态中，从因果图生成局部测试用例。局部测试库由原因值（输入数据）组合与对应的结果值（输出数据或状态）构成</li>
<li><strong>测试路径生成</strong>：利用上面的规则生成从初始状态到最后状态的测试路径；</li>
<li><strong>测试用例合成</strong>：合成测试路径与功能图中每个状态的局部测试用例。结果是初状态到最后一个状态的一个状态序列，以及每个状态中输入数据与对应输出数据组合。</li>
</ul>
<h4 id="场景设计法"><a href="#场景设计法" class="headerlink" title="场景设计法"></a>场景设计法</h4><p>黑盒测试中重要的测试用例设计方法。目前，多数软件系统都是用事件触发来控制业务流程，事件触发时的情景便形成了场景，场景的不同触发顺序构成了用例。同一事件的不同触发顺序和处理结果就形成<strong>事件流</strong>。</p>
<ul>
<li>基本流（基本流程）</li>
<li>备选流（分支流程）</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092232801.png"></p>
<ul>
<li>采用矩阵或决策表来确定和管理测试用例</li>
<li>确定执行用例场景所需要的数据元素，构建矩阵</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092234681.png"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092233282.png"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401092234150.png"></p>
<ul>
<li>根椐UML覆盖系统用例中的主场景和扩展场景，并且适当补充各种<strong>正、反面的测试用例</strong>和考虑出现的异常情形</li>
<li>测试人员要充分发挥对用户实际业务场景的想象</li>
<li>关心用户做什么，而不是关心产品做什么</li>
<li>优点：实用性强，有效，设计出来的用例有价值</li>
<li>缺点：可能使用的场景不一定能对事件系列进行全面的分析，设计出来的用例不完整。</li>
</ul>
<h4 id="场景法例题"><a href="#场景法例题" class="headerlink" title="场景法例题"></a>场景法例题</h4><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401101720632.png"></p>
<h4 id="错误推测法"><a href="#错误推测法" class="headerlink" title="错误推测法"></a>错误推测法</h4><p>错误推测法是测试者根据经验、知识和直觉来发现软件的错误，来推测程序中可能存在的各种错误，从而有针对性地进行测试。例举出程序中所有可能有的错误和容易发生错误的特殊情况，根据它们选择测试用例。</p>
<p>方便实用，特别在软<strong>件测试基础较差</strong>的情况下，是一种有效的测试方法。但不是一个系统的测试方法，只能用作<strong>辅助手段</strong>。没有别的办法可用时用推测法补充一些测试用例。</p>
<ul>
<li>优点：快速切入体会到程序易用与否； </li>
<li>缺点：难以准确知道测试覆盖率。</li>
</ul>
<h4 id="方法比较与选择"><a href="#方法比较与选择" class="headerlink" title="方法比较与选择"></a>方法比较与选择</h4><ul>
<li><p>静态</p>
</li>
<li><ul>
<li>单因素：等价类划分、边界值分析</li>
</ul>
</li>
<li><ul>
<li>多因素：因果分析法、决策表、组合覆盖、正交实验法</li>
</ul>
</li>
<li><p>动态：功能图、场景法</p>
</li>
<li><p>其他：错误推测法</p>
</li>
<li><p>如果变量引用的是物理量，可采用等价类测试和边界值测试。</p>
</li>
<li><p>如果变量引用的是逻辑量，可采用等价类测试用例和决策表测试。</p>
</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>进行<strong>等价类划分</strong>，包括输入条件和输出条件的等价类划分，将无限测试变成有限测试，这是减少工作量和提高测试效率最有效的方法。</li>
<li>在任何情况下都必须使用<strong>边界值分析方法</strong>，经验表明，用这种方法设计出的测试用例<strong>发现错误的能力强</strong>。</li>
<li>如果程序的功能说明中含有输入条件的组合情况，则一开始就可选用<strong>因果图法</strong>和<strong>判定表法</strong>。</li>
<li>对于配置参数类软件，用<strong>正交试验法</strong>选择较好的组合方式达到最佳效果</li>
<li><strong>功能图法</strong>也是很好的测试用例设计方法，可以通过不同时期条件的有效性设计不同的测试数据</li>
<li>对于业务清晰的系统，可以利用<strong>场景法</strong>贯穿整个测试案例过程在案例中综合使用各种测试方法</li>
<li>可以用<strong>错误推测法</strong>追加一些测试用例，这需要依靠测试工程师的智慧和经验</li>
</ul>
<h3 id="测试执行"><a href="#测试执行" class="headerlink" title="测试执行"></a>测试执行</h3><h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><p>Test Case，在测试执行之前设计的一套详细的测试方案，包括测试环境、测试步骤、测试数据和预期结果。<br>测试用例&#x3D;输入（测试步骤和操作步骤）+输出（期望结果）+ <strong>测试环境</strong>（系统环境设置）</p>
<ul>
<li>用例名称</li>
<li>测试路径</li>
<li>前提条件</li>
<li>详细步骤</li>
</ul>
<h4 id="软件缺陷的生命周期"><a href="#软件缺陷的生命周期" class="headerlink" title="软件缺陷的生命周期"></a>软件缺陷的生命周期</h4><p>软件缺陷生命周期指的是一个软件缺陷被发现、报告到这个缺陷被修复、验证直至最后关闭的完整过程<br>发现——打开——修复——关闭</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401101728129.png"></p>
<ul>
<li>激活或打开（Active or Open）：问题还没有解决 ，存在源代码中，确认“提交地缺陷”，等待处理已</li>
<li>修正或修复（Fixed or Resolved）：已被开发人员检查、修复过的缺陷，通过单元测试，认为已解决但还没有被测试人员验证</li>
<li>关闭或非激活（Close or Inactive）：测试人员验证后，确认缺陷不存在之后的状态</li>
<li>重新打开：测试人员验证后，还依然存在的缺陷，等待开发人员进一步修复</li>
<li>推迟：这个软件缺陷可以再下一个版本中解决</li>
<li>保留：由于技术原因或第三种软件的缺陷，开发人员不能修复的缺陷</li>
<li>不能重现：开发不能复现这个软件缺陷，需要测试人员检查缺陷复现的步骤</li>
<li>需要更多信息：开发能复现这个软件缺陷，但开发人员需要一些信息，例如：缺陷的日志文件、图片等</li>
</ul>
<p>完整缺陷描述的重要因素</p>
<ul>
<li>步骤：提供了如何重复当前缺陷的准确描述，应简明而完备、清楚而准确。这些信息对开发人员是关键的，视为修复缺陷的向导</li>
<li>期望结果：与测试用例标准或设计规格说明书或用户需求等一致，达到软件预期的功能。是验证缺陷的依据。</li>
<li>实际结果：实际执行测试的结果，不同于期望结果，从而确认缺陷的存在</li>
</ul>
<p>测试进度管理：</p>
<ul>
<li>S曲线法：法通过对计划中、尝试的与实际的进度三者对比来实现</li>
<li>NOB（Number of Open Bug）：收集当前所有打开的（激活的）缺陷数</li>
</ul>
<h4 id="软件缺陷的处理和跟踪"><a href="#软件缺陷的处理和跟踪" class="headerlink" title="软件缺陷的处理和跟踪"></a>软件缺陷的处理和跟踪</h4><ul>
<li>收集缺陷数据并根据缺陷趋势曲线识别测试处于测试过程中的哪个阶段</li>
<li>通过缺陷趋势曲线来<strong>确定测试过程是否结束</strong>是常用且较为有效的一种方式</li>
</ul>
<ol>
<li>缺陷趋势分析：监控（打开&#x2F;关闭&#x2F;已修正的）缺陷随时间的变化</li>
<li>缺陷分布分析：缺陷数量与缺陷属性的函数。如测试需求和缺陷状态、严重性的分布情况等</li>
<li>缺陷报告：缺陷分布&#x2F;趋势&#x2F;年龄报告、测试结果进度报告</li>
<li>缺陷跟踪方法</li>
</ol>
<h4 id="测试执行-1"><a href="#测试执行-1" class="headerlink" title="测试执行"></a>测试执行</h4><p>实践经验</p>
<ul>
<li>抽查性质的探索式测试，验证高风险区域的测试质量</li>
<li>交叉互换测试人员所测试的模块，可以发挥互补作用</li>
</ul>
<h4 id="测试管理"><a href="#测试管理" class="headerlink" title="测试管理"></a>测试管理</h4><p>缺陷探测率（DDP Defect Detection Percentage）：衡量测试工作效率的软件质量成本的指标<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401101745932.png"></p>
<h2 id="第三章-开发人员测试"><a href="#第三章-开发人员测试" class="headerlink" title="第三章 开发人员测试"></a>第三章 开发人员测试</h2><h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><ul>
<li>黑盒测试：外部逻辑功能错误，界面错误，安装、卸载时的错误，兼容性错误，性能问题</li>
<li>白盒测试</li>
<li><ul>
<li>程序的源代码有多个分支，，尽可能覆盖所有分支，提高测试覆盖率，黑盒无法做到</li>
</ul>
</li>
<li><ul>
<li>代码中的内存泄漏问题，白盒（eg: C&#x2F;C++）可以很快找到黑盒需要长时间运行才能发现的内存泄漏问题</li>
</ul>
</li>
<li><ul>
<li>极端情况出现，(eg:卫星中的电磁辐射等）难以进行功能测试，一般只对源代码进行静态分析</li>
</ul>
</li>
</ul>
<h4 id="程序静态分析（结构分析）"><a href="#程序静态分析（结构分析）" class="headerlink" title="程序静态分析（结构分析）"></a>程序静态分析（结构分析）</h4><p>方法：</p>
<ul>
<li>程序流程分析：控制流分析、数据流分析</li>
<li>符号执行</li>
</ul>
<p>控制流分析（缺陷——影响）：</p>
<ul>
<li>转向并不存在的符号——程序运行意外终止</li>
<li>存在无用的语句标号——占用额外管理资源</li>
<li>存在不可达语句标号——相应功能无法调用</li>
<li>不可能到达停机语句——程序运行难以终止</li>
</ul>
<p>数据流分析：</p>
<ul>
<li>变量被定义，但从未被使用</li>
<li>变量被使用，但从未被定义</li>
<li>变量在使用之前被定义多次</li>
</ul>
<p>符号执行：得到运行特定区域代码的输入</p>
<ul>
<li>检查程序的执行结果是否符合预期</li>
<li>通过符号执行产生程序的执行路径，为进一步自动生成测试数据提供约束条件</li>
</ul>
<p>静态符号执行：</p>
<ul>
<li><strong>以符号值作为输入</strong>，不使用一般程序运行时使用的具体值，通过符号执行模拟代码运行的过程</li>
<li>任何执行点，符号化执行的<strong>程序状态</strong>包括：</li>
<li><ul>
<li>程序变量在该点的符号值</li>
</ul>
</li>
<li><ul>
<li>路径条件的符号值</li>
</ul>
</li>
<li><ul>
<li>一个程序计数器<br>示例：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401101754005.png"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401101755751.png"></li>
</ul>
</li>
</ul>
<p>动态符号执行：传统符号执行技术无法精确求解路径，也无法获得满足路径条件约束的测试用例</p>
<ul>
<li>结合符号输入和具体数据对程序进行分析</li>
<li>遇到复杂路径或大规模路径时使用具体输入值代替符号输入，驱使符号执行继续向后开展，获得可解的约束路径</li>
<li>优于使用具体值代替了部分符号输入，使得路径约束包含的复杂数据结构和表达式简化，减小符号执行代价<br>具体执行：</li>
<li>运行工具跟踪记录符号状态以及当前路径的运行条件</li>
<li>一条路径运行结束后，运行工具将路径中未覆盖分支的最后一个路径条件约束取反，再将新路径条件传递给约束求解器求解</li>
<li>如果约束求解器可以给出一个满足新路径条件的解，运行工具运行该路径重复上述过程</li>
<li>直到所有路径被覆盖，或覆盖特定目标，或满足时间需求<br>示例：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401101758906.png"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401101758399.png"></li>
</ul>
<p>动态白盒测试：<br>利用查看代码（做什么）和实现方法(怎么做)得到的信息来确定哪些需要测试、哪些不要测试、如何开展测试。又称为<strong>结构化测试</strong>(structral testing)<br><em>用尽量少的测试用例完成尽量高的逻辑覆盖。</em></p>
<h4 id="逻辑覆盖测试法"><a href="#逻辑覆盖测试法" class="headerlink" title="逻辑覆盖测试法"></a>逻辑覆盖测试法</h4><p>逻辑覆盖是通过对<strong>程序逻辑结构的遍历</strong>实现程序的覆盖。</p>
<ul>
<li>语句覆盖（SC）：设计若干测试用例，运行被测程序，使程序中的每个可执行语句至少被执行一次。盖能发现一般语句的错误，但不能发现其中的逻辑错误。</li>
<li>判定覆盖（DC）：设计若干用例，运行被测程序，使得程序中<strong>每个判断</strong>的取真分支和取假分支至少经历一次，即判断真假值均曾被满足。较语句覆盖测试强度更高</li>
<li><ul>
<li>满足判定覆盖 -&gt; 满足语句覆盖</li>
</ul>
</li>
<li>条件覆盖（CC）：设计若干测试用例，执行被测程序以后，要使<strong>每个判断</strong>中<strong>每个条件</strong>的可能取值至少满足一次。虽然条件覆盖分析了更小的条件粒度，与分支覆盖相比，并不具有更高测试强度</li>
<li>判定-条件覆盖（CDC）：是<strong>判定和条件覆盖设计方法的交集</strong>，即设计足够的测试用例，使得判断条件中的所有条件可能取值至少执行一次，同时，所有判断的可能结果至少执行一次</li>
<li>条件组合覆盖（MCC）：设计足够的测试用例，使得判断中每个条件的所有可能组合至少出现一次，并且每个判断本身的判定结果也至少出现一次。</li>
<li><ul>
<li>它与条件覆盖的差别是它不是简单地要求每个条件都出现“真”与“假”两种结果，而是要求让这些结果的所有可能组合都至少出现一次。</li>
</ul>
</li>
<li><ul>
<li><em>满足条件组合覆盖，一定满足判定覆盖、条件覆盖、条件判定组合覆盖</em></li>
</ul>
</li>
</ul>
<p>修正条件&#x2F;判定覆盖（MCDC）：</p>
<ul>
<li>每个程序模块的入口和出口至少执行一次</li>
<li>每个判定的所有可能结果至少能取值一次</li>
<li>判定中的每个条件的所有可能结果至少取值一次</li>
<li>一个判定中的每个条件曾经<strong>独立地</strong>对判定的结果产生影响<br>比条件&#x2F;判定覆盖测试强度更高的逻辑覆盖标准，应用更广泛、测试效果更佳的逻辑覆盖标准。</li>
</ul>
<h4 id="白盒测试逻辑覆盖习题"><a href="#白盒测试逻辑覆盖习题" class="headerlink" title="白盒测试逻辑覆盖习题"></a>白盒测试逻辑覆盖习题</h4><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401101958482.png"></p>
<!-- TODO -->

<h4 id="基本路径测试法"><a href="#基本路径测试法" class="headerlink" title="基本路径测试法"></a>基本路径测试法</h4><p>对程序中的可运行路径进行穷举测试是不可行的，只能选择部分可运行路径作为测试目标。<strong>基本</strong>路径覆盖就是以程序控制流图中的<strong>独立路径</strong>作为覆盖目标的测试方法。基本路径测试并不是测试所有路径的组合，仅仅保证每条基本路径被执行一次。</p>
<ol>
<li>依据代码绘制流程图（控制流图）</li>
<li>确定控制流图的圈&#x2F;环复杂度（cyclomatic complexity）</li>
<li>确定线性独立路径的基本集合（basis set）</li>
<li>设计测试用例覆盖每条基本路径</li>
</ol>
<p>如果判断中的条件表达式是复合条件，即条件表达式是由一个或多个逻辑运算符（or, and, nor）连接的<strong>逻辑表达式</strong>，则需要改变复合条件的判断为<strong>一系列只有单个条件的嵌套的判断</strong>。</p>
<p>控制流图：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401102030801.png"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401102030067.png"></p>
<p>圈复杂度（Cyclomatic complexity）: 环复杂度。确定了程序基本路径集合中独立路径条数的上界。复杂度越高，出错的概率越大。</p>
<ul>
<li><p>V(G) &#x3D; 区域数量(由节点、连线包围的区域，包括图形外部区域)</p>
</li>
<li><p>V(G) &#x3D; 简单可预测节点数量 + 1 &#x3D; 判断节点数目 + 1</p>
</li>
<li><p>V(G) &#x3D; 连线数量 - 节点数量 + 2</p>
</li>
<li><ul>
<li>(包括起点和终点；所有终点只计算一次，多个return和throw算作一个节点)</li>
</ul>
</li>
<li><p>独立路径：至少引入一系列新的处理语句或条件的任何路径。程序中的每条语句至少会包含在一个独立路径中，满足独立路径覆盖需求也必定满足语句覆盖需求。</p>
</li>
<li><p>基本集：由独立路径构成的集合。由基本集导出的测试用例，保证每行代码语句至少被执行一次。基本集合<strong>不一定唯一</strong>。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401102034407.png"></p>
</li>
<li><p>逻辑覆盖：以程序或系统的<strong>内部逻辑结构</strong>为基础，分为语句覆盖、判定覆盖、判定-条件覆盖、条件组合覆盖等</p>
</li>
<li><p>基本路径测试：在程序<strong>或业务</strong>控制流程的基础上，分析控制构造的环路复杂性，导出基本可执行路径集合，从而设计测试用例。</p>
</li>
</ul>
<h4 id="循环测试"><a href="#循环测试" class="headerlink" title="循环测试"></a>循环测试</h4><p>目标 : 在循环内部及边界上执行测试</p>
<p>简单循环（迭代次数n）<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401102038813.png"></p>
<p>嵌套（Nested）循环<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401102039001.png"></p>
<p>串行连接的循环<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401102039694.png"></p>
<p>循环化简：有时无法实现路径覆盖。考虑循环化简，限制循环次数。</p>
<ul>
<li>对循环机制进行简化，舍掉一些次要因素，极大地减少路径数量，使得覆盖有限的路径成为可能。</li>
<li>循环化简，即限制循环的次数。无论循环的形式和实际执行循环体的次数多少，只考虑<strong>循环1次和0次</strong>两种情况，即<strong>进入循环和跳过循环</strong>两种情况。</li>
</ul>
<h4 id="测试用例数估算"><a href="#测试用例数估算" class="headerlink" title="测试用例数估算"></a>测试用例数估算</h4><p>为简化问题，避免出现测试用例极多的组合爆炸，把构成循环操作的重复型结构用选择结构代替。即<em>不指望测试循环体所有的重复执行，而是只对循环体检验一次。</em></p>
<ul>
<li>顺序型——构成串行操作</li>
<li>选择型——构成分支操作</li>
<li>重复型——构成循环操作<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401102042346.png"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401102042937.png"></li>
</ul>
<h4 id="白盒测试路径覆盖习题"><a href="#白盒测试路径覆盖习题" class="headerlink" title="白盒测试路径覆盖习题"></a>白盒测试路径覆盖习题</h4><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401102043249.png"></p>
<!-- TODO -->

<h3 id="程序插桩和变异测试"><a href="#程序插桩和变异测试" class="headerlink" title="程序插桩和变异测试"></a>程序插桩和变异测试</h3><p>两类主要的程序修改方法</p>
<ul>
<li>程序插桩: 获得程序执行过程中的内部状态信息</li>
<li>程序变异: 度量测试用例的缺陷检测能力</li>
</ul>
<p>程序插桩原则：用尽可能少的插桩点完成尽量多的信息收集工作。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401102045551.png"></p>
<p>变异程序：一般用与源程序差异极小的简单变体模拟程序中可能存在的各种缺陷。<br>两个重要假设：</p>
<ul>
<li>熟练程序员假设：开发人员编程水平高，编写的代码即使包含缺陷，也仅需微小修改</li>
<li>变异偶尔效应假设：测试用例能够杀死简单变异体，也容易杀死复杂变异体</li>
</ul>
<p>变异体杀死：</p>
<ul>
<li>源程序与变异程序存在运行差异时，测试用例检测到变异程序中缺陷，变异程序被杀死</li>
<li>两个程序不存在运行差异时，测试用例没有检测到变异程序的缺陷，变异程序存活</li>
</ul>
<p>变异算子：</p>
<ul>
<li>模拟典型软件缺陷，度量测试用例对常见缺陷的检测能力</li>
<li>引入特殊值，度量测试用例在特殊环境下的缺陷检测能力</li>
</ul>
<p>面向过程程序的变异算子：</p>
<ul>
<li>运算符变异</li>
<li><ul>
<li>对关系运算符&lt;、&lt;&#x3D;, &gt;, &gt;&#x3D; 进行替换，将&lt; 替换为 &lt;&#x3D;</li>
</ul>
</li>
<li><ul>
<li>对自增运算符++或—运算符进行替换，如将++替换为–</li>
</ul>
</li>
<li><ul>
<li>对与数值运算有关的二元算数运算符进行替换，如将+替换为-</li>
</ul>
</li>
<li><ul>
<li>将程序中的条件运算符替换为相反运算符，如将 &#x3D;&#x3D; 替换为 !&#x3D;</li>
</ul>
</li>
<li>数值变异：对程序中的整数类型、浮点数类型的变量取反数，如将i 替换为 -i</li>
<li>方法返回值变异</li>
<li><ul>
<li>删除程序中返回值类型为void的方法</li>
</ul>
</li>
<li><ul>
<li>对程序中方法的返回值进行修改，如将true修改为false</li>
</ul>
</li>
</ul>
<p>面向对象程序的变异算子：</p>
<ul>
<li>继承变异</li>
<li><ul>
<li>增加或删除子类中的重写变量</li>
</ul>
</li>
<li><ul>
<li>增加、修改或重命名子类中的重写方法</li>
</ul>
</li>
<li><ul>
<li>删除子类中的关键字super，如将return a<em>super.b 修改为return a</em>b</li>
</ul>
</li>
<li>多态变异</li>
<li><ul>
<li>将变量实例化为子类型</li>
</ul>
</li>
<li><ul>
<li>将变量声明、形参类型改为父类型，如将 Integer i 修改为Object I</li>
</ul>
</li>
<li><ul>
<li>赋值时将使用的变量替换为其他可用类型</li>
</ul>
</li>
<li>重载变异</li>
<li><ul>
<li>修改重载方法的内容，或删除重载方法</li>
</ul>
</li>
<li><ul>
<li>修改方法参数的顺序或数量</li>
</ul>
</li>
</ul>
<p>变异程序运行结束后，仍存活，为<strong>等价变异程序</strong>。<br>变异得分 &#x3D; 被杀死的变异程序 &#x2F; （变异程序总数 - 等价变异程序数）</p>
<h4 id="变异测试习题"><a href="#变异测试习题" class="headerlink" title="变异测试习题"></a>变异测试习题</h4><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401102110010.png"></p>
<!-- TODO -->

<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><ul>
<li>定义：单元测试是对软件基本的组成单元进行独立的测试</li>
<li>时机：单元测试和编码是同步进行，但在测试驱动开发（Test driven development, TDD）中，强调测试在先，编码在后</li>
<li>人员：单元测试一般由开发人员完成, QA人员辅助</li>
<li>概念：模块、组件、单元</li>
<li>目标：单元模块被正确编码</li>
<li><ul>
<li>信息正确地流入和流出单元</li>
</ul>
</li>
<li><ul>
<li>在单元工作过程中，其内部数据保持其完整性</li>
</ul>
</li>
<li><ul>
<li>为限制数据加工而设置的边界处正确工作</li>
</ul>
</li>
<li><ul>
<li>单元的运行做到满足特定的逻辑覆盖</li>
</ul>
</li>
<li>任务：</li>
<li><ul>
<li>模块独立执行路径测试</li>
</ul>
</li>
<li><ul>
<li>局部数据结构测试</li>
</ul>
</li>
<li><ul>
<li>模块接口测试</li>
</ul>
</li>
<li><ul>
<li>单元边界条件测试</li>
</ul>
</li>
<li><ul>
<li>单元容错测试&#x2F;错误处理</li>
</ul>
</li>
<li><ul>
<li>表达式与SQL语句</li>
</ul>
</li>
</ul>
<p>单元测试最重要的手段——静态测试：不运行被测试程序，对代码通过检查、阅读进行分析。</p>
<p>运行单元程序有时需要基于被测单元的接口，开发相应的驱动模块和桩模块。</p>
<ul>
<li><p>驱动模块（drive）： 对<strong>底层或子层模块</strong>进行测试所编写的<strong>调用</strong>这些模块的程序</p>
</li>
<li><p>桩模块（stub）：对<strong>顶层或上层模块</strong>进行测试时所编写的<strong>替代下层模块</strong>的程序<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401102116532.png"></p>
</li>
<li><p>传统单元测试：针对程序的函数、过程或完成某一特定功能的程序块。</p>
</li>
<li><p>面向对象软件的单元测试：测试类成员函数。数据成员是否满足数据封装的要求？类是否实现了要求的功能？</p>
</li>
</ul>
<p>父类中已经测试过的成员函数，两种情况需要在子类中重新测试:</p>
<ul>
<li>继承的成员函数在子类中做了改动</li>
<li>成员函数调用了改动过的成员函数的部分</li>
</ul>
<p>对包含多态的成员函数进行测试时，只在原有测试分析和基础上增加对<strong>测试用例中输入数据类型</strong>的考虑</p>
<h3 id="面向对象的单元测试习题"><a href="#面向对象的单元测试习题" class="headerlink" title="面向对象的单元测试习题"></a>面向对象的单元测试习题</h3><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401102121701.png"></p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401102121487.png"></p>
<h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><ul>
<li>定义：根据实际情况将程序模块采用适当的集成测试策略组装起来，对<strong>模块之间的接口以及集成后的功能等</strong>进行正确性检验的测试工作。</li>
<li>时机：确保测试对象所包含的程序模块全部通过单元测试</li>
<li>缺陷类型：接口缺陷、数据丢失、误差放大、规格问题、并发问题</li>
</ul>
<p>组件之间存在显式&#x2F;隐形相依性，需通过结构分析、接口分析、模块分析获取相依性关系。</p>
<p>集成测试模式：</p>
<ul>
<li><strong>非渐增式测试模式</strong>先分别测试每个模块，再把所有模块按设计要求放在一起结合成所要的程序，如大棒模式。</li>
<li><ul>
<li>很难确定出错的真正位置、所在的模块、错误的原因，并不推荐在任何系统中使用，适合在规模较小的应用系统中使用。</li>
</ul>
</li>
<li><ul>
<li><strong>可以并行测试</strong></li>
</ul>
</li>
<li><strong>渐增式测试模式</strong>把下一个要测试的模块同已经测试好的模块结合起来进行测试，测试完以后再把下一个应该测试的模块结合进来测试，如自顶向下和自底向上</li>
<li><ul>
<li>测试更彻底</li>
</ul>
</li>
<li><ul>
<li>需要较多的机器时间</li>
</ul>
</li>
</ul>
<p>自顶向下法（Top-down Integration）步骤：</p>
<ol>
<li>对<strong>主控模块</strong>进行测试，测试时用<strong>桩程序</strong>代替所有直接附属于主控模块的模块</li>
<li>根据<strong>选定的结合策略</strong>（深度优先&#x2F;宽度优先），<strong>每次用一个实际模块代替一个桩程序</strong>（新结合进来的模块往往又需要桩程序）</li>
<li>在结合下一个模块的同时进行测试</li>
<li>为了保证加入模块没有引进新的错误，可能需要进行<strong>回归测试</strong>。</li>
</ol>
<p>自底向上法步骤：</p>
<ol>
<li>把底层模块组合成实现某个特定的软件子功能的族</li>
<li>写一个驱动程序（用于测试的控制程序），协调测试数据的输入和输出</li>
<li>对由模块组成的子功能进行测试</li>
<li>去掉驱动程序，沿软件结构自下向上移动，把子功能族结合起来形成更大的子功能族（Cluster）</li>
</ol>
<p>三明治集成方法(Sandwich Integration)：</p>
<ul>
<li>优点：将自顶向下和自底向上的集成方法有机地结合起来，不需要写桩程序。因为在测试初自底向上集成已经验证了底层模块的正确性。</li>
<li>缺点：在真正集成之前（中层）每一个独立的模块没有完全测试过。</li>
<li>改进的三明治集成方法，不仅自两头向中间集成，而且保证每个模块得到单独的测试，使测试进行得比较彻底 。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401102128113.png"></li>
</ul>
<p>基于调用图的集成：较少所需的驱动模块和测试桩模块，有效地减少集成测试的工作量。<br>构建程序调用图 → 识别各个模块间的程序调用关系<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401102129362.png"></p>
<p>持续集成：通常系统集成都会采用持续集成的策略，软件开发中各个模块不是同时完成，根据进度将完成的模块尽可能早的进行集成，有助于尽早发现Bug，避免集成中大量Bug涌现</p>
<ul>
<li>传统集成测试：自顶向下和自底向上</li>
<li>面向对象软件的集成测试</li>
<li><ul>
<li>没有层次的控制结构</li>
</ul>
</li>
<li><ul>
<li>OO程序相互调用的功能在程序的不同类中，类之间相互依赖紧密</li>
</ul>
</li>
<li><ul>
<li>集成测试在<strong>整个程序编译完成后</strong>进行</li>
</ul>
</li>
<li><ul>
<li><strong>基于使用的测试</strong>：先测试独立类构造系统，完成后测试下一层，测试使用了独立类的类（依赖类）</li>
</ul>
</li>
</ul>
<h3 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h3><h4 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h4><ul>
<li>单元功能测试：保证所测试的每个独立的模块的功能正确，从输入条件和输出结果来判断是否满足程序的设计要求</li>
<li>系统功能测试：</li>
<li><ul>
<li>考虑模块间的相互作用，考虑系统的应用环境</li>
</ul>
</li>
<li><ul>
<li>衡量标准是实现产品规格说明书上所要求的功能</li>
</ul>
</li>
<li><ul>
<li>特别地，模拟用户从头到尾（End-to-End,端到端）的业务测试，确保系统可以完成实现设计的功能，满足用户实际业务需求<br>功能测试的整体思路：需求 -&gt; 测试用例。客户需求为导向，全面理解功能特性。</li>
</ul>
</li>
</ul>
<h4 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h4><ul>
<li>一旦程序某些区域被修改了，就可能影响其它区域，导致受影响的区域出现新的缺陷（<strong>回归缺陷</strong>）。</li>
<li>回归测试是为了<strong>发现回归缺陷</strong>而进行的测试。</li>
<li><strong>定义</strong>：对软件的新版本测试时，重复执行上一个版本测试时的用例。</li>
<li>回归测试可以在任何测试阶段进行。既有黑盒测试的回归，也有白盒测试的回归。</li>
</ul>
<h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h4><p>性能测试：是为了发现系统性能问题或获取系统性能相关指标而进行的测试。一般在真实环境、特定负载（正常或峰值）条件下，通过工具模拟实际软件系统的运行及其操作，同时监控性能各项指标，最后对测试结果进行分析来确定系统的性能状况。<br><em>性能测试用来保证产品发布后系统的性能能够满足用户需求</em></p>
<p>性能测试目标：</p>
<ul>
<li>获取系统性能某些指标数据</li>
<li>为了<strong>验证</strong>系统是否达到用户提出的性能指标</li>
<li>发现系统中存在的<strong>性能瓶颈</strong>，优化系统的性能</li>
</ul>
<p>性能测试类型：</p>
<ul>
<li>性能规划测试</li>
<li>性能基准测试</li>
<li>容量测试</li>
<li>性能验证测试</li>
</ul>
<p>产品生命周期中的性能要点：</p>
<ul>
<li>需求分析中充分关注负载压力性能</li>
<li>在设计中得到负载压力性能指标</li>
<li>开发阶段创建负载压力性能测试环境</li>
<li>验收阶段在多等级范围内测试并调优</li>
<li>运行阶段持续监控系统负载压力性能</li>
</ul>
<p>不同角度的关注点：</p>
<ul>
<li>响应时间是用户的关注点；</li>
<li>容量和数据吞吐量是（产品市场团队）业务处理方面的关注点；</li>
<li>而系统资源占用率是开发团队的技术关注点。</li>
</ul>
<p>性能的具体指标：</p>
<ul>
<li>数据传输的吞吐量（Transactions）</li>
<li>数据处理效率（Transactions per second）</li>
<li>数据请求的响应时间（Response time）</li>
<li>内存和CPU使用率</li>
</ul>
<p>80～20原理：每个工作日80％的业务在20％的时间内完成。</p>
<p>负载压力测试：在一定约束条件下测试系统所能承受的并发用户量、运行时间、数据量，以确定系统能承受的最大负载压力。<br>在一种需要反常（如长时间的峰值）数量、频率或资源的方式下，执行可重复的负载测试，以检查程序对异常情况的抵抗能力，找出<strong>性能瓶颈</strong>或其它<strong>不稳定性问题</strong>。</p>
<p>并发性能测试：<strong>逐渐增加并发用户数</strong>负载，直到系统出现性能瓶颈或者崩溃（不能接受的性能点）为止。通过综合分析交易执行指标、资源监控指标来确定系统并发性能的过程。<strong>并发性能是负载压力测试的重要内容。</strong></p>
<ul>
<li>负载测试：通过逐步增加系统负载，测试系统性能的变化，并最终确定<strong>在满足性能指标的情况下</strong>，系统能承受的<strong>最大负载量</strong>的测试。</li>
<li>压力测试：通过逐步增加系统负载，测试系统性能的变化，并最终确定在什么负载条件下系统性能处于<strong>失效状态</strong>，并以此来获得<strong>系统能提供的最大服务级别</strong>的测试。压力测试是为了发现在什么条件下系统的性能会变得不可接受。</li>
</ul>
<h4 id="其他非功能性测试"><a href="#其他非功能性测试" class="headerlink" title="其他非功能性测试"></a>其他非功能性测试</h4><h5 id="安全性测试"><a href="#安全性测试" class="headerlink" title="安全性测试"></a>安全性测试</h5><p>安全性：使伤害或损害的风险限制在可接受的水平内<br>软件安全性测试：检验系统权限设置有效性、防范非法入侵的能力、数据备份和恢复能力等，设法找出各种安全性漏洞<br><strong>系统安全设计的准则</strong>：使非法侵入的代价超过被保护信息的价值</p>
<p>安全性测试：</p>
<ul>
<li>软件不做它不应该做的事, 应用输入验证, 没有不安全的事情发生</li>
<li>在测试软件系统中对危险防止和危险处理设施进行的测试，以验证其是否有效</li>
<li>安全性缺陷常常由软件的副作用引起，即软件应当做A，它<em>做了A的同时，又做了B</em></li>
</ul>
<p>安全性测试方法：</p>
<ul>
<li>基于漏洞的方法，从软件内部考虑其安全性，识别软件的安全漏洞。如借助于特定的漏洞扫描器。</li>
<li>基于威胁的方法，从软件外部考察其安全性，识别软件面临的安全威胁并测试其是否能够发生</li>
<li>模拟攻击测试是一组特殊的 、极端的测试方法，如Fuzzing，使用大量半有效的数据作为应用程序的输入，以程序是否出现异常为标志，来发现应用程序中可能存在的安全漏洞</li>
</ul>
<h5 id="可靠性和容错性测试"><a href="#可靠性和容错性测试" class="headerlink" title="可靠性和容错性测试"></a>可靠性和容错性测试</h5><p>可靠性（Reliability）是产品在<strong>规定的条件下和规定的时间内完成规定功能的能力</strong>。软件可靠性与软件缺陷有关，也与系统输入和系统使用有关。理论上说，可靠的软件系统应该是正确、完整、一致和健壮的。</p>
<p><strong>成熟性度量</strong>可以通过错误发现率DDP（Defect Detection Percentage）来表现。在测试中查找出来的错误越多，实际应用中出错的机会就越小，软件也就越成熟。</p>
<p>容错性测试（Fault-tolrent test）是检查软件在异常条件下自身是否具有<strong>防护性的措施</strong>或者某种<strong>灾难性恢复</strong>的手段。</p>
<ul>
<li>输入异常数据或进行异常操作，以检验系统的保护性。如果系统的容错性好的话，系统只给出提示或内部消化掉，而不会导致系统出错甚至崩溃。</li>
<li>灾难恢复性测试。通过各种手段，让软件强制性地发生故障，然后验证系统已保存的用户数据是否丢失、系统和数据是否能尽快恢复。</li>
</ul>
<h5 id="兼容性测试"><a href="#兼容性测试" class="headerlink" title="兼容性测试"></a>兼容性测试</h5><p>兼容性测试: 验证软件之间是否正确地交互和共享信息<br>需要对所有可能的软件组合等价分配，验证软件之间正确交互的最小有效集合。</p>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>university</tag>
        <tag>software-test</tag>
      </tags>
  </entry>
  <entry>
    <title>教程其二之git</title>
    <url>/2023/08/04/tutorial-git/</url>
    <content><![CDATA[<h2 id="开源为王-git安装与github初入门"><a href="#开源为王-git安装与github初入门" class="headerlink" title="开源为王- git安装与github初入门"></a>开源为王- git安装与github初入门</h2><p>“开源（open source）”——人人可审查、修改与增强，可以从这篇文章稍作了解<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNzUwMTA3MA==">什么是开源？<i class="fa fa-external-link-alt"></i></span>。<br>至于git——世界上<strong>目前最先进</strong>的分布式版本控制系统，详见廖雪峰大佬的<span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvODk2MDQzNDg4MDI5NjAw">Git教程<i class="fa fa-external-link-alt"></i></span>。</p>
<p>以下内容不对其上概念和重要性做过多阐述，请自行选择阅读上述文章，以下仅从安装配置讨论。</p>
<span id="more"></span>

<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Windows 上安装方法有几种，对于新手推荐以下两种。</p>
<h4 id="官网安装"><a href="#官网安装" class="headerlink" title="官网安装"></a>官网安装</h4><p>官网下载地址（通过科学上网访问）：<span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9kb3dubG9hZC93aW4=">https://git-scm.com/download/win<i class="fa fa-external-link-alt"></i></span><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308041758468.png"></p>
<blockquote>
<p>小提示：如果你对你的英语水平不自信，edge&#x2F;chrome浏览器可以安装<code>沉浸式翻译</code>插件。<br>官网安装的详细步骤详见<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L211a2VzL2FydGljbGUvZGV0YWlscy8xMTU2OTM4MzM=">Git详细安装教程<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h4 id="Github-Desktop-安装"><a href="#Github-Desktop-安装" class="headerlink" title="Github Desktop 安装"></a>Github Desktop 安装</h4><p>该安装程序包含图形化和命令行版本的 Git。它也能支持 Powershell，提供了稳定的凭证缓存和健全的换行设置。前往 Github for Windows 网站下载，网址为<span class="exturl" data-url="aHR0cHM6Ly9kZXNrdG9wLmdpdGh1Yi5jb20v">https://desktop.github.com/<i class="fa fa-external-link-alt"></i></span>。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>打开 Git Bash ，命令行界面如下：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308041813146.png"></p>
<p>配置用户名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;username&quot;</span> // 将<span class="string">&quot;username&quot;</span>替换为你的账户名</span><br></pre></td></tr></table></figure>
<p>邮箱：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.email <span class="string">&quot;user@email.com&quot;</span> // 将<span class="string">&quot;user@email.com&quot;</span>替换为你的邮箱</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果你不清楚为什么要配置用户名和邮箱，请重新阅读<span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvODk2MDQzNDg4MDI5NjAw">Git教程<i class="fa fa-external-link-alt"></i></span>并找到相关部分。</p>
</blockquote>
<p>以上命令执行完毕后，可以用如下命令查看配置是否正确。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308041817797.png"></p>
<p>确认完毕后，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>
<p>此时有三个配置问题，第一次使用保持默认配置即可，<strong>请连按三次回车键</strong>。<br>结束后你可以看到两个目录地址，如你保持默认配置则前往系统盘目录<code>C:\Users(用户)\&quot;username&quot;\.ssh</code>文件夹查看 ssh 文件是否生成成功，分别为<code>id_rsa</code>和<code>id_rsa.pub</code>。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308041826736.png"></p>
<p>此时 git 的配置暂时告一段落，让我们将目光转向 github ，世界上最大的开源仓库平台。</p>
<h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>如果你对注册账号的流程抱有疑问，请查看<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MTY1OTQ1MjA=">注册Github账号详细教程<i class="fa fa-external-link-alt"></i></span>，本博客不再详述。</p>
<blockquote>
<p>如若可以，建议用非 qq 邮箱注册，出于 qq 号可能被封禁考虑。</p>
</blockquote>
<p>你的 github 主页如下：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308041832965.png"></p>
<h3 id="绑定-git"><a href="#绑定-git" class="headerlink" title="绑定 git"></a>绑定 git</h3><p>点击右上角你的头像，选择<code>Settings</code>：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308041833037.png"></p>
<p>于左侧<code>Access</code>下选择<code>SSH and GPG keys</code>：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308041835639.png"></p>
<p>点击<code>New SSH Key</code>：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308041840544.png"></p>
<p>title随意取好，个人建议为<code>你的电脑型号-Windows</code>（如<code>ThinkBook16p-Windows</code>），方便日后管理不同电脑&#x2F;虚拟机&#x2F;系统的 git 密钥。 Key Type 保持不变为<code>Authentication Key</code>。将<strong>公钥（<code>id_rsa.pub</code>）</strong>文件中的内容用 vscode 打开后复制粘贴到key中，然后点击<code>Add SSH key</code>即可。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308041841111.png">。</p>
<blockquote>
<p>如果你对 SSH 公钥与私钥之分很感兴趣，可以阅读<span class="exturl" data-url="aHR0cHM6Ly9zb25nbGVlMjQuZ2l0aHViLmlvLzIwMTUvMDUvMDMvcHVibGljLWtleS1hbmQtcHJpdmF0ZS1rZXkv">理解公钥与私钥<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>测试一下你的配置是否成功，在 Git Bash 终端中输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308041848555.png"><br>看到如上字样则你的 github 与 git 已经配置成功。欢迎来到开源世界！</p>
]]></content>
      <categories>
        <category>recruitment</category>
      </categories>
      <tags>
        <tag>software-engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>教程其四之编码风格</title>
    <url>/2023/08/23/tutorial-style-guide/</url>
    <content><![CDATA[<h2 id="google-编码风格"><a href="#google-编码风格" class="headerlink" title="google 编码风格"></a>google 编码风格</h2><blockquote class="blockquote-center">
<p>干净的代码既简单又直接。干净的代码读起来像写得很好的散文。简洁的代码永远不会掩盖设计者的意图，而是充满清晰的抽象和直接的控制线。</p>

</blockquote>

<p><strong>style guide</strong>，编码规范，又称风格指南。每个较大的开源项目都有自己的风格指南：关于如何为该项目编写代码的一系列规定（有时候会比较武断）。当所有代码均保持一致的风格时，在理解大型代码库时更为轻松。</p>
<span id="more"></span>

<p>为什么要遵循编码规范？</p>
<ol>
<li>代码更加干净整洁</li>
<li>代码质量更高</li>
<li>提升代码的可读性</li>
<li>使后续维护更加容易</li>
</ol>
<p>如今大型软件系统之代码量，早已不是一人之力可以完成，需借助团队的力量。此时就显现出编码规范的重要之处。虽然初期为了适应编码规范需要额外的时间、降低了工作效率，但和日后维护的收益比起来，这些阵痛不值一提。</p>
<p>本篇教程我们主要介绍 Google 开源项目的 HTML&#x2F;CSS 风格指南的部分内容，同时有一些常用规范（如命名约定，函数约定）。如感兴趣可前往文末链接查看完整内容，本教程大部分引用其中。</p>
<p>请注意，我们不鼓励背诵以下内容。快速阅读，按需查找。</p>
<h3 id="先导内容"><a href="#先导内容" class="headerlink" title="先导内容"></a>先导内容</h3><h4 id="常用编程命名规范"><a href="#常用编程命名规范" class="headerlink" title="常用编程命名规范"></a>常用编程命名规范</h4><h5 id="驼峰式命名法-camel-case"><a href="#驼峰式命名法-camel-case" class="headerlink" title="驼峰式命名法(camel case)"></a>驼峰式命名法(camel case)</h5><p>第一个单词首字母小写，后面其他单词首字母大写。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> myAge;</span><br><span class="line"><span class="type">char</span> myName[<span class="number">10</span>];</span><br><span class="line"><span class="type">float</span> myHeight;</span><br></pre></td></tr></table></figure>

<h5 id="帕斯卡命名法（upper-camel-case）"><a href="#帕斯卡命名法（upper-camel-case）" class="headerlink" title="帕斯卡命名法（upper camel case）"></a>帕斯卡命名法（upper camel case）</h5><p>所有单词首字母大写。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> MyAge;</span><br><span class="line"><span class="type">char</span> MyName;</span><br><span class="line"><span class="type">float</span> MyHeight;</span><br></pre></td></tr></table></figure>

<h5 id="下划线命名法"><a href="#下划线命名法" class="headerlink" title="下划线命名法"></a>下划线命名法</h5><p>用下划线连接单词。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> my_age;</span><br><span class="line"><span class="type">char</span> my_name[<span class="number">10</span>]；</span><br><span class="line"><span class="type">float</span> my_height;</span><br></pre></td></tr></table></figure>

<h2 id="常用风格指南"><a href="#常用风格指南" class="headerlink" title="常用风格指南"></a>常用风格指南</h2><h3 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h3><p>最重要的一致性规则是命名管理. 命名的风格能让我们在不需要去查找类型声明的条件下快速地了解某个名字代表的含义: 类型, 变量, 函数, 常量, 宏, 等等, 甚至. 我们大脑中的模式匹配引擎非常依赖这些命名规则.</p>
<p>命名规则具有一定随意性, 但相比按个人喜好命名, 一致性更重要, 所以无论你认为它们是否重要, 规则总归是规则.</p>
<h4 id="通用命名规则"><a href="#通用命名规则" class="headerlink" title="通用命名规则"></a>通用命名规则</h4><h5 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h5><p>函数命名, 变量命名, 文件命名要有描述性; 少用缩写。</p>
<h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><p>尽可能使用描述性的命名, 别心疼空间, 毕竟相比之下让代码易于新读者理解更重要. 不要用只有项目开发者能理解的缩写, 也不要通过砍掉几个字母来缩写单词。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> price_count_reader;    <span class="comment">// 无缩写</span></span><br><span class="line"><span class="type">int</span> num_errors;            <span class="comment">// &quot;num&quot; 是一个常见的写法</span></span><br><span class="line"><span class="type">int</span> num_dns_connections;   <span class="comment">// 人人都知道 &quot;DNS&quot; 是什么</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;                     <span class="comment">// 毫无意义.</span></span><br><span class="line"><span class="type">int</span> nerr;                  <span class="comment">// 含糊不清的缩写.</span></span><br><span class="line"><span class="type">int</span> n_comp_conns;          <span class="comment">// 含糊不清的缩写.</span></span><br><span class="line"><span class="type">int</span> wgc_connections;       <span class="comment">// 只有贵团队知道是什么意思.</span></span><br><span class="line"><span class="type">int</span> pc_reader;             <span class="comment">// &quot;pc&quot; 有太多可能的解释了.</span></span><br><span class="line"><span class="type">int</span> cstmr_id;              <span class="comment">// 删减了若干字母.</span></span><br></pre></td></tr></table></figure>

<p>注意, 一些特定的广为人知的缩写是允许的, 例如用 <code>i</code> 表示迭代变量和用 <code>T</code> 表示模板参数。</p>
<p>模板参数的命名应当遵循对应的分类: 类型模板参数应当遵循<strong>类型命名</strong>的规则, 而非类型模板应当遵循<strong>变量命名</strong>的规则。</p>
<h4 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h4><h5 id="总述-1"><a href="#总述-1" class="headerlink" title="总述"></a>总述</h5><p>文件名要全部小写, 可以包含下划线 (<code>_</code>) 或连字符 (<code>-</code>), 依照项目的约定. 如果没有约定, 那么 “<code>_</code>” 更好。</p>
<h5 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h5><p>可接受的文件命名实例：</p>
<ul>
<li><code>my_useful_class.cc</code></li>
<li><code>my-useful-class.cc</code></li>
<li><code>myusefulclass.cc</code></li>
</ul>
<p>通常应尽量让文件名更加明确.<code> http_server_logs.h</code> 就比 <code>logs.h</code> 要好。</p>
<h4 id="类型命名"><a href="#类型命名" class="headerlink" title="类型命名"></a>类型命名</h4><blockquote>
<p>如果你还不知道什么是类型，大可以跳过此小节，但我依然建议大致看一下。</p>
</blockquote>
<h5 id="总述-2"><a href="#总述-2" class="headerlink" title="总述"></a>总述</h5><p>类型名称的每个单词首字母均大写, 不包含下划线:<code>MyExcitingClass</code>，<code>MyExcitingEnum</code>。</p>
<h5 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h5><p>所有类型命名 —— 类, 结构体, 类型定义 (<code>typedef</code>), 枚举, 类型模板参数 —— 均使用相同约定, 即以大写字母开始, 每个单词首字母均大写, 不包含下划线. 例如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类和结构体</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UrlTable</span> &#123; ...</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UrlTableTester</span> &#123; ...</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UrlTableProperties</span> &#123; ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// using 别名</span></span><br><span class="line"><span class="keyword">using</span> PropertiesMap = hash_map&lt;UrlTableProperties *, string&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">UrlTableErrors</span> &#123; ...</span><br></pre></td></tr></table></figure>

<h4 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h4><h5 id="总述-3"><a href="#总述-3" class="headerlink" title="总述"></a>总述</h5><p>变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 但结构体的就不用, 如: <code>a_local_variable</code>, <code>a_struct_data_member</code>, <code>a_class_data_member_</code>。</p>
<h5 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h5><h6 id="普通变量命名"><a href="#普通变量命名" class="headerlink" title="普通变量命名"></a>普通变量命名</h6><p>举例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string table_name;  <span class="comment">// 好 - 用下划线.</span></span><br><span class="line">string tablename;   <span class="comment">// 好 - 全小写.</span></span><br><span class="line"></span><br><span class="line">string tableName;  <span class="comment">// 差 - 混合大小写</span></span><br></pre></td></tr></table></figure>

<h6 id="类数据成员"><a href="#类数据成员" class="headerlink" title="类数据成员"></a>类数据成员</h6><p>不管是静态的还是非静态的, 类数据成员都可以和普通变量一样, 但要接下划线。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TableInfo</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  string table_name_;  <span class="comment">// 好 - 后加下划线.</span></span><br><span class="line">  string tablename_;   <span class="comment">// 好.</span></span><br><span class="line">  <span class="type">static</span> Pool&lt;TableInfo&gt;* pool_;  <span class="comment">// 好.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="结构体变量"><a href="#结构体变量" class="headerlink" title="结构体变量"></a>结构体变量</h6><p>不管是静态的还是非静态的, 结构体数据成员都可以和普通变量一样, 不用像类那样接下划线:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">UrlTableProperties</span> &#123;</span><br><span class="line">  string name;</span><br><span class="line">  <span class="type">int</span> num_entries;</span><br><span class="line">  <span class="type">static</span> Pool&lt;UrlTableProperties&gt;* pool;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a>常量命名</h4><h5 id="总述-4"><a href="#总述-4" class="headerlink" title="总述"></a>总述</h5><p>声明为 <code>constexpr</code> 或 <code>const</code> 的变量, 或在程序运行期间其值始终保持不变的, 命名时以 “k” 开头, 大小写混合. 例如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> kDaysInAWeek = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>

<h5 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h5><p>所有具有静态存储类型的变量 (例如静态变量或全局变量, 参见 <strong>存储类型</strong>) 都应当以此方式命名. 对于其他存储类型的变量, 如自动变量等, 这条规则是可选的. 如果不采用这条规则, 就按照一般的变量命名规则。</p>
<h4 id="函数命名"><a href="#函数命名" class="headerlink" title="函数命名"></a>函数命名</h4><h5 id="总述-5"><a href="#总述-5" class="headerlink" title="总述"></a>总述</h5><p>常规函数使用大小写混合, 取值和设值函数则要求与变量名匹配: <code>MyExcitingFunction()</code>, <code>MyExcitingMethod()</code>, <code>my_exciting_member_variable()</code>, <code>set_my_exciting_member_variable()</code></p>
<h5 id="说明-5"><a href="#说明-5" class="headerlink" title="说明"></a>说明</h5><p>一般来说, 函数名的每个单词首字母大写 (即 “驼峰变量名” 或 “帕斯卡变量名”), 没有下划线. 对于首字母缩写的单词, 更倾向于将它们视作一个单词进行首字母大写 (例如, 写作 <code>StartRpc()</code> 而非 <code>StartRPC()</code>)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">AddTableEntry</span>()</span><br><span class="line"><span class="built_in">DeleteUrl</span>()</span><br><span class="line"><span class="built_in">OpenFileOrDie</span>()</span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h4><h5 id="说明-6"><a href="#说明-6" class="headerlink" title="说明"></a>说明</h5><p>在排序函数参数时，将所有输入参数放在所有输出参数之前. 特别要注意, 在加入新参数时不要因为它们是新参数就置于参数列表最后, 而是仍然要按照前述的规则, 即将新的输入参数也置于输出参数之前。</p>
<h4 id="编写简短函数"><a href="#编写简短函数" class="headerlink" title="编写简短函数"></a>编写简短函数</h4><h5 id="总述-6"><a href="#总述-6" class="headerlink" title="总述"></a>总述</h5><p>我们倾向于编写简短, 凝练的函数。</p>
<h5 id="说明-7"><a href="#说明-7" class="headerlink" title="说明"></a>说明</h5><p>我们承认长函数有时是合理的, 因此并不硬性限制函数的长度. 如果函数超过 40 行, 可以思索一下能不能在不影响程序结构的前提下对其进行分割。</p>
<p>即使一个长函数现在工作的非常好, 一旦有人对其修改, 有可能出现新的问题, 甚至导致难以发现的 bug. 使函数尽量简短, 以便于他人阅读和修改代码。</p>
<p>在处理代码时, 你可能会发现复杂的长函数. 不要害怕修改现有代码: 如果证实这些代码使用 &#x2F; 调试起来很困难, 或者你只需要使用其中的一小段代码, 考虑将其分割为更加简短并易于管理的若干函数。</p>
<h2 id="HTML-x2F-CSS-风格指南"><a href="#HTML-x2F-CSS-风格指南" class="headerlink" title="HTML&#x2F;CSS 风格指南"></a>HTML&#x2F;CSS 风格指南</h2><h3 id="总体排版规则"><a href="#总体排版规则" class="headerlink" title="总体排版规则"></a>总体排版规则</h3><h4 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h4><p>每次缩进使用两个空格。不使用<code>TAB</code>键或混合使用<code>TAB</code>键和空格进行缩进。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Fantastic</span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Great</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.example</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="整体的元数据规则"><a href="#整体的元数据规则" class="headerlink" title="整体的元数据规则"></a>整体的元数据规则</h3><h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p>使用<strong>UTF-8</strong>无BOM编码。</p>
<p>在 HTML 模板和文档中使用<code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>指定编码。不需要为样式表（css）指定编码，它默认是 UTF-8 。</p>
<blockquote>
<p>想要了解关于编码的知识，可查阅<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMzc4NzU2MTU=">unicode 编码简介<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>在需要时尽可能去解释你的代码，包括它的应用范围、用途、此方案的选择理由等。</p>
<h4 id="处理内容"><a href="#处理内容" class="headerlink" title="处理内容"></a>处理内容</h4><p>用 <strong>TODO</strong> 标记待办事宜和处理内容。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;# TODO(john.doe): 重新处理水平居中 #&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- <span class="doctag">TODO:</span> 移除可选的标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Apples<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Oranges<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="HTML-样式规则"><a href="#HTML-样式规则" class="headerlink" title="HTML 样式规则"></a>HTML 样式规则</h3><h4 id="文档类型"><a href="#文档类型" class="headerlink" title="文档类型"></a>文档类型</h4><p>使用 HTML5 。HTML5 是所有 HTML 文档的首选： <code>&lt;!DOCTYPE html&gt;</code> 。</p>
<h4 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a>语义化</h4><p>根据 HTML 的目的使用它。</p>
<p>根据元素（有时被错误的叫做“标签”）被创造的用途使用他们。比如，对标题使用标题元素，对段落使用<code>p</code>元素，对锚点使用<code>a</code>元素等。</p>
<p>语义化的使用HTML对于可访问性、复用性和代码的高效性等因素非常重要。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 不推荐 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;goToRecommendations();&quot;</span>&gt;</span>All recommendations<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 推荐 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;recommendations/&quot;</span>&gt;</span>All recommendations<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="多媒体降级"><a href="#多媒体降级" class="headerlink" title="多媒体降级"></a>多媒体降级</h4><p>为多媒体提供替代内容。</p>
<p>对于图片、视频、通过 <code>canvas</code> 实现的动画等多媒体来说，确保提供可访问的替代内容。对于图片，可提供有意义的替代文本（ <code>alt</code> ）；对于视频和音频，如有条件可提供对白和字幕。</p>
<p>提供替代内容对辅助功能很重要：没有 <code>alt</code> ，一位盲人用户很难知道一张图片的内容，其他用户可能不能了解视频和音频的内容。 （对于 <code>alt</code> 属性会引起冗余的图片和你不打算添加CSS的纯粹装饰性的图片，不用添加替代文本，写成 <code>alt=&quot;&quot;</code> 即可。）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 不推荐 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;spreadsheet.png&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 推荐 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;spreadsheet.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Spreadsheet screenshot.&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="关注点分离"><a href="#关注点分离" class="headerlink" title="关注点分离"></a>关注点分离</h4><p><strong>将结构、表现、行为分离。</strong></p>
<p>严格保持结构（标识），表现（样式），行为（脚本）分离，尽量使三者之间的相互影响最小。</p>
<p>就是说，确保文档和模板只包含HTML，并且HTML只用来表现结构。把任何表现性的东西都移到样式表，任何行为性的东西都移到脚本中。</p>
<p>此外，<em>尽可能少的从文档和模板中引用样式表和脚本来减少三者的相互影响</em>。</p>
<p>结构、表现、行为分离对维护非常重要。更改HTML文档和模板总是比更新样式表和脚本成本更高。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 不推荐 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>HTML sucks<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;base.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;grid.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;print.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;print&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 1em;&quot;</span>&gt;</span>HTML sucks<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>I’ve read about this on a few sites but now I’m sure:</span><br><span class="line">  <span class="tag">&lt;<span class="name">u</span>&gt;</span>HTML is stupid!!1<span class="tag">&lt;/<span class="name">u</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span>I can’t believe there’s no way to control the styling of</span><br><span class="line">  my website without doing everything all over again!<span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 推荐 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>My first CSS-only redesign<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;default.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>My first CSS-only redesign<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>I’ve read about this on a few sites but today I’m actually</span><br><span class="line">  doing it: separating concerns and avoiding anything in the HTML of</span><br><span class="line">  my website that is presentational.</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>It’s awesome!</span><br></pre></td></tr></table></figure>

<h4 id="type-属性"><a href="#type-属性" class="headerlink" title="type 属性"></a>type 属性</h4><p>为样式表和脚本省略 <code>type</code> 属性。</p>
<p>引用样式表（除非不是使用CSS）和脚本（除非不是使用JavaScript）不要使用type属性。</p>
<p>HTML5将 text&#x2F;css 和 text&#x2F;javascript 设置为默认值，在这种情况下指定type属性并不必要。甚至同样兼容老版本的浏览器。</p>
<h3 id="HTML-格式规则"><a href="#HTML-格式规则" class="headerlink" title="HTML 格式规则"></a>HTML 格式规则</h3><h4 id="常规格式化"><a href="#常规格式化" class="headerlink" title="常规格式化"></a>常规格式化</h4><p>对每个块、列表、表格元素都另起一行，每个子元素都缩进。</p>
<p>每个块元素、列表元素或表格元素另起一行，而不必考虑元素的样式（因CSS可以改变元素的 <code>display</code> 属性）。</p>
<p>同样的，如果他们是块、列表或者表格元素的子元素，则将之缩进。</p>
<p>（如果你遇到列表项之间有空白的问题，可以把所有 <code>li</code> 元素放到一行。Linter鼓励抛出警告而不是错误。）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>Space<span class="tag">&lt;/<span class="name">em</span>&gt;</span>, the final frontier.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Moe</span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Larry</span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Curly</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">&quot;col&quot;</span>&gt;</span>Income</span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">&quot;col&quot;</span>&gt;</span>Taxes</span><br><span class="line">  <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>$ 5.00</span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>$ 4.50</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="CSS-样式规则"><a href="#CSS-样式规则" class="headerlink" title="CSS 样式规则"></a>CSS 样式规则</h3><h4 id="id-与-class-的命名"><a href="#id-与-class-的命名" class="headerlink" title="id 与 class 的命名"></a>id 与 class 的命名</h4><p>使用有意义的或者通用的id和class名称</p>
<p>用能反映出元素目的或者通用的id、class名称，代替那些很表象的、难懂的名称。</p>
<p>如果名称需要是易懂的，或不容易被修改，应该首选特定的或者能反映出元素目的的名称。</p>
<p>通用的名称适用于非特殊元素或与兄弟元素无区别的元素。他们常被称为“辅助元素”。</p>
<p>使用功能性或者通用的名称，可减少不必要的文档或者模板变化。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 不推荐：无意义 */</span></span><br><span class="line"><span class="selector-id">#yee-1901</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 不推荐：表象 */</span></span><br><span class="line"><span class="selector-class">.button-green</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.clear</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 推荐：具体的 */</span></span><br><span class="line"><span class="selector-id">#gallery</span> &#123;&#125;</span><br><span class="line"><span class="selector-id">#login</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.video</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 推荐：通用的 */</span></span><br><span class="line"><span class="selector-class">.aux</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.alt</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="id与class的命名规范"><a href="#id与class的命名规范" class="headerlink" title="id与class的命名规范"></a>id与class的命名规范</h4><p>ID和class命名要尽可能简短，但必要的话就别怕长。</p>
<p>尽可能简洁地传达id或者class名称的含义。</p>
<p>使用简洁的id或者class名称有助于提高可读性和代码效率。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 不推荐 */</span></span><br><span class="line"><span class="selector-id">#navigation</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.atr</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 推荐 */</span></span><br><span class="line"><span class="selector-id">#nav</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.author</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="简写属性"><a href="#简写属性" class="headerlink" title="简写属性"></a>简写属性</h4><p>尽可能使用简写的属性书写方式。</p>
<p>CSS提供了多种属性<strong>简写</strong>的方式（如 <code>font</code> ），即使只显式设置一个值，也应该尽可能地使用。</p>
<p>使用简写属性有助于提高代码效率及可读性。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 不推荐 */</span></span><br><span class="line"><span class="attribute">border-top-style</span>: none;</span><br><span class="line"><span class="attribute">font-family</span>: palatino, georgia, serif;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">line-height</span>: <span class="number">1.6</span>;</span><br><span class="line"><span class="attribute">padding-bottom</span>: <span class="number">2em</span>;</span><br><span class="line"><span class="attribute">padding-left</span>: <span class="number">1em</span>;</span><br><span class="line"><span class="attribute">padding-right</span>: <span class="number">1em</span>;</span><br><span class="line"><span class="attribute">padding-top</span>: <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 推荐 */</span></span><br><span class="line"><span class="attribute">border-top</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">font</span>: <span class="number">100%</span>/<span class="number">1.6</span> palatino, georgia, serif;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">0</span> <span class="number">1em</span> <span class="number">2em</span>;</span><br></pre></td></tr></table></figure>

<h4 id="id与class名称分隔符"><a href="#id与class名称分隔符" class="headerlink" title="id与class名称分隔符"></a>id与class名称分隔符</h4><p>用连字符分隔ID和类名中的单词。</p>
<p>选择器中的词语和缩写中不要使用除了连字符以外的任何字符（包括空字符），以提高可理解性和可读性。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 不推荐: 单词未分开 */</span></span><br><span class="line"><span class="selector-class">.demoimage</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 不推荐：使用下划线而不是连字符 */</span></span><br><span class="line"><span class="selector-class">.error_status</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 推荐 */</span></span><br><span class="line"><span class="selector-id">#video-id</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.ads-sample</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CSS-格式化规则"><a href="#CSS-格式化规则" class="headerlink" title="CSS 格式化规则"></a>CSS 格式化规则</h3><h4 id="声明顺序"><a href="#声明顺序" class="headerlink" title="声明顺序"></a>声明顺序</h4><p>按字母顺序排列声明。</p>
<p>css文件书写按字母顺序排列的方式，容易记忆和维护，以达到一致的代码。</p>
<p>在排序时忽略浏览器特定的前缀。但是，特定CSS属性的多个浏览器前缀应按字母顺序排列（如-moz书写在-webkit前面）。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>: fuchsia;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">-moz-<span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">-webkit-<span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line"><span class="attribute">color</span>: black;</span><br><span class="line"><span class="attribute">text-align</span>: center;</span><br><span class="line"><span class="attribute">text-indent</span>: <span class="number">2em</span>;</span><br></pre></td></tr></table></figure>

<h4 id="块内容的缩进"><a href="#块内容的缩进" class="headerlink" title="块内容的缩进"></a>块内容的缩进</h4><p>缩进块内容。</p>
<p>将包括嵌套及声明的 块内容 进行缩进，以体现层次并提高可读性。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen, projection &#123;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#444</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CSS属性名结束"><a href="#CSS属性名结束" class="headerlink" title="CSS属性名结束"></a>CSS属性名结束</h4><p>属性名称的冒号后有一个空格。</p>
<p>为保证一致性，在属性名与属性值之间添加一个空格（但是属性名和冒号间没有空格）。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 不推荐 */</span></span><br><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>:bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 推荐 */</span></span><br><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="声明块间隔"><a href="#声明块间隔" class="headerlink" title="声明块间隔"></a>声明块间隔</h4><p>在选择器和后面的声明块之间使用一个空格。</p>
<p>最后一个选择器与表示 声名块 开始的左大花括号在同行，中间有一个字符空格。</p>
<p>表示开始的左大花括号和选择器在同行。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 不推荐：缺少空间 */</span></span><br><span class="line"><span class="selector-id">#video</span>&#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 不推荐：不必要的换行符 */</span></span><br><span class="line"><span class="selector-id">#video</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 推荐 */</span></span><br><span class="line"><span class="selector-id">#video</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CSS代码块分离"><a href="#CSS代码块分离" class="headerlink" title="CSS代码块分离"></a>CSS代码块分离</h4><p>使用新空行分离规则。</p>
<p>始终把一个空行（两个换行符）放在代码块规则之间。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CSS元规则"><a href="#CSS元规则" class="headerlink" title="CSS元规则"></a>CSS元规则</h3><h4 id="分段规则"><a href="#分段规则" class="headerlink" title="分段规则"></a>分段规则</h4><p>组的分段由一段注释完成（可选）。</p>
<p>尽可能地用注释来将css分段，段与段之间采用新行。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Header */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#adw-header</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Footer */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#adw-footer</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Gallery */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.adw-gallery</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="赠言"><a href="#赠言" class="headerlink" title="赠言"></a>赠言</h3><p>请与周围保持一致。</p>
<p>如果你正在编辑代码，花几分钟时间看看上下文代码的格式，确定他们的编码风格。如果在上下文代码中，算术运算符前后有空格，或注释前后添加了“#”，你也应该这样做。</p>
<p>编写这个风格指导的目标是让人们可以专注于“我们在讨论什么”而不是“我们该怎么描述”。我们提供了一些通用的编码规范，大家就可以基于这些规范而继续，但特定情况下的规范也同样重要。如果你在一个文件中添加的代码看上去跟其他代码明显不同，你就把阅读此文件的人的节奏打乱了。避免这种情况出现。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="%22https://zh-google-styleguide.readthedocs.io/en/latest/contents/%22">Google 开源项目风格指南</a></p>
]]></content>
      <categories>
        <category>recruitment</category>
      </categories>
      <tags>
        <tag>style</tag>
      </tags>
  </entry>
  <entry>
    <title>教程其一之VSCode</title>
    <url>/2023/08/03/tutorial-vscode/</url>
    <content><![CDATA[<h2 id="工欲善其事，必先利其器-从环境开始讲起"><a href="#工欲善其事，必先利其器-从环境开始讲起" class="headerlink" title="工欲善其事，必先利其器-从环境开始讲起"></a>工欲善其事，必先利其器-从环境开始讲起</h2><p>刚踏入计算机相关专业，却从未有编程经验？甚至从小到大第一次遇见计算机？没有关系，让我们从零开始讲起，一步一步从最最基础的开始讲起。<br>开篇先叠甲：<em>以下所有内容仅源于于个人体验，请根据你使用最舒服的方式进行配置。</em></p>
<span id="more"></span>

<h2 id="计算机环境"><a href="#计算机环境" class="headerlink" title="计算机环境"></a>计算机环境</h2><h3 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h3><p>如题，请确保你能通过<strong>科学上网</strong>访问<a href="%22https://github.com/%22">Github</a>。如若不能（或者你从未听过科学上网），请询问你身边的学长学姐。</p>
<h3 id="安全软件"><a href="#安全软件" class="headerlink" title="安全软件"></a>安全软件</h3><p>首先，如果你有良好的计算机使用习惯，日常远离p2p下崽器、xxx中文网，始终对于网络资源尤其是各类安装包保持警惕，安装软件的第一步是寻找官网且日常略过前三广告，那么恭喜你，可以卸载所有安全管家等。<strong>Windows安全中心</strong>绝对足敷使用，请打开它并开启所有必要的保护。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308021111543.png"><br>这个可以解决许多因安全软件拦截而产生的疑难杂症。<strong>请务必确保您的使用习惯足够良好，本站概不承担因卸载后猪脑过载导致的财产损失。</strong></p>
<h3 id="浏览器和搜索引擎"><a href="#浏览器和搜索引擎" class="headerlink" title="浏览器和搜索引擎"></a>浏览器和搜索引擎</h3><p>Chrome，Edge，Firefox三选其一（排名分先后）。<br><strong>近乎所有的国产浏览器都是Chromium套壳+捆绑广告，请不要让它们污染你重金购入的电脑。</strong><br>利用科学上网手段注册账号后，打开密码自动填充并在手机端下载相同浏览器，上网体验如德芙般丝滑。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308021121569.png"><br>请将默认浏览器设置为你最喜欢的御三家之一，搜索引擎推荐google&#x2F;bing（前者更好，但需要保持科学上网）。<strong>作为高质量大学生，请不要使用百度搜索引擎。</strong></p>
<p>益智小游戏，请指出图中真正的steam官网：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308021126585.png"></p>
<p>最基本的计算机环境已经配置完毕，电脑已经清爽许多，现在让我们叩开编程的大门，不妨先从环境入手。</p>
<h2 id="Visual-Studio-Code：免费开源的轻量级代码编辑器"><a href="#Visual-Studio-Code：免费开源的轻量级代码编辑器" class="headerlink" title="Visual Studio Code：免费开源的轻量级代码编辑器"></a>Visual Studio Code：免费开源的轻量级代码编辑器</h2><h3 id="为什么是-VS-Code-？"><a href="#为什么是-VS-Code-？" class="headerlink" title="为什么是 VS Code ？"></a>为什么是 VS Code ？</h3><p>VS Code 的全称是 Visual Studio Code，是一款开源的、免费的、跨平台的、高性能的、轻量级的代码<strong>编辑器</strong>。</p>
<p>何为编辑器？何为IDE？</p>
<ul>
<li>IDE（Integrated Development Environment，集成开发环境）:一组集成在一起的工具，包含文本编辑器、编译器、构建或集成、调试。侧重于工程项目，比较臃肿笨重。如Visual Studio、IDEA、Eclipse。</li>
<li>编辑器：文本（代码）的编辑。如Windows系统自带的记事本就是最简单的编辑器。</li>
</ul>
<p>微软有两种软件：一种是 VS Code，一种是其他软件。</p>
<h3 id="VS-Code-的特点"><a href="#VS-Code-的特点" class="headerlink" title="VS Code 的特点"></a>VS Code 的特点</h3><ul>
<li>跨平台：支持 MacOS、Windows 和 Linux 等多个平台，且有一致的用户界面和开发体验，支持同步配置</li>
<li>开源：源代码、开发计划和发布管理均开源</li>
<li>自带终端、Git版本支持</li>
<li>丰富的插件拓展</li>
<li>活跃的社区生态</li>
<li>语法支持：语法高亮、代码智能提示和补全、括号匹配、颜色区分、代码片段提示</li>
</ul>
<h3 id="官网安装"><a href="#官网安装" class="headerlink" title="官网安装"></a>官网安装</h3><p>免费？不是70r吗？</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308021130466.png"></p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308021132921.webp"></p>
<p>这就是为什么推荐google或bing搜索引擎，因为你真的能在国产搜索引擎看到这些。如果对是否是官网有疑问，请尤其注意他的域名。通过域名，能够分辨一大半的虚假官网。</p>
<p>真正的VSCode官网：<span class="exturl" data-url="aHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20v">https://code.visualstudio.com/<i class="fa fa-external-link-alt"></i></span>，点开后你应该能看到如下网页。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308021137406.png"></p>
<p>请根据你的电脑型号（Windows or MacOS）选择对应Stable（*稳定）版本下载。安装过程不再赘述，其中注意Win本<strong>尽量选择安装路径为非C盘</strong>即可，否则后续很可能<strong>因为C盘爆满，Windows系统无法更新</strong>。</p>
<p>安装完成后打开软件，界面如下：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308030942879.png"></p>
<p>如果你对英文界面感觉不太好，那么第一步就是<strong>将VSCode设置为中文</strong>。以下有两种方法：</p>
<ul>
<li>Windows用户快捷键<code>Ctrl+Shift+P</code>（Mac用户快捷键<code>Cmd+Shift+P</code>），打开命令面板，输入<code>Configure Display Language</code>，选择<code>Install additional languages</code>，然后安装插件<code>Chinese(Simplified) Language Pack for Visual Studio Code</code>即可</li>
<li>Windows用户快捷键<code>Ctrl+Shift+X</code>，打开拓展页面，同样安装此插件<code>Chinese(Simplified) Language Pack for Visual Studio Code</code><br>安装完成后，重启 VS Code 。</li>
</ul>
<p>解放右手，请熟记常用快捷键组合。</p>
<h3 id="常见操作-amp-使用技巧"><a href="#常见操作-amp-使用技巧" class="headerlink" title="常见操作&amp;使用技巧"></a>常见操作&amp;使用技巧</h3><h4 id="1、快速生成HTML骨架"><a href="#1、快速生成HTML骨架" class="headerlink" title="1、快速生成HTML骨架"></a>1、快速生成HTML骨架</h4><p>新建一个.html文件（如example.html），然后通过以下方式可快速生成HTML骨架：</p>
<ol>
<li>输入<code>!</code>（英文感叹号），然后按下<code>Enter</code>键</li>
<li>输入<code>html:5</code>，然后按住<code>Tab</code>键<br>生成的骨架如下：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>小技巧：</strong>在HTML文件中输入<code>lorem</code>可生成一段占位文本。</p>
<h4 id="2、并排编辑：上下左右显示多个文件窗口"><a href="#2、并排编辑：上下左右显示多个文件窗口" class="headerlink" title="2、并排编辑：上下左右显示多个文件窗口"></a>2、并排编辑：上下左右显示多个文件窗口</h4><p>Windows用户按住快捷键<code>Ctrl + \</code>（反斜杠，在你的<code>Enter</code>回车键上方），即可同时打开多个编辑器窗口，进行并排编辑。按快捷键<code>Ctrl + 1</code>切换到左侧窗口，<code>Ctrl + 2</code>切换到右侧窗口，以此类推。</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308031012609.png"></p>
<h3 id="部分插件推荐"><a href="#部分插件推荐" class="headerlink" title="部分插件推荐"></a>部分插件推荐</h3><h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308031015953.png"></p>
<p>我们可通过点击上图中红框部分，即可在顶部输入框中查找想要安装的插件名，然后进行安装。安装完毕后部分插件会需要重启软件，插件才会生效。<br>另外，我们也可以通过访问官网的插件市场来安装插件：<br>VS Code 官网插件市场：<span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL3ZzY29kZQ==">https://marketplace.visualstudio.com/vscode<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="推荐的插件"><a href="#推荐的插件" class="headerlink" title="推荐的插件"></a>推荐的插件</h4><h5 id="0、基本插件"><a href="#0、基本插件" class="headerlink" title="0、基本插件"></a>0、基本插件</h5><h6 id="Chinese-Simplified-Language-Pack-for-Visual-Studio-Code"><a href="#Chinese-Simplified-Language-Pack-for-Visual-Studio-Code" class="headerlink" title="Chinese (Simplified) Language Pack for Visual Studio Code"></a>Chinese (Simplified) Language Pack for Visual Studio Code</h6><p>中文语言插件，不必多言。</p>
<h5 id="1、Git相关"><a href="#1、Git相关" class="headerlink" title="1、Git相关"></a>1、Git相关</h5><p>还不熟悉Git？没事，先安装再说，后续我们一定会讲到or用上。</p>
<h6 id="GitLens"><a href="#GitLens" class="headerlink" title="GitLens"></a>GitLens</h6><p>Git管理神器，可视化仓库。</p>
<h6 id="Local-History"><a href="#Local-History" class="headerlink" title="Local History"></a>Local History</h6><p>维护文件的本地历史记录，妈妈再也不用担心我代码忘记保存了。</p>
<h5 id="2、代码显示增强"><a href="#2、代码显示增强" class="headerlink" title="2、代码显示增强"></a>2、代码显示增强</h5><h6 id="highlight-icemode"><a href="#highlight-icemode" class="headerlink" title="highlight-icemode"></a>highlight-icemode</h6><p>选中相同代码时高亮显示。安装后请关闭 VS Code 自带高亮，于用户设置添加<code>&quot;editor.selectionHighlight&quot;: false</code>。</p>
<h6 id="TODO-Highlight"><a href="#TODO-Highlight" class="headerlink" title="TODO Highlight"></a>TODO Highlight</h6><p>什么，手上的 bug 还没修完突然有事，正巧这时候有了思路？按照代码规范，可以在代码中加上 TODO 注释（区分大小写）。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// TODO:发现跳转bug，可能的解决思路为：······</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// FIXME: 如没有万分把握请勿删去此行注释，可能导致程序崩溃。</span><br></pre></td></tr></table></figure>
<p>安装此插件后，打开命令面板（还记得快捷键吗？）输入<code>TODO-Highlight</code>，选择相关命令，我们就可以看到 todoList 清单。</p>
<h5 id="3、图片相关插件"><a href="#3、图片相关插件" class="headerlink" title="3、图片相关插件"></a>3、图片相关插件</h5><h6 id="Polacode-2022"><a href="#Polacode-2022" class="headerlink" title="Polacode-2022"></a>Polacode-2022</h6><p>可优雅地分享你的代码截图，如下所示：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308031036600.png"></p>
<p>我们谴责愚蠢的拍屏主义者，<code>Win+Shift+S</code>截图为可接受的。</p>
<h5 id="4、Markdown相关"><a href="#4、Markdown相关" class="headerlink" title="4、Markdown相关"></a>4、Markdown相关</h5><p>本网站所有博客均由 Markdown 写成，其优点在于不用操心格式，随想随写，解放右手。推荐 VS Code + Markdown ，最好的笔记组合。</p>
<h6 id="Markdown-Preview-Github-Styling"><a href="#Markdown-Preview-Github-Styling" class="headerlink" title="Markdown Preview Github Styling"></a>Markdown Preview Github Styling</h6><p>以 Github 风格预览 Markdown 样式，简洁且优雅。左侧书写右侧预览。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308031047619.png"></p>
<h5 id="5、通用工具"><a href="#5、通用工具" class="headerlink" title="5、通用工具"></a>5、通用工具</h5><h6 id="Live-Server"><a href="#Live-Server" class="headerlink" title="Live Server"></a>Live Server</h6><p>在本地启动服务器，代码修改时实现<strong>热更新</strong>，不需要手动刷新页面。<br>使用方式：于代码页面点击右键，选择<code>Open with Live Server</code>。</p>
<h6 id="WakaTime"><a href="#WakaTime" class="headerlink" title="WakaTime"></a>WakaTime</h6><p>统计在各安装了 WakaTime 插件的编程环境中写代码的时间，发现真实的自己。网站统计效果如下：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308031051230.png"></p>
<h5 id="6、软件主题"><a href="#6、软件主题" class="headerlink" title="6、软件主题"></a>6、软件主题</h5><p>想给你的 VS Code 换个皮肤？欢迎来到海澜之家！</p>
<ul>
<li><p>Dracula Theme</p>
</li>
<li><p>Material Theme</p>
</li>
<li><p>Nebula Theme</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPXpodWFuZ3RvbmdmYS5NYXRlcmlhbC10aGVtZQ==">One Dark Pro<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>One Monokai Theme</p>
</li>
<li><p>Monokai Pro</p>
</li>
<li><p>Ayu</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPWFrYXJsc3Rlbi52c2NvZGUtc25henp5LWFrYXJsc3Rlbg==">Snazzy Plus<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPWFsZXhhbmRlcnRlLmRhaW50eS12c2NvZGU=">Dainty<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>GitHub Plus Theme：白色主题</p>
</li>
<li><p>Horizon Theme：红色主题</p>
</li>
</ul>
<h3 id="多端协作：-VS-Code-云同步"><a href="#多端协作：-VS-Code-云同步" class="headerlink" title="多端协作： VS Code 云同步"></a>多端协作： VS Code 云同步</h3><ol>
<li>上方菜单栏选择<code>文件-首选项-打开设置同步</code></li>
<li>选择需要同步的配置，全选即可</li>
<li>通过 GitHub 账号登录</li>
<li>同步完成后，菜单栏显示“设置同步已打开”</li>
</ol>
<p>什么，你还没有 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLw==">GitHub<i class="fa fa-external-link-alt"></i></span> 账号？注册啊！</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202308031041381.jpg"></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3FpYW5ndXlpaGFvL1dlYi9ibG9iL21hc3Rlci8wMC0lRTUlODklOEQlRTclQUIlQUYlRTUlQjclQTUlRTUlODUlQjcvMDEtVlMlMjBDb2RlJUU3JTlBJTg0JUU0JUJEJUJGJUU3JTk0JUE4Lm1k">Web-Master&#x2F;00-前端工具<i class="fa fa-external-link-alt"></i></span><br>多有参考，如想进一步了解 VS Code 如快捷键及更进一步的配置，可阅读全文。<br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC85MjMxMjY0Mg==">为什么要学Markdown？有什么用？<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>recruitment</category>
      </categories>
      <tags>
        <tag>frontend</tag>
        <tag>software-engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>websocket 在 vue 中的使用</title>
    <url>/2023/08/22/use-websocket-in-vue/</url>
    <content><![CDATA[<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>socket.io-client</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pnpm i socket.io-client</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol>
<li>规范 socket api</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// socket.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; io, <span class="title class_">Socket</span> &#125; <span class="keyword">from</span> <span class="string">&quot;socket.io-client&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SocketService</span> &#123;</span><br><span class="line">  <span class="attr">socket</span>: <span class="title class_">Socket</span></span><br><span class="line">  <span class="attr">state</span>: <span class="built_in">any</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="attr">room</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="attr">sio</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">flag</span>: <span class="number">60</span>,</span><br><span class="line">      <span class="attr">sid</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="attr">heartbeatTimer</span>: <span class="literal">null</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socket</span> = <span class="title function_">io</span>(<span class="string">&quot;/websocket&quot;</span>, &#123;</span><br><span class="line">      <span class="attr">autoConnect</span>: <span class="literal">false</span>, <span class="comment">// 禁止自动连接</span></span><br><span class="line">      <span class="attr">extraHeaders</span>: &#123;</span><br><span class="line">        <span class="string">&quot;Access-Control-Allow-Origin&quot;</span>: <span class="string">&quot;*&quot;</span> <span class="comment">// 设置跨域请求头</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// connect, get_sid 只执行一次，采用 once</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socket</span>.<span class="title function_">once</span>(<span class="string">&quot;connect&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">handleConnect</span>()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socket</span>.<span class="title function_">once</span>(<span class="string">&quot;get_sid&quot;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">handleGetSid</span>(data)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socket</span>.<span class="title function_">on</span>(<span class="string">&quot;join_room_result&quot;</span>, <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">handleJoinRoomResult</span>(res)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socket</span>.<span class="title function_">on</span>(<span class="string">&quot;test&quot;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">handleTest</span>(data)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socket</span>.<span class="title function_">on</span>(<span class="string">&quot;leave&quot;</span>, <span class="function">(<span class="params">room</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">handleLeave</span>(room)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socket</span>.<span class="title function_">on</span>(<span class="string">&quot;leave_all&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">handleLeaveAll</span>()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socket</span>.<span class="title function_">on</span>(<span class="string">&quot;connect_error&quot;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">handleConnectError</span>(err)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">connect</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socket</span>.<span class="title function_">connect</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;socket connect&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">disconnect</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">handleLeaveAll</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">stopHeartbeat</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socket</span>.<span class="title function_">disconnect</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;socket disconnect&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">joinRoom</span>(<span class="params">room: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socket</span>.<span class="title function_">emit</span>(<span class="string">&quot;join&quot;</span>, &#123; <span class="attr">rooms</span>: [room] &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">leaveRoom</span>(<span class="params">room: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">handleLeave</span>(room)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">leaveAll</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">handleLeaveAll</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">handleConnect</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socket</span>.<span class="title function_">emit</span>(<span class="string">&quot;get_sid&quot;</span>, &#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">handleGetSid</span>(<span class="params">data: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">sid</span> = data.<span class="property">sid</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;get_sid:&quot;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">sid</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">handleJoinRoomResult</span>(<span class="params">res: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">handleTest</span>(<span class="params">data: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;test data:&quot;</span> + data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 离开指定房间</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">handleLeave</span>(<span class="params">room: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socket</span>.<span class="title function_">emit</span>(<span class="string">&quot;leave&quot;</span>, &#123; <span class="attr">rooms</span>: [room] &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;leave room &quot;</span> + room)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 离开所有房间</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">handleLeaveAll</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socket</span>.<span class="title function_">emit</span>(<span class="string">&quot;leave_all&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;leave all room&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理连接错误</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">handleConnectError</span>(<span class="params">err: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">stopHeartbeat</span>() <span class="comment">// 停止心跳，避免不必要的心跳消息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 启动心跳计时器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">startHeartbeat</span>() =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">heartbeatTimer</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">heartbeatTimer</span> = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">sendHeartbeat</span>()</span><br><span class="line">        &#125;, <span class="number">15000</span>) <span class="comment">// 15秒发送一次心跳，可以根据需求调整</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 停止心跳计时器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">stopHeartbeat</span>() =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">heartbeatTimer</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">heartbeatTimer</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">heartbeatTimer</span> = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送心跳数据</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">sendHeartbeat</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socket</span>.<span class="title function_">emit</span>(<span class="string">&quot;heartbeat&quot;</span>, &#123; <span class="comment">/* 心跳数据 */</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> socketService = <span class="keyword">new</span> <span class="title class_">SocketService</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> socket = socketService.<span class="property">socket</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> state = socketService.<span class="property">state</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>设置 url</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vite.config.ts</span></span><br><span class="line"></span><br><span class="line"><span class="attr">proxy</span>: &#123;</span><br><span class="line">    <span class="string">&quot;/socket.io&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&quot;http://example.com&quot;</span> <span class="comment">// 代理目标（后端 socket URL ）</span></span><br><span class="line">        <span class="attr">ws</span>: <span class="literal">true</span>, <span class="comment">// 设置代理 WebSocket 连接</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">// 允许跨域</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>建立 socket 连接</li>
</ol>
<p>websocket 连接应在打开页面时建立，关闭页面时销毁，所以应选择在入口文件建立。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// App.vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; socketService &#125; <span class="keyword">from</span> <span class="string">&quot;@/api/socket&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; onBeforeUnmount &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line">socketService.<span class="title function_">connect</span>()</span><br><span class="line"></span><br><span class="line"><span class="title function_">onBeforeMount</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    socketService.<span class="title function_">disconnect</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>进入 socket 房间</li>
</ol>
<p>为保证浏览器性能，房间应该在进入特定路由时建立，离开特定路由时退出，所以选择在路由守卫文件编写相关逻辑。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// permission.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&quot;@/router&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; socketService &#125; <span class="keyword">from</span> <span class="string">&quot;@/api/socket&quot;</span></span><br><span class="line"></span><br><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 离开特定路由时离开对应房间</span></span><br><span class="line">    <span class="keyword">if</span>( <span class="keyword">from</span>.<span class="property">name</span> === <span class="string">&quot;room-name&quot;</span> ) &#123;</span><br><span class="line">        socketService.<span class="title function_">leaveRoom</span>(<span class="string">&quot;room-name&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入特定路由时进入特定房间</span></span><br><span class="line">    <span class="keyword">if</span>( to.<span class="property">name</span> !== <span class="string">&quot;room-name&quot;</span> ) &#123;</span><br><span class="line">        socketService.<span class="title function_">joinRoom</span>(<span class="string">&quot;room-name&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>监听数据</li>
</ol>
<p>后端通过 WebSocket 发送的数据在前端页面渲染的部分，应在前端对应页面监听。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; socket &#125; <span class="keyword">from</span> <span class="string">&quot;@/api/socket&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">subscribeChannel</span> = (<span class="params">channel: <span class="built_in">string</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">unsubscribeChannel</span>(channel) <span class="comment">// 避免重复订阅</span></span><br><span class="line"></span><br><span class="line">    socket.<span class="title function_">on</span>(channel, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 处理数据...</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">unsubscribeChannel</span> = (<span class="params">channel: <span class="built_in">string</span></span>) =&gt; &#123;</span><br><span class="line">    socket.<span class="title function_">off</span>(channel)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL1dlYlNvY2tldA==">WebSocket - Web Api 接口参考|MDN<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9zb2NrZXQuaW8vemgtQ04v">Socket.io<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>frontend</tag>
        <tag>vue</tag>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode 下的 PR 流程</title>
    <url>/2023/10/26/vscode-PR/</url>
    <content><![CDATA[<h2 id="VSCode-下的-PR-流程"><a href="#VSCode-下的-PR-流程" class="headerlink" title="VSCode 下的 PR 流程"></a>VSCode 下的 PR 流程</h2><ol>
<li>VSCode 安装 <code>Github Pull Request 插件</code><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202310261942360.png"></li>
<li>于源代码管理处点击<code>创建拉取请求</code><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202310261943040.png"></li>
<li>提交 PR 后等待其余协同开发者审核<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202310261945217.png"></li>
</ol>
<span id="more"></span>

<h2 id="Commit-x2F-PR-规范"><a href="#Commit-x2F-PR-规范" class="headerlink" title="Commit&#x2F;PR 规范"></a>Commit&#x2F;PR 规范</h2><blockquote>
<p>参考：Angular commit 规范</p>
</blockquote>
<p>提交信息包括三个部分：</p>
<ul>
<li>Header</li>
<li>Body</li>
<li>footer<br>其中 header 为必填，其余可省略</li>
</ul>
<h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>Header 部分只有一行，包含两个字段，均必填</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;type&gt;: &lt;subject&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>type：说明 commit 的类别，可以使用如下类别</li>
</ol>
<ul>
<li>feat：新功能（feature）</li>
<li>fix：修补 bug</li>
<li>doc：文档（documentation）</li>
<li>refactor：重构（不属于 feat 和 fix 的代码变动）</li>
<li>test：增加测试</li>
<li>chore：构建过程或辅助工具的变动</li>
</ul>
<ol start="2">
<li>subject：对 commit 目的的简短描述</li>
</ol>
<ul>
<li>以动词开头，使用第一人称现在时（改变 √ 改变了 ×）</li>
<li>结尾不加句号（。）</li>
</ul>
<h3 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h3><p>Body 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">More detailed explanatory text, if necessary.  Wrap it to </span><br><span class="line">about 72 characters or so. </span><br><span class="line"></span><br><span class="line">Further paragraphs come after blank lines.</span><br><span class="line"></span><br><span class="line">- Bullet points are okay, too</span><br><span class="line">- Use a hanging indent</span><br></pre></td></tr></table></figure>

<p>注意：应注意代码变动的动机，以及与以前行为的对比</p>
<h3 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h3><p>Footer 部分应该包含：</p>
<ol>
<li>Breaking Changes</li>
<li>关闭 issue</li>
</ol>
<h4 id="Breaking-Changes"><a href="#Breaking-Changes" class="headerlink" title="Breaking Changes"></a>Breaking Changes</h4><p>如果当前代码与上一个版本不兼容，则 Footer 部分以 BREAKING CHANGE 开头，后面是对变动的描述、以及变动理由和迁移方法。</p>
<h4 id="issue"><a href="#issue" class="headerlink" title="issue"></a>issue</h4><ol>
<li>通过 commit 关联 issue ：如果当前提交信息关联了某个issue，那么可以在 Footer 部分关联这个 issue：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">issue #2</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过commit关闭issue，当提交到默认分支时，提交信息里可以使用 fix&#x2F;fixes&#x2F;fixed , close&#x2F;closes&#x2F;closed 或者 resolve&#x2F;resolves&#x2F;resolved等关键词，后面为 issue 编号，关闭对应Issue：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Closes #1</span><br></pre></td></tr></table></figure>

<p>注意：如果不是提交到默认分支，那么并不能关闭这个issue，但是在这个issue下面会显示相关的信息表示曾经想要关闭这个issue，当这个分支合并到默认分支时，就可以关闭这个issue了。</p>
<h2 id="PR-模板"><a href="#PR-模板" class="headerlink" title="PR 模板"></a>PR 模板</h2><p>推荐路径：<code>.github/pull_request_template.md</code></p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="section"># PR 标题</span></span><br><span class="line">&lt;!-- </span><br><span class="line">格式为 type：subject（中文分号）</span><br><span class="line"><span class="bullet">-</span> type：说明 commit 的类别，可以使用如下类别</span><br><span class="line"><span class="bullet">-</span> - feat：新功能（feature）</span><br><span class="line"><span class="bullet">-</span> - fix：修复 bug</span><br><span class="line"><span class="bullet">-</span> - doc：文档（documentation）</span><br><span class="line"><span class="bullet">-</span> - refactor：重构（不属于 feat 和 fix 的代码变动）</span><br><span class="line"><span class="bullet">-</span> - build：构建打包</span><br><span class="line"><span class="bullet">-</span> - test：增加测试</span><br><span class="line"><span class="bullet">-</span> - chore：构建过程或辅助工具的变动</span><br><span class="line"><span class="bullet">-</span> - revert：恢复</span><br><span class="line"><span class="bullet">-</span> subject：对 commit/PR 目的的简短描述</span><br><span class="line"><span class="bullet">-</span> - 以动词开头，使用第一人称现在时（改变 √ 改变了 ×）</span><br><span class="line"><span class="bullet">-</span> - 结尾不加句号（。）</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line">feat：添加实时表格</span><br><span class="line">bug：修复实时表格小数点位问题</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line"><span class="section">## 内容</span></span><br><span class="line">&lt;!-- </span><br><span class="line">是对本次 commit 的详细描述，可以分成多行。下面是一个范例</span><br><span class="line"></span><br><span class="line">More detailed explanatory text, if necessary.  Wrap it to </span><br><span class="line">about 72 characters or so. </span><br><span class="line"></span><br><span class="line">Further paragraphs come after blank lines.</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> Bullet points are okay, too</span><br><span class="line"><span class="bullet">-</span> Use a hanging indent</span><br><span class="line"></span><br><span class="line">应注意代码变动的动机、与以前行为的对比</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line"><span class="section">## 影响范围</span></span><br><span class="line">&lt;!-- </span><br><span class="line">描述这个PR对现有代码的影响。例如：</span><br><span class="line"><span class="bullet">  -</span> 影响哪些组件或功能</span><br><span class="line"><span class="bullet">  -</span> 是否引入了任何可能的性能问题</span><br><span class="line"><span class="bullet">  -</span> 是否有任何向后兼容的问题 </span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line"><span class="section">## 附加信息</span></span><br><span class="line">&lt;!-- </span><br><span class="line">包含 Breaking Changes 和关闭 issue</span><br><span class="line"><span class="bullet">-</span> Breaking Changes： 当前代码是否与上一个版本不兼容，如有，需包含对变动的描述、以及变动理由和迁移方法</span><br><span class="line"><span class="bullet">-</span> issue：是否有关联的 issue，是否需关闭 issue</span><br><span class="line"><span class="bullet">-</span> - 关联 issue ： issue #42</span><br><span class="line"><span class="bullet">-</span> - 关闭 issue ： closes #42</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line"><span class="section">## 请求审查</span></span><br><span class="line">&lt;!-- @提及需要审查这个PR的团队成员或团队。 --&gt;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202312071711649.png"></p>
]]></content>
      <categories>
        <category>experience</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>软件体系结构复习</title>
    <url>/2024/01/12/software-architecture-review/</url>
    <content><![CDATA[<h2 id="概论（5分左右）"><a href="#概论（5分左右）" class="headerlink" title="概论（5分左右）"></a>概论（5分左右）</h2><h3 id="软件体系结构的意义"><a href="#软件体系结构的意义" class="headerlink" title="软件体系结构的意义"></a>软件体系结构的意义</h3><p><strong>体系结构提供一种方法：解决共同的问题，确保建筑、桥梁、乐曲、书籍、计算机、网络或系统在完成后具有某些属性或行为</strong></p>
<ul>
<li>体系结构既是所构建系统的计划，确保得到期望的特性，同时也是所构建系统的描述。</li>
</ul>
<p>软件体系结构的意义：</p>
<ul>
<li>体系结构，有助于确保系统能够满足其利益相关人的关注点，构想、计划、构建、维护系统时，体系结构有助于处理复杂性。</li>
<li>开发一个具有一定规模和复杂性的软件系统和编写一个简单的程序是不一样的</li>
</ul>
<span id="more"></span>

<h3 id="软件体系结构的意义-1"><a href="#软件体系结构的意义-1" class="headerlink" title="软件体系结构的意义"></a>软件体系结构的意义</h3><p><strong>软件体系结构 &#x3D; 组件 + 连接件 + 约束</strong><br>Software Architecture &#x3D; Components + Connectors + Constrain</p>
<ul>
<li>组件：具有某种功能的可重用的<strong>软件模块单元</strong>，表示了系统中主要的<strong>计算单元</strong>和<strong>数据存储</strong>。</li>
<li>连接件：表示了<strong>组件之间的交互</strong></li>
<li>约束：表示了组件和连接件的<strong>拓扑逻辑</strong>和<strong>约束</strong></li>
</ul>
<p>国内定义：<strong>软件体系结构 &#x3D; 构件 + 连接件 + 约束</strong><br>软件体系结构包括<strong>构件、连接件和约束</strong>，它是<strong>可预制</strong>和<strong>可重构</strong>的软件框架结构。</p>
<ul>
<li><strong>构件</strong>是可预制和可重用的软件部件，是组成体系结构的基本计算单元或数据存储单元</li>
<li><ul>
<li>构件是<strong>指一个计算单元或者数据存储单元，可以是一个处理过程或数据元素</strong>。</li>
</ul>
</li>
<li><ul>
<li><strong>构件是用于实现计算和状态的单元</strong>，可以工作在：客户端、服务器端、数据库或层等。</li>
</ul>
</li>
<li><ul>
<li>构件可简单可复杂：复杂构件描述一个系统，一个体系结构由一些描述系统的复杂构件组成。</li>
</ul>
</li>
<li><strong>连接件</strong>也是可预制和可重用的软件部件，是构件之间的连接单元</li>
<li><ul>
<li>连接件用于建模：<strong>构件之间的相互作用、控制这些相互作用的规则</strong></li>
</ul>
</li>
<li>构件和连接件之间的关系用<strong>约束</strong>来描述</li>
<li><ul>
<li><strong>约束描述了体系结构的配置和拓扑要求，配置或拓扑</strong></li>
</ul>
</li>
<li><ul>
<li><strong>用于描述软件体系结构的构成，确定了体系结构的构件与连接件之间的连接关系</strong>：正确的连接性、并发和分布性、符合设计的启发和风格规则</li>
</ul>
</li>
</ul>
<h3 id="软件体系结构的发展史"><a href="#软件体系结构的发展史" class="headerlink" title="软件体系结构的发展史"></a>软件体系结构的发展史</h3><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401122139501.png"></p>
<p>软件体系结构的研究活动-软件体系结构要解决的问题：</p>
<ul>
<li>软件体系结构的<strong>建模与表示</strong>（Architecture Modeling and Documenting）</li>
<li>软件体系结构<strong>风格</strong>的研究(Software Architecture Styles)</li>
<li>体系结构<strong>描述语言</strong>(Architecture Description Language,ADL)</li>
<li>软件体系结构的<strong>评价方法</strong>(Architecture Evaluation)</li>
<li>软件产品线及特定领域软件框架的研究(Product line and DSSA)</li>
<li>动态软件体系结构</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401122141021.png"></p>
<h3 id="软件体系结构的优势"><a href="#软件体系结构的优势" class="headerlink" title="软件体系结构的优势"></a>软件体系结构的优势</h3><ul>
<li>容易理解：从<strong>高层设计的抽象层次</strong>来表征一个系统，<strong>简化了</strong>我们理解庞大系统的能力</li>
<li>重用：<strong>重用</strong>大的构件、重用一些集成构件的框架、<strong>特定领域</strong>的软件体系结构、<strong>设计模式</strong></li>
<li>控制成本：系统维护者可以<strong>更好的理解变更带来的影响</strong>，因而可以<strong>更加精确的估算变更所需的成本</strong></li>
<li>可分析性：对系统的一致性检查提供<strong>高层次的视图</strong></li>
</ul>
<p>软件架构师关键关注点：功能性、可变性、性能、容量、生态系统、模块化、可构建性、产品化、安全性</p>
<h2 id="软件体系结构风格"><a href="#软件体系结构风格" class="headerlink" title="软件体系结构风格"></a>软件体系结构风格</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>多年来，人们在开发某些类型软件过程中积累起来的组织规则和结构，形成了软件体系结构风格</li>
<li>软件体系结构设计的一个核心问题是，能否使用重复的体系结构模式，即能否达到体系结构级的软件重用</li>
<li>软件体系结构风格是描述<strong>某一特定应用领域中系统组织方式的惯用模式</strong></li>
<li><ul>
<li><strong>体系结构风格定义一个系统家族，即一个体系结构定义一个词汇表和一组约束</strong></li>
</ul>
</li>
<li><ul>
<li>体系结构风格，反映了领域中中<strong>众多系统所共有的结构和语义特征，并指导如何将各个模块和子系统有效地组织成一个完整的系统</strong></li>
</ul>
</li>
</ul>
<p><strong>体系结构风格的最关键的四要素</strong>：</p>
<ol>
<li>提供一个词汇表</li>
<li>定义一套配置规则</li>
<li>定义一套语义解释原则</li>
<li>定义对基于这种风格的系统所进行的分析</li>
</ol>
<h3 id="管道-过滤器风格的体系结构"><a href="#管道-过滤器风格的体系结构" class="headerlink" title="管道-过滤器风格的体系结构"></a>管道-过滤器风格的体系结构</h3><p>管道-过滤器模式下，每个功能模块都有一组输入和输出，功能模块从输入集合读入数据流，并在输出集合产生输出数据流，即功能模块对输入数据流进行增量计算得到输出数据流。功能模块称作过滤器（Filter），功能模块间的连接可以看作输入、输出数据流之间的通路，所以称作管道（Pipe）。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401122153552.png"></p>
<ol>
<li>管道-过滤器体系结构模式，把系统任务分成几个序贯的处理步骤。这些步骤，通过系统的数据流连接，一个步骤的输出是下一个步骤的输入</li>
<li>系统的输入，由诸如文本文件等数据源提供</li>
<li>实现相连处理步骤间的数据流动。通过管道联合的过滤器序列叫做处理流水线（pipeline）</li>
<li>过滤器是独立运行的部件，不受其它过滤器运行的影响</li>
</ol>
<p>优点：</p>
<ol>
<li>由于每个构件的行为不受其他构件的影响，因此，整个系统的行为比较易于理解</li>
<li>支持功能模块的复用</li>
<li>具有较强的可维护性、可扩展性</li>
<li>支持特殊的分析</li>
<li>支持并发执行</li>
</ol>
<p>缺点：</p>
<ol>
<li>往往会导致系统处理过程的成批操作</li>
<li>在处理两个独立但又相关的数据流时，可能会遇到困难</li>
<li>需要对数据传输进行特定的处理时，导致对于每个过滤器的解析输入和格式化输出要做更多的工作，带来系统复杂性的上升</li>
<li>并行处理获得的效率，往往是一种假象</li>
</ol>
<h3 id="数据抽象和面向对象风格"><a href="#数据抽象和面向对象风格" class="headerlink" title="数据抽象和面向对象风格"></a>数据抽象和面向对象风格</h3><p>抽象数据类型概念，对软件系统有着重要作用，目前，软件界已普遍转向使用面向对象系统</p>
<ul>
<li>这种风格建立在数据抽象和面向对象的基础上，数据的表示方法和相应操作，封装在一个抽象数据类型或对象中</li>
<li>这种风格的<strong>构件是对象</strong>，或者说，是抽象数据类型的实例</li>
</ul>
<p>优点：</p>
<ol>
<li>改变一个对象的表示，而不影响其他对象</li>
<li>设计者可将一些数据存取操作的问题分解成一些交互的代理程序的集合</li>
</ol>
<p>缺点：</p>
<ol>
<li>为了使对象间通过过程调用等进行交互，<strong>必须知道对象的标识</strong></li>
<li>连锁反应：必须修改所有显示调用它的其他对象，并消除由此带来的副作用</li>
</ol>
<h3 id="基于事件的隐式调用风格（事件驱动）"><a href="#基于事件的隐式调用风格（事件驱动）" class="headerlink" title="基于事件的隐式调用风格（事件驱动）"></a>基于事件的隐式调用风格（事件驱动）</h3><ul>
<li>基于事件的隐式调用风格的思想，是构件不直接调用一个过程，而是触发或广播一个或多个事件</li>
<li>从体系结构上说，这种风格的构件是一些模块，这些模块既可以是一些过程，又可以是一些事件的集合</li>
<li>基于事件的隐式调用风格的主要特点，是事件的触发者并不知道哪些构件会被这些事件影响</li>
</ul>
<p>优点：</p>
<ul>
<li>为软件重用提供了强大的支持</li>
<li>为改进系统带来了方便</li>
</ul>
<p>缺点：</p>
<ul>
<li>构件放弃了对系统计算的控制</li>
<li>数据交换的问题</li>
<li>既然过程的语义必须依赖于被触发事件的上下文约束，关于正确性的推理，就存在问题</li>
</ul>
<p>总结：</p>
<ul>
<li>构件不直接调用一个过程，而是触发或广播一个或多个事件</li>
<li>系统中的其他构件中的过程在一个或多个事件中注册，当一个事件被触发，系统自动调用在这个事件中注册的所有过程。</li>
<li>这种风格的构件是一个模块，这些模块可以是一些过程，又可以是一些事件的集合。</li>
<li>不变量：事件的触发者并不知道哪些构件会被这些事件影响（观察者模式-Observer）</li>
<li>实例：数据库管理系统，用户界面</li>
</ul>
<h3 id="分层系统风格"><a href="#分层系统风格" class="headerlink" title="分层系统风格"></a>分层系统风格</h3><p>分层式体系结构，是按层次组织软件的一种软件体系结构</p>
<ul>
<li>一个分层风格的系统按照层次结构组织，每一层向它的上层提供服务，同时又是它的下层客户</li>
<li>连接件可以用层次间的交互协议来定义。每个独立层都要防止较高层直接访问较低层</li>
</ul>
<p>优点：</p>
<ol>
<li>系统易于改进和拓展</li>
<li>每一层的软件都易于重用，并可为某一层次提供多种可互换的具体实现</li>
<li>分层系统所支持的设计体现了不断增加的抽象层次</li>
<li>标准化支持</li>
<li>局部依赖性</li>
<li>可替换性</li>
</ol>
<p>缺点：</p>
<ol>
<li>应当如何界定层次间的划分是一个较为复杂的问题</li>
<li>更改行为的重叠</li>
<li>降低效率</li>
<li>不必要的工作</li>
<li>难以认可层的正确粒度</li>
</ol>
<h3 id="仓库风格和黑板风格（数据共享风格）"><a href="#仓库风格和黑板风格（数据共享风格）" class="headerlink" title="仓库风格和黑板风格（数据共享风格）"></a>仓库风格和黑板风格（数据共享风格）</h3><ul>
<li><p>仓库风格的体系结构由两个构件组成。一个中央数据结构，表示当前状态，一个独立构件的集合，对中央数据结构进行操作</p>
</li>
<li><p>在问题求解过程中，黑板上保存了所有的部分解，代表了问题求解的不同阶段</p>
</li>
<li><p>“黑板”模式即让专业们坐在真实黑板并一起工作，来解决一个问题</p>
</li>
<li><p>设计问题：黑板系统传统是应用在需要对数据做出复杂解释的信号处理中，这类系统包括语音和模式识别领域</p>
</li>
<li><p>解决方案：黑板体系结构实现的基本出发点，是已经存在一个对公共数据结构进行协同操作的独立程序集合。因此，黑板结构存在一个中心控制部件。</p>
</li>
</ul>
<p>标准的黑板型仓库模式系统：</p>
<ul>
<li>知识源</li>
<li>中央数据单元</li>
<li>控制单元</li>
</ul>
<p>优点：</p>
<ul>
<li>便于多客户共享大量数据，不用关心数据是何时出现的、谁提供的、怎样提供的</li>
<li>既便于添加新的作为知识源代理的应用程序，也便于扩展共享的黑板数据结构</li>
<li>可重用的知识源</li>
<li>支持容错性和健壮性</li>
</ul>
<p>缺点：</p>
<ul>
<li>不同的知识源代理</li>
<li>需要一定的同步锁机制</li>
<li>测试困难</li>
<li>不能有好的求解方案</li>
<li>低效</li>
<li>开发成本高</li>
</ul>
<p>仓库系统：</p>
<ul>
<li>构件：中心数据结构（仓库）和一些独立构件的集合</li>
<li>仓库和在系统中很重要的外部构件之间的相互作用</li>
<li>实例：需要使用一些复杂表征的信号处理系统</li>
</ul>
<h3 id="模型-视图-控制器风格"><a href="#模型-视图-控制器风格" class="headerlink" title="模型-视图-控制器风格"></a>模型-视图-控制器风格</h3><p>MVC结构是为那些需要为同样的数据提供多个视图的应用程序而设计的，很好地实现了数据层与表示层的分离，通常用于分布式应用系统的设计、分析中，以及用于确定系统各部分间的组织关系。对于界面设计可变性的需求，MVC把交互系统的组成分解成模型、视图、控制器三种部件。</p>
<ol>
<li>MVC模式<ul>
<li>MVC是许多交互和界面系统的构成基础，微软的MFC基础类，也遵循了MVC的思想</li>
<li>作为一种软件设计典范，MVC用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑</li>
</ul>
</li>
<li>模型、视图和控制类<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401122223306.png"></li>
</ol>
<p>MVC的实现：</p>
<ol>
<li>分析应用问题，对系统进行分离</li>
<li>设计和实现每个视图</li>
<li>设计和实现每个控制器</li>
<li>使用可安装和卸载的控制器</li>
</ol>
<h3 id="解释器风格（虚拟机风格）"><a href="#解释器风格（虚拟机风格）" class="headerlink" title="解释器风格（虚拟机风格）"></a>解释器风格（虚拟机风格）</h3><p>解释器风格通常被用于建立一种虚拟机，以弥合程序的语义与作为计算引擎的硬件的间隙。解释器风格适用于这样的应用程序，<strong>应用程序并不能直接运行在最合适的机器上，或者不能直接以最适合的语言执行</strong>。</p>
<p>优点：</p>
<ul>
<li>有助于应用程序的可移植性与程序设计语言的跨平台能力。</li>
<li>可以对未实现的硬件进行仿真。<br>缺点：<strong>额外的间接层次带来的系统性能的下降</strong></li>
</ul>
<p>案例：上下文关键字</p>
<h3 id="C-x2F-S风格——任务分配"><a href="#C-x2F-S风格——任务分配" class="headerlink" title="C&#x2F;S风格——任务分配"></a>C&#x2F;S风格——任务分配</h3><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401122226496.png"><br>网络通信软件的主要作用，是完成数据库服务器和客户端应用程序之间的数据传输。</p>
<p>优点：</p>
<ul>
<li>强大的数据操作和事务处理能力，模型思想简单，易于理解接受</li>
<li>系统的客户应用程序和服务器构件分别运行在不同的计算机上，系统中每台服务器都可以适合各构件的要求，这<strong>对于硬件和软件的变化显示出极大的适应性和灵活性</strong>，而且<strong>易于对系统进行扩充和缩小</strong></li>
<li>在C&#x2F;S体系结构中，系统中的功能构件充分隔离，客户应用程序的开发集中于数据的显示和分析，而数据库服务器的开发则集中于数据的管理，不必在每一个新的应用程序中都要对一个DBMS进行编码。将大的应用处理任务分布到许多通过网络连接的低成本计算机上，以<strong>节约大量费用</strong></li>
</ul>
<p>缺点：</p>
<ul>
<li>开发成本较高</li>
<li>客户端程序设计复杂</li>
<li>信息内容和形式单一</li>
<li>用户界面风格不一</li>
<li>软件移植困难</li>
<li>软件维护与升级困难</li>
<li>新技术不能轻易应用</li>
</ul>
<h3 id="三层客户-x2F-服务器结构风格"><a href="#三层客户-x2F-服务器结构风格" class="headerlink" title="三层客户&#x2F;服务器结构风格"></a>三层客户&#x2F;服务器结构风格</h3><p>传统的二层C&#x2F;S结构局限：</p>
<ol>
<li>单一服务器且以局域网为中心，难以拓展至大型企业广域网或因特网</li>
<li>软、硬件的组合及集成能力有限</li>
<li>客户机的负荷太重，难以管理大量的客户机，系统的性能容易变差</li>
<li>数据安全性不好</li>
</ol>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401122230760.png"><br>与二层C&#x2F;S结构相比，在三层C&#x2F;S体系结构中，增加了一个<strong>应用服务器</strong>，可以将整个应用逻辑驻留在应用服务器上，而只有表示层存在于客户机上。这种结构，被称为“瘦客户机”。</p>
<ul>
<li>表示层：应用的用户接口部分，担负着用户与应用之间的对话功能</li>
<li><ul>
<li>在变更用户界面时，只需改写显示控制和数据检查程序，而不影响其他两层</li>
</ul>
</li>
<li>功能层：应用的本体，用于将具体的业务处理逻辑编入程序</li>
<li><ul>
<li>功能层相当于应用的本体，用于将具体的业务处理逻辑编入程序</li>
</ul>
</li>
<li><ul>
<li>表示层与功能层之间的数据交往，要尽可能简洁</li>
</ul>
</li>
<li>数据层</li>
<li><ul>
<li>数据层就是数据库管理系统，负责管理对数据库数据的读写。数据库管理系统必须能迅速执行大量数据的更新和检索</li>
</ul>
</li>
<li><ul>
<li>三层C&#x2F;S的解决方案，是对这三层进行明确分割，并在逻辑上使其独立</li>
</ul>
</li>
</ul>
<p>优点：</p>
<ul>
<li>允许合理地划分三层结构的功能，使之在逻辑上保持相对独立性，从而使<strong>整个系统的逻辑结构更为清晰，能提高系统与软件的可维护性和可扩展性</strong></li>
<li>允许<strong>更灵活有效地选用相应的平台与硬件系统</strong>，使之在处理负荷能力上与处理特性上分别适应于结构清晰的三层，并且这些平台与各个组成部分可以具有良好的可升级性与开放性</li>
<li>三层C&#x2F;S结构中，应用的各层可以并行开发，各层也可以选择各自最适合的开发语言，使之能<strong>并行地而且是高效率地进行开发</strong>，达到较高的性能价格比，对每一层的处理逻辑的<strong>开发和维护也会更容易些</strong></li>
<li>允许<strong>充分利用功能层有效地隔离开表示层与数据层</strong>，未授权的用户难以绕过功能层而利用数据库工具或黑客手段去非法地访问数据层，这就为<strong>严格的安全管理</strong>奠定了坚实的基础，整个系统的管理层次也更加合理和可控制</li>
</ul>
<p>注意点：</p>
<ul>
<li>各层间的通信效率不高</li>
<li>设计时必须慎重考虑三层间的通信方法、通信频率及数据量</li>
</ul>
<h3 id="浏览器-x2F-服务器风格"><a href="#浏览器-x2F-服务器风格" class="headerlink" title="浏览器&#x2F;服务器风格"></a>浏览器&#x2F;服务器风格</h3><p>浏览器&#x2F;Web服务器&#x2F;数据库服务器</p>
<p>优点：</p>
<ul>
<li>系统安装、修改和维护全在服务器端解决，用户在使用时仅需要浏览器便可运行全部的模块，可以在运行时自动升级</li>
<li>提供了异种机、异种网、异种应用服务器的联机、联网、统一服务的最现实的开放性基础</li>
</ul>
<p>缺点：</p>
<ul>
<li>缺乏对动态页面的支持能力，没有集成有效的数据库处理功能</li>
<li>系统扩展能力差，安全性难以控制</li>
<li>在数据查询等响应速度上，要远远低于C&#x2F;S体系结构</li>
<li>的数据提交一般以页面为单位，数据的动态交互性不强，不利于在线事务处理（OLTP）应用</li>
</ul>
<h3 id="C-x2F-S与B-x2F-S混合风格结构"><a href="#C-x2F-S与B-x2F-S混合风格结构" class="headerlink" title="C&#x2F;S与B&#x2F;S混合风格结构"></a>C&#x2F;S与B&#x2F;S混合风格结构</h3><p>B&#x2F;S与C&#x2F;S混合软件体系结构是一种典型的异构体系结构。</p>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><p>UML图之间的关系：需求模型与设计模型</p>
<p>UML建模原则：</p>
<ul>
<li>适当增加<strong>注释</strong></li>
<li>画图应<strong>简化</strong>系统理解而不是增加工作量</li>
<li>注意<strong>折衷</strong></li>
<li>保持图的<strong>一致性</strong></li>
<li><strong>不要画多余的图</strong></li>
</ul>
<h3 id="软件体系结构建模概述"><a href="#软件体系结构建模概述" class="headerlink" title="软件体系结构建模概述"></a>软件体系结构建模概述</h3><ul>
<li><strong>统一建模语言（Unified Modeling Language，UML）是一种为面向对象系统的产品进行说明、可视化、编制文档的一种标准语言，是非专利的第三代建模和规约语言。</strong></li>
<li>UML具有广泛的建模能力，在消化、吸收、提炼现有的软件建模语言的基础上提出，集百家之长，是软件建模语言的集大成者</li>
</ul>
<p>软件体系结构模型<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401131703244.png"></p>
<h3 id="UML概述"><a href="#UML概述" class="headerlink" title="UML概述"></a>UML概述</h3><p>UML：</p>
<ul>
<li>标准的工业化设计语言</li>
<li>把复杂的问题分解成易于理解的小问题</li>
<li>建模是开发优秀软件的所有活动中核心部分之一，实现对系统的结构的可视化控制</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401131723197.png"></p>
<ul>
<li><strong>用例图</strong></li>
<li><strong>类图</strong></li>
<li><em>包图</em></li>
<li><em>顺序图</em></li>
<li><em>状态图</em></li>
<li><em>活动图</em></li>
<li><em>组件图</em></li>
<li><em>部署图</em></li>
</ul>
<p>UML的结构：</p>
<ul>
<li><strong>模型元素</strong>(Model element)</li>
<li><ul>
<li>模型元素包括<strong>事物</strong>以及事物与事物之间的<strong>联系</strong></li>
</ul>
</li>
<li><ul>
<li>每一个模型元素都有一个与之相对应的<strong>图形元素</strong></li>
</ul>
</li>
<li><ul>
<li>无论在哪个图中，同一个模型元素都保持<strong>相同的意义和符号</strong></li>
</ul>
</li>
<li><strong>通用机制</strong>(General mechanism)</li>
<li><ul>
<li>额外的<strong>注释、修饰和语义</strong>等</li>
</ul>
</li>
<li><ul>
<li>包括<strong>规格说明、修饰、公共分类和扩展机制</strong>四种</li>
</ul>
</li>
</ul>
<p><strong>UML的特点和用途</strong>：</p>
<ul>
<li>统一标准</li>
<li>面向对象的特性</li>
<li>提出了新的概念</li>
<li>独立于过程</li>
<li>对系统的逻辑模型和实现模型，都能清晰的表示，可以用于复杂软件系统的建模</li>
</ul>
<h3 id="UML中的结构建模"><a href="#UML中的结构建模" class="headerlink" title="UML中的结构建模"></a>UML中的结构建模</h3><ul>
<li>结构图显示建模系统的<strong>静态结构</strong>。关注系统的元件，<strong>无需考虑时间</strong>，在系统内，静态结构通过显示类型和实例进行传播</li>
<li>除了显示<strong>系统类内部结构型</strong>和它们的<strong>实例</strong>，结构图至少也显示了这些元素间的一些<strong>关系</strong></li>
</ul>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>类的定义：</p>
<ul>
<li><strong>类(Class)封装了数据和行为</strong>，是面向对象的重要组成部分，它是<strong>具有相同属性、操作、关系的对象集合的总称</strong></li>
<li>在系统中，<strong>每个类具有一定的职责</strong>，职责指的是类所担任的任务，即类要完成什么样的功能，要承担什么样的义务。<strong>一个类可以有多种职责，设计得好的类一般只有一种职责（单一职责原则）</strong>，在定义类的时候，将类的职责分解成为类的属性和操作（即方法）。</li>
<li><strong>类的属性即类的数据职责，类的操作即类的行为职责</strong>。</li>
</ul>
<p>类图定义：类图使用需要出现在系统内的不同的类来描述系统的<strong>静态结构</strong>，类图<strong>包含类和它们之间的关系</strong>，它描述系统内所声明的类，但它没有描述系统运行时类的行为</p>
<p>类图表示：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132058776.png"></p>
<p>定义属性：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132059351.png"></p>
<p>定义操作：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132100261.png"></p>
<h5 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h5><ul>
<li><strong>关联关系(Association)<strong>是类与类之间最常用的一种关系，它是一种结构化关系，</strong>用于表示一类对象与另一类对象之间有联系</strong>。</li>
<li>在UML类图中，<strong>用实线连接有关联的对象所对应的类</strong>，在使用Java、C#和C++等编程语言实现关联关系时，<strong>通常将一个类的对象作为另一个类的属性</strong>。</li>
<li>在使用类图表示关联关系时可以<strong>在关联线上标注角色名</strong>。</li>
</ul>
<p>关联关系：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132103868.png"></p>
<p>双向关联：默认情况下，关联是<strong>双向的</strong><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132103107.png"></p>
<p>单向关联：类的关联关系也可以是单向的，单向关联用<strong>带箭头的实线</strong>表示<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132104317.png"></p>
<p>自关联：<strong>一些类的属性对象类型为该类本身</strong><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132104642.png"></p>
<p>多重性关联：多重性关联关系又称为**重数性关联关系(Multiplicity)**，表示一个类的对象与另一个类的对象连接的个数。在UML中多重性关系可以直接在关联直线上增加一个数字表示与之对应的另一个类的对象的个数。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132106133.png"></p>
<blockquote>
<p>一个表单包含一个按钮，一个按钮可以被零到多个表单包含<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132107415.png"></p>
</blockquote>
<h5 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h5><ul>
<li><strong>聚合关系(Aggregation)<strong>表示一个</strong>整体与部分的关系</strong>。通常在定义一个整体类后，再去分析这个整体类的组成结构，从而找出一些成员类，该整体类和成员类之间就形成了聚合关系。</li>
<li>在聚合关系中，<strong>成员类是整体类的一部分</strong>，即成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。<strong>在UML中，聚合关系用带空心菱形的直线表示</strong></li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132110491.png"></p>
<h5 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h5><ul>
<li>组合关系(Composition)也表示类之间整体和部分的关系，但是组合关系中<strong>部分和整体具有统一的生存期</strong>。一旦整体对象不存在，部分对象也将不存在，部分对象与整体对象之间具有同生共死的关系。</li>
<li>在组合关系中，成员类是整体类的一部分，而且整体类可以控制成员类的生命周期，即成员类的存在依赖于整体类。<strong>在UML中，组合关系用带实心菱形的直线表示</strong>。</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132143867.png"></p>
<h5 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h5><ul>
<li>依赖关系(Dependency)是一种<strong>使用关系</strong>，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。大多数情况下，<strong>依赖关系体现在某个类的方法使用另一个类的对象作为参数</strong>。</li>
<li><ul>
<li><strong>方法参数、局部变量、调用静态方法</strong></li>
</ul>
</li>
<li><strong>在UML中，依赖关系用带箭头的虚线表示</strong>，由依赖的一方指向被依赖的一方。</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132145877.png"></p>
<h5 id="泛化关系"><a href="#泛化关系" class="headerlink" title="泛化关系"></a>泛化关系</h5><ul>
<li>泛化关系(Generalization)也就是继承关系，也称为“is-a-kind-of”关系，泛化关系用于描述<strong>父类与子类之间的关系</strong>，父类又称作基类或超类，子类又称作派生类。<strong>在UML中，泛化关系用带空心三角形的直线来表示。</strong></li>
<li>在代码实现时，使用<strong>面向对象的继承机制</strong>来实现泛化关系，如在Java语言中使用extends关键字、在C++&#x2F;C#中使用冒号“：”来实现。</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132147261.png"></p>
<h5 id="接口与实现关系"><a href="#接口与实现关系" class="headerlink" title="接口与实现关系"></a>接口与实现关系</h5><p>接口之间也可以有与类之间关系类似的继承关系和依赖关系，但是接口和类之间还存在一种实现关系(Realization)，在这种关系中，类实现了接口，类中的操作实现了接口中所声明的操作。<strong>在UML中，类与接口之间的实现关系用带空心三角形的虚线来表示。</strong></p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132149606.png"></p>
<h5 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h5><p>某C&#x2F;S系统需要提供注册功能，注册用例基本描述如下：</p>
<ul>
<li>用户输入新帐号，系统检测该帐号是否已存在，如果不存在则可注册成功，否则提示“帐号已存在”，用户再次输入帐号；</li>
<li>用户输入其他个人信息；</li>
<li>系统保存用户个人信息；</li>
<li>用户个人信息包括帐号、密码、姓名、性别、年龄、电话、电子邮箱。</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132152584.png"></p>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><ul>
<li>类图是UML中最基本也是最重要的一种视图，用来刻画软件中<strong>类等元素的静态结构和关系</strong>。</li>
<li>在大多数UML模型中，这些类型包括<strong>类，接口、数据类型、组件</strong>。</li>
<li>类（Class）是来描述<strong>具有相同特征、约束、语义的一类对象</strong>，这些对象具有<strong>共同的属性和操作</strong>。</li>
<li><ul>
<li>类图中的一个类。可以简单地只给出类名，也可以具体列出该类拥有的成员变量和方法，甚至更详细地描述可见性、方法参数、变量类型等信息。</li>
</ul>
</li>
<li>类的UML表示，是一个<strong>长方形</strong>，垂直地分为<strong>三个区</strong>。当图描述仅仅用于显示分类器间关系的高层细节时，下面的两个区域是不必要的。</li>
<li><ul>
<li>第一层显示类的<strong>名称</strong>，如果是抽象类就要用斜体显示。</li>
</ul>
</li>
<li><ul>
<li>第二层是类的<strong>特性</strong>，通常就是字段和属性。</li>
</ul>
</li>
<li><ul>
<li>第三层是类的<strong>操作</strong>，通常是方法和行为。</li>
</ul>
</li>
</ul>
<h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p>抽象类（Abstract class）是指一个类只提供操作明，而不对其进行实现。</p>
<ul>
<li>对这些操作的实现，可以由其子类进行，并且不同的子类可以对同一操作具有不同的实现。</li>
<li>抽象类和类的符号区别，在于<strong>抽象类的名称用斜体字符表示</strong>。</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132156656.png"></p>
<h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><ul>
<li>“飞翔”矩形框表示一个接口图，与类图的区别，主要是<strong>顶端有接口（Interface）的显示</strong>，第一行是接口名称，第二行是接口方法。</li>
<li>接口还有另一种表示方法，俗称棒棒糖表示法，就是唐老鸭类实现了“讲人话”的接口。</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132157861.png"></p>
<h5 id="关联关系-1"><a href="#关联关系-1" class="headerlink" title="关联关系"></a>关联关系</h5><ul>
<li>关联关系（Association）描述了<strong>类的结构之间的关系</strong>。</li>
<li><ul>
<li>具有方向、名字、角色和多重性等信息。当关联是双向的，那么就可以用无向连线表示。</li>
</ul>
</li>
<li>一般的关联关系语义较弱，也有两种语义较强，分别是<strong>聚合与组合</strong>。</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132158583.png"></p>
<h5 id="依赖关系-1"><a href="#依赖关系-1" class="headerlink" title="依赖关系"></a>依赖关系</h5><p>两个类之间存在依赖关系（Dependency），表明<strong>一个类使用或需要知道另一个类中包含的信息</strong>。</p>
<ul>
<li><ul>
<li>有多种表现形式，例如，绑定（bind）、友元（friend）等。</li>
</ul>
</li>
<li><ul>
<li>模板类Stack<T>定义了栈相关的操作；IntStack将参数T与实际类型int绑定，使得所有操作都针对int类型的数据。</li>
</ul>
</li>
<li><strong>依赖关系使用虚线箭头</strong>，表示“动物”、“氧气”与“水”之间。</li>
<li><ul>
<li>动物有几大特征，比如有新陈代谢，能繁殖。而动物要有生命，需要氧气，水<br>以及食物等。</li>
</ul>
</li>
<li><ul>
<li>也就是说，动物依赖于氧气和水。之间是依赖关系（dependency），用虚线箭头来表示。</li>
</ul>
</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132159914.png"></p>
<h5 id="聚合关系-1"><a href="#聚合关系-1" class="headerlink" title="聚合关系"></a>聚合关系</h5><ul>
<li>聚合关系（Aggrengation）表明，两个类的实例之间存在一种<strong>拥有或属于关系</strong>，可以看作是一种较弱的整体-部分关系。</li>
<li><ul>
<li>在一个聚合关系中，子类实例可以比父类存在更长的时间。</li>
</ul>
</li>
<li><ul>
<li>为了表现一个聚合关系，画一条从父类到部分类的实线，并在父类的关联末端画一个未填充棱形。</li>
</ul>
</li>
<li>例如，“大雁”和“雁群”这两个类。大雁是群居动物，每只大雁都属于一个雁群，一个雁群可以有多只大雁。所以，它们之间就满足聚合关系。</li>
<li><ul>
<li><strong>聚合表示一种弱的“拥有”关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分。</strong></li>
</ul>
</li>
<li><ul>
<li>聚合关系用<strong>空心的菱形加上实线箭头表示</strong>。</li>
</ul>
</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132202547.png"></p>
<h5 id="合成关系"><a href="#合成关系" class="headerlink" title="合成关系"></a>合成关系</h5><ul>
<li>合成（Composition）是一种<strong>强的“拥有”关系</strong>，体现了严格的部分和整体的关系，部分和整体的生命周期一样。</li>
<li><ul>
<li>合成关系用<strong>实心的菱形加上实线箭头</strong>来表示。另外，合成关系的连线两端，还有一个<strong>数字“1”和数字“2”</strong>，这被称为基数。</li>
</ul>
</li>
<li>表明<strong>这一端的类可以有几个实例</strong>。“鸟”和“翅膀”这两个类中，鸟和翅膀类似整体和部分的关系，并且翅膀和鸟的生命周期是相同的，在这里“鸟”类和其“翅膀”类就是合成关系。</li>
<li><ul>
<li>一个鸟应该有两支翅膀。如果一个类可能有无数个实例，则就用“n”来表示。关联关系，聚合关系也可以有基数的。</li>
</ul>
</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132209317.png"></p>
<h5 id="泛化关系-1"><a href="#泛化关系-1" class="headerlink" title="泛化关系"></a>泛化关系</h5><p>泛化关系（Generalization）在面向对象中一般称为<strong>继承关系</strong>，存在于<strong>父类与子类、父接口与子接口之间</strong>。</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132210862.png"></p>
<h4 id="包图"><a href="#包图" class="headerlink" title="包图"></a>包图</h4><ul>
<li>包是一种把元素组织到一起的通用机制，包可以嵌套于其他包中。</li>
<li>包图用于描述包与包之间的关系，包的图标是一个带标签的文件夹。</li>
</ul>
<p>两种组包方式：</p>
<ul>
<li><strong>根据系统分层架构组包</strong>（推荐使用）；</li>
<li>根据系统业务功能模块组包<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132215411.png"></li>
</ul>
<h5 id="引入关系"><a href="#引入关系" class="headerlink" title="引入关系"></a>引入关系</h5><ul>
<li>一个包中的类可以被另一个指定包（以及嵌套于其中的那些包）中的类<strong>引用</strong>。</li>
<li>引入关系是依赖关系的一种，需要在依赖线上增加一个**&lt;<import>&gt;**衍型，包之间一般依赖关系都属于引入关系。</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132212239.png"></p>
<h5 id="泛化关系-2"><a href="#泛化关系-2" class="headerlink" title="泛化关系"></a>泛化关系</h5><p>表示一个包继承了另一个包的内容，同时又补充自己增加的内容。</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132212421.png"></p>
<h5 id="嵌套关系"><a href="#嵌套关系" class="headerlink" title="嵌套关系"></a>嵌套关系</h5><p>一个包中可以包含若干个子包，构成了包的嵌套层次结构。</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132213275.png"></p>
<h4 id="组件图"><a href="#组件图" class="headerlink" title="组件图"></a>组件图</h4><ul>
<li>组件图又称为构件图(Component Diagram) 。<strong>组件图中通常包括组件、接口，以及各种关系</strong>。组件图显示<strong>组件以及它们之间的依赖关系</strong>，它可以用来显示程序代码如何分解成模块或组件。一般来说，<strong>组件就是一个实际文件</strong>，可以有以下几种类型：</li>
<li><ul>
<li><strong>源代码组件</strong>：一个源代码文件或者与一个包对应的若干个源代码文件。</li>
</ul>
</li>
<li><ul>
<li><strong>二进制组件</strong>：一个目标码文件，一个静态的或者动态的库文件。</li>
</ul>
</li>
<li><ul>
<li><strong>可执行组件</strong>：在一台处理器上可运行的一个可执行的程序单位，即所谓可执行程序。</li>
</ul>
</li>
<li>组件图可以用来<strong>显示编译、链接或执行时组件之间的依赖关系</strong>，以及<strong>组件的接口和调用关系</strong>。</li>
<li>组件间的关系有两种：<strong>泛化关系和依赖关系</strong>，如果两个不同组件中的类存在泛化关系或依赖关系，那么两个组件之间的关系就表示为泛化关系或依赖关系。</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132218353.png"></p>
<p>组件图组成元素：</p>
<ul>
<li>组件：系统中<strong>可以替换的部分</strong>，一般对应一个实际文件，如exe、jar、dll等文件，它遵循并提供了一组接口的实现。</li>
<li>接口：<strong>一组操作的集合</strong>，它指明了由类或组件所请求或者所提供的服务。</li>
<li>部件：<strong>组件的局部实现</strong>。</li>
<li>端口：<strong>被封装的组件与外界的交互点</strong>，遵循指定接口的组件通过它来收发消息。</li>
<li>连接件：在特定语境下组件中<strong>两个部件之间或者两个端口之间的通信关系</strong>。</li>
</ul>
<p>供(Provided)接口与需(Required)接口：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132220103.png"></p>
<p>绘制技巧：</p>
<ul>
<li>当需要把系统<strong>分成若干组件（构件）</strong>，希望<strong>借助接口或组件将系统分解为低层结构并表示其相互关系</strong>时需要使用组件图。</li>
<li>在绘制组件图时，应该注意侧重于描述系统的静态实现视图的一个方面，<strong>图形不要过于简化</strong>，应该为组件图取一个直观的名称，在绘制时避免产生线的交叉。</li>
<li>注意<strong>组件的粒度</strong>，粒度过细的构件将导致系统过于庞大，会给版本管理带来问题。</li>
</ul>
<h5 id="组件图分析实例"><a href="#组件图分析实例" class="headerlink" title="组件图分析实例"></a>组件图分析实例</h5><p>在某销售终端系统中，客户端收银机可以通过销售消息接口与销售服务器相连。考虑到网络可能不可靠，需要提供一个消息队列组件。在网络环境畅通时收银机直接与服务器相连；如果网络不可靠则与消息队列交互，当网络可用时队列再与服务器交互。服务器分解为两个主要组件，主要包括事务处理组件和记账驱动组件，记账驱动组件需要和记账系统交互。绘制系统组件图。</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132221417.png"></p>
<h5 id="组件图小结"><a href="#组件图小结" class="headerlink" title="组件图小结"></a>组件图小结</h5><ul>
<li>构件图用于<strong>静态建模</strong>，是表示<strong>构件类型的组织</strong>以及各种<strong>构件之间依赖关系</strong>的图。</li>
<li>由于基于构件的软件开发日益普及和应用，UML对构件图进行了较大的改进。</li>
<li><strong>构件（Component）是系统中遵从一组接口且提供其实现的物理的、可替换的部分</strong>。</li>
<li>随着面向对象技术的引用，软件系统被分成若干个子系统、构件。</li>
</ul>
<h4 id="部署图"><a href="#部署图" class="headerlink" title="部署图"></a>部署图</h4><ul>
<li>部署图(Deployment Diagram)，也称为<strong>实施图</strong>，它和组件图一样，是面向对象系统的物理方面建模的两种图之一。组件图是说明组件之间的逻辑关系的，而部署图则是在此基础上更进一步，<strong>描述系统硬件的物理拓扑结构及在此结构上执行的软件</strong>。部署图可以显示计算节点的拓扑结构和通信路径、节点上运行的软件组件。</li>
<li>在UML中，部署图显示了<strong>系统的硬件和安装在硬件上的软件</strong>，以及<strong>用于连接异构计算机之间的中间件</strong>。部署图通常被认为是一个<strong>网络图</strong>或者<strong>物理架构图</strong>。</li>
</ul>
<p>部署图实例：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132224751.png"></p>
<p>部署图元素：</p>
<ul>
<li>节点和连接：<strong>节点(Node)代表一个物理设备</strong>。在 UML 中，使用一个<strong>立方体</strong>表示一个节点。<strong>节点之间的连线表示系统之间进行交互的通信路径</strong>，在 UML 中被称为<strong>连接</strong>。</li>
<li>组件：在部署图中，<strong>组件代表可执行的物理代码模块</strong>，如一个可执行程序，逻辑上它可以与类或包对应。</li>
</ul>
<p>绘制技巧：</p>
<ul>
<li>部署图用于表示<strong>何者部署于何处</strong>，任何复杂的部署都可以使用部署图描述。</li>
<li>一个部署图只是系统静态部署视图的一个图形表示，<strong>在单个部署图中不必捕获系统部署视图的所有内容</strong>。</li>
<li>部署图一般用于：</li>
<li><ul>
<li>对<strong>嵌入式系统建模</strong>（硬件之间的交互）</li>
</ul>
</li>
<li><ul>
<li>对<strong>客户端&#x2F;服务器系统建模</strong>（用户界面与数据的分离）</li>
</ul>
</li>
<li><ul>
<li>对<strong>分布式系统建模</strong>（多级服务器）</li>
</ul>
</li>
</ul>
<h5 id="部署图实例分析"><a href="#部署图实例分析" class="headerlink" title="部署图实例分析"></a>部署图实例分析</h5><p>某大型商场的信息管理系统是由一个数据库服务器、中央服务器、每个楼层的楼层服务器、各柜台的收款机和各个部门的计算机终端组成的局域网络，它们分别负责商场数据存储、数据的汇总与分析、当日数据的保存与整理、销售信息录入和进销存信息处理等各种业务处理。用部署图描述该系统在不同硬件上的配置情况。</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132230749.png"></p>
<h5 id="部署图小结"><a href="#部署图小结" class="headerlink" title="部署图小结"></a>部署图小结</h5><ul>
<li>部署图（Component Diagram）描述的是<strong>系统运行时的结构</strong>，展示了<strong>硬件的配置</strong>及<strong>其软件如何部署到网络结构中</strong>。</li>
<li><ul>
<li>一个系统模型，只有一个部署图，部署图通常用来帮助理解分布式系统。</li>
</ul>
</li>
<li>部署图用于静态建模，是表示<strong>运行时过程节点结构、描述软件与硬件是如何映射的、构件实例及其对象结构</strong>的图。</li>
</ul>
<h3 id="UML中的行为建模"><a href="#UML中的行为建模" class="headerlink" title="UML中的行为建模"></a>UML中的行为建模</h3><ul>
<li>行为建模被称为<strong>动态建模</strong>，主要用来刻画<strong>系统中的动态行为、过程、步骤</strong>。</li>
<li>UML行为建模中提供的视图，可以从不同的侧面来描述软件系统的动态过程</li>
<li><ul>
<li>例如，业务或算法过程与步骤、多个对象为完成一个场景而进行的交互、消息传递的过程、一个对象在生存周期中根据收到的不同事件进行响应的过程等。</li>
</ul>
</li>
</ul>
<h4 id="用例建模技术"><a href="#用例建模技术" class="headerlink" title="用例建模技术"></a>用例建模技术</h4><ul>
<li><p>用例图是被称为参与者的外部用户所能观察到的系统功能的<strong>模型图</strong>。</p>
</li>
<li><p>用例图列出<strong>系统中的用例和系统外的参与者</strong>，并示哪个参与者参与了哪个用例的执行（或称为发起了个用例）。</p>
</li>
<li><ul>
<li><strong>用例图多用于静态建模阶段（主要是业务建模和需求建模）</strong>。</li>
</ul>
</li>
<li><p>用例建模（Use Case Modeling）是使用<strong>用例</strong>的方法来描述系统的<strong>功能需求</strong>的过程，<strong>用例建模促进并鼓励了用户参与</strong>，这是确保项目成功的关键因素之一。</p>
</li>
<li><p>用例建模主要包括以下两部分内容：</p>
</li>
<li><ul>
<li><strong>用例图(Use Case Diagram)</strong></li>
</ul>
</li>
<li><ul>
<li><strong>用例描述文档 (Use Case Specification)</strong></li>
</ul>
</li>
</ul>
<p>用例建模步骤：</p>
<ol>
<li>识别执行者<ul>
<li>执行者——Actor</li>
<li>定义：在<strong>系统之外</strong>，透过<strong>系统边界</strong>与系统进行<strong>有意义交互</strong>的<strong>任何事物</strong>。</li>
<li>引入执行者的目的：<strong>帮助确定系统边界</strong>。</li>
</ul>
</li>
<li>识别用例<ul>
<li>用例是在<strong>系统中执行</strong>的<strong>一系列动作</strong>，这些动作将生成<strong>特定执行者</strong>可见的<strong>价值结果</strong>。一个用例定义<strong>一组用例实例</strong>。</li>
</ul>
</li>
<li>绘制用例图</li>
<li>书写用例文档</li>
<li>检查用例模型</li>
</ol>
<h5 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h5><p>用例要点：</p>
<ul>
<li>有意义的目标</li>
<li>价值结果由系统生成</li>
<li>业务语言，用户观点</li>
<li>注意用例的命名</li>
<li>用例的“粒度</li>
</ul>
<p>执行者与用例之间的关联关系&#x2F;通信关系：在用例图中，执行者和用例之间进行交互，相互之间的关系用一根直线来表示</p>
<p>执行者之间的<strong>泛化</strong>关系：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132254504.png"></p>
<p>用例之间的关系：</p>
<ul>
<li>包含关系：描述在<strong>多个用例中都有的公共行为</strong>，由用例A指向用例B，表示用例A中使用了用例B中的行为或功能，包含关系是通过在依赖关系上应用**&lt;<include>&gt;**构造型（衍型）来表示的<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132256962.png"></li>
<li>拓展关系：在扩展（extend）关系中，基础用例(Base)中定义有一至多个已命名的扩展点，扩展关系是指将扩展用例(Extension)的事件流在一定的条件下按照相应的扩展点插入到基础用例(Base)中。</li>
<li><ul>
<li>扩展用例可以<strong>在基用例之上添加新的行为</strong>，但是基用例必须声明某些特定的“扩展点”，并且扩展用例只能在这些扩展点上扩展新的行为。</li>
</ul>
</li>
<li><ul>
<li>扩展关系是通过在依赖关系上应用**&lt;<extend>&gt;**构造型（衍型）来表示的。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132258520.png"></li>
</ul>
</li>
<li>泛化关系：</li>
<li><ul>
<li>当多个用例共同拥有一种类似的结构和行为的时候，可以<strong>将它们的共性抽象成为父用例</strong>，其他的用例作为泛化关系中的子用例。</li>
</ul>
</li>
<li><ul>
<li>在用例的泛化关系中，子用例是父用例的一种特殊形式，<strong>子用例继承了父用例所有的结构、行为和关系</strong>。</li>
</ul>
</li>
<li><ul>
<li>泛化关系一般很少使用。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132259842.png"></li>
</ul>
</li>
</ul>
<h5 id="实例：酒店"><a href="#实例：酒店" class="headerlink" title="实例：酒店"></a>实例：酒店</h5><p>某酒店订房系统描述如下：</p>
<ol>
<li><strong>顾客</strong>可以选择<em>在线预订</em>，也可以直接去酒店通过<strong>前台服务员</strong>预订；</li>
<li><strong>前台服务员</strong>可以利用系统直接在<em>前台预订房间</em>；</li>
<li>不管采用哪种预订方式，都需要在预订时<em>支付相应订金</em>；</li>
<li>前台预订可以<em>通过现金或信用卡的形式进行订金支付</em>，但是网上预订只能通过信用卡进行支付；</li>
<li>利用信用卡进行支付时需要和<strong>信用卡系统</strong>进行通信；</li>
<li><strong>客房部经理</strong>可以随时<em>查看客房预订情况</em>和<em>每日收款情况</em>。<br>构造该系统的用例模型。</li>
</ol>
<p>解决方案：加粗为<strong>执行者</strong>，斜体为<em>用例</em></p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132303266.png"></p>
<h5 id="用例文档"><a href="#用例文档" class="headerlink" title="用例文档"></a>用例文档</h5><ul>
<li>用例是文本文档，而非图形</li>
<li>用例建模主要是编写文本的活动，而非制图</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132303206.png"></p>
<p>用例的内容：</p>
<ul>
<li><strong>用例编号</strong></li>
<li><strong>用例名</strong></li>
<li><strong>执行者</strong></li>
<li><strong>前置条件</strong></li>
<li><strong>后置条件</strong></li>
<li>涉众利益</li>
<li><strong>基本路径</strong><ol>
<li>××××</li>
<li>××××</li>
<li>××××</li>
</ol>
</li>
<li>扩展路径</li>
<li>2a.××××：</li>
<li><ul>
<li>2a1….×××××</li>
</ul>
</li>
<li>字段列表</li>
<li>业务规则</li>
<li>非功能需求</li>
<li>设计约束</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132307065.png"></p>
<p>前置、后置条件:</p>
<ul>
<li>开始用例前所必需的系统及其环境的状态</li>
<li>用例成功结束后系统应该具备的状态</li>
<li><strong>注意：系统必须能检测到</strong></li>
</ul>
<p>基本路径：客户最想看到、最关心的路径。把基本路径单独分离，凸显用例的核心价值。</p>
<ul>
<li>只书写“可观测”的（说人话）</li>
<li>使用主动语句</li>
<li>句子必须以执行者或系统作为主语</li>
<li>每一句都要朝目标迈进</li>
<li>分支和循环</li>
<li>不要涉及界面细</li>
</ul>
<p>拓展路径：注意意外和分支</p>
<ul>
<li>替换路径</li>
<li>异常路径</li>
</ul>
<h4 id="顺序图"><a href="#顺序图" class="headerlink" title="顺序图"></a>顺序图</h4><ul>
<li>UML顺序图一般<strong>用于确认和丰富一个使用情境的逻辑</strong>。</li>
<li>一个使用情境的逻辑或是<strong>一个用例的一部分</strong>；或是<strong>一条扩展路径</strong>；或是<strong>一个贯穿单个用例的完整路径</strong>，例如动作基本过程的逻辑描述；或是<strong>动作的基本过程的一部分再加上一个或多个的备用情境的逻辑描述</strong>；或是<strong>包含在几个用例中的路径</strong>。</li>
<li>顺序图将交互关系表现为一个二维图，<strong>纵向是时间轴</strong>，时间沿竖线向下延伸。<strong>横向轴代表了在协作中各独立对象的类元角色</strong>，类元角色的活动用生命线表示。</li>
</ul>
<p>示例：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132312872.png"></p>
<p>组成元素：</p>
<ul>
<li><strong>生命线用一条纵向虚线表示</strong>。</li>
<li>在UML中，<strong>对象表示为一个矩形</strong>，其中<strong>对象名称标有下划线</strong>。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132314718.png"></li>
<li><strong>激活是过程的执行</strong>，包括等待过程执行的时间。在顺序图中<strong>激活部分替换生命线，使用长条的矩形表示</strong>。</li>
<li><strong>消息是对象之间的通信</strong>，是两个对象之间的单路通信，是从发送者到接收者之间的控制信息流。<strong>消息在顺序图中由有标记的箭头表示</strong>，箭头从一个对象的生命线指向另一个对象的生命线，消息按时间顺序在图中从上到下排列。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132315403.png"></li>
<li>在顺序图中，<strong>对象安排在X轴</strong>。启动交互的对象放在最左边，随后放入消息的对象放在启动交互对象的右边。交互中对象发送和接收的<strong>消息沿着Y轴以时间增加的次序放置</strong>。在顺序图中，有的消息对应于激活，表示它将会激活一个对象，这种消息称为**调用消息(Call Message)<strong>；如果消息没有对应激活框，表示它不是一个调用消息，不会引发其他对象的活动，这种消息称为</strong>发送消息(SendMessage)**。</li>
</ul>
<p>消息：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132318912.png"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132318587.png"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132319052.png"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132319274.png"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132319855.png"></p>
<ul>
<li>对象间的通信，用对象生命线之间的水平消息线来表示，消息箭头的形状，表明消息的类型（同步、异步或简单）。</li>
<li><ul>
<li>当收到消息时，接收对象立即开始执行活动，即对象被激活了。</li>
</ul>
</li>
<li><ul>
<li>激活用对象生命线上的细长矩形框表示。消息通常用消息名和参数表来标识。</li>
</ul>
</li>
<li>消息还可以带有条件表达式，用以表示分支或决定是否发送消息。</li>
<li><ul>
<li>如果用条件表达式表示分支，则会有若干个互斥的箭头，就是说，在某一时刻仅可发送分支中的一个消息。</li>
</ul>
</li>
<li><ul>
<li>一个顺序图显示了，一系列的对象和这些对象之间发送和接收的消息。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132331156.png"></li>
</ul>
</li>
</ul>
<p>交互片段：一个复杂的顺序图可以划分为几个小块，每一个小块称为一个交互片段。每个交互片段由一个大方框包围，其名称显示在方框左上角的间隔区内，表示该顺序图的信息。常用操作符如下：</p>
<ul>
<li>alt:多条路径，条件为真时执行。</li>
<li>opt:任选，仅当条件为真时执行。</li>
<li>par:并行，每一片段都并发执行。</li>
<li>loop:循环，片段可多次执行。</li>
<li>critical:临界区，只能有一个线程对它立即执行。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132319934.png"></li>
</ul>
<p>顺序图作用：</p>
<ul>
<li>对于<strong>业务人员</strong>，顺序图可显示不同的业务对象如何交互，对于交流当前业务如何进行很有用。除记录组织的当前事件外，一个业务级的顺序图能被当作一个需求文件使用，为实现一个未来系统传递需求。</li>
<li>对于<strong>需求分析人员</strong>，顺序图能通过提供一个深层次的表达，把用例带入下一层次。通常用例被细化为一个或者更多的顺序图。顺序图的主要用途之一，是把用例表达的需求，转化为进一步、更深层次的精细表达。</li>
<li>对于<strong>技术人员</strong>，顺序图在记录一个未来系统的行为应该如何表现时非常有用。在设计阶段，架构师和开发者能使用顺序图挖掘出系统对象间的交互，进一步完善整个系统的设计。</li>
</ul>
<p>顺序图绘制技巧：</p>
<ul>
<li><strong>以用例为单位创建顺序图</strong>，针对每个用例，考察为完成它所描述的功能需要哪些对象的操作参与执行，并且进一步考察这些操作的执行需要通过消息而引起其他哪些对象操作的执行。把这些对象以及参与交互的执行者组织到一个顺序图中。</li>
<li><strong>理论上需要为每一个用例创建一个顺序图</strong>，但是<strong>如果一个用例的交互对象很简单可以不需要创建顺序图</strong>。</li>
<li>如果需要考察<strong>单个用例内部多个对象的行为</strong>可以使用<strong>顺序图</strong>；</li>
<li>如果需要考察<strong>单个对象的行为</strong>就需要使用<strong>状态图</strong>；</li>
<li>如果需要考察<strong>跨用例或者跨线程的行为</strong>就需要考虑使用<strong>活动图</strong>。</li>
</ul>
<h5 id="顺序图分析实例"><a href="#顺序图分析实例" class="headerlink" title="顺序图分析实例"></a>顺序图分析实例</h5><p>绘制图书管理系统“借书”用例的顺序图（业务模型）。图书管理员打开借书界面，输入借书信息并提交借书请求；系统验证借书卡状态，如果借书卡未借书则记录借书信息且修改图书状态和借书卡状态，并提示借书成功；否则提示借书失败。</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132330214.png"></p>
<h4 id="通信图"><a href="#通信图" class="headerlink" title="通信图"></a>通信图</h4><ul>
<li>通信图是由协作图发展而来的。与顺序图不同，通信图主要关注，参与交互的对象通过连接组成的结构。</li>
<li>通信图的对象没有生命线，其消息以及方向都附属于对象间的连接，并通过编号表示消息的顺序。</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132332976.png"></p>
<h4 id="交互概览图"><a href="#交互概览图" class="headerlink" title="交互概览图"></a>交互概览图</h4><ul>
<li>交互概览图通过类似于活动图方式，描述交互之间的流程，给出交互控制流的概览。</li>
<li>在交互概览图中，节点不像活动图中那样是动作，而是一个交互图或是对交互图的引用。交互概览图，有两种形式：</li>
<li><ul>
<li>一种是以活动图为主线，对活动图中某些重要活动节点进行细化，即用一些小的顺序图对重要活动节点进行细化，描述活动节点内的对象之间的交互。</li>
</ul>
</li>
<li><ul>
<li>另一种是以顺序图为主线，用活动图细化顺序图中某些重要对象，即用活动图描述重要对象的活动细节。</li>
</ul>
</li>
</ul>
<h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h4><ul>
<li>时序图（Sequence Diagram）是显示对象之间交互的图，这些对象是按时间顺序排列的。</li>
<li><ul>
<li>顺序图中显示的，是参与交互的对象及其对象之间消息交互的顺序。时序图中包括的建模元素，有对象（Actor）、生命线（Lifeline）、控制焦点（Focus of control）、消息（Message）等等。</li>
</ul>
</li>
<li>时序图最常应用到实时或嵌入式系统的开发中，但并不局限于此。</li>
<li><ul>
<li>被建模的系统类型，对交互的准确时间进行建模，是非常必要的。</li>
</ul>
</li>
<li>时序图中，每个消息都有与其有关联的信息，准确描述了何时发送消息，消息的接收对象会花多长时间收到该消息，以及消息的接收对象需要多少时间处于某个特定状态。</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132334484.png"></p>
<h4 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h4><p>状态图(State Diagram)用来描述<strong>一个特定对象的所有可能状态及其引起状态转移的事件</strong>。通常用状态图来描述<strong>单个对象</strong>的行为，它确定了由事件序列引出的状态序列，但并不是所有的类都需要使用状态图来描述它的行为，<strong>只有那些具有重要交互行为的类，才会使用状态图来描述</strong>。一个状态图包括<strong>一系列对象的状态及状态之间的转换</strong>。</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132335516.png"></p>
<p>状态图组成元素：</p>
<ul>
<li><p>初始状态</p>
</li>
<li><ul>
<li>状态图用初始状态（Initial State）表示对象创建时的状态，每一个状态图一般只有一个初始状态，用实心的圆点表示。</li>
</ul>
</li>
<li><p>终止状态</p>
</li>
<li><ul>
<li>每一个状态图可能有多个终止状态（Final State），用一个实心圆外加一个圆圈表示。</li>
</ul>
</li>
<li><p>状态</p>
</li>
<li><ul>
<li>状态图中可有多个状态框，每个状态框中有两格：上格放置状态名称，下格说明处于该状态时，系统或对象要进行的活动（Action）。</li>
</ul>
</li>
<li><p>转移</p>
</li>
<li><ul>
<li>从一个状态到另一个状态之间的连线称为转移（Transition）。状态之间的转移可带有标注，由三部分组成（每一部分都可省略），其语法为：<strong>事件名 [条件] &#x2F; 动作名</strong>。</li>
</ul>
</li>
<li><p>守护条件</p>
</li>
<li><ul>
<li>事件有可能在特定的条件下发生，在UML中这样的条件称为守护条件（Guard Condition）。</li>
</ul>
</li>
<li><p>事件</p>
</li>
<li><ul>
<li>状态之间的过渡事件（Event）对应对象的动作或活动（Action）。</li>
</ul>
</li>
<li><p>动作</p>
</li>
<li><ul>
<li>发生的事件可通过对象的动作（Action）进行处理。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132336218.png"></li>
</ul>
</li>
<li><p>简单状态：不包含其他状态的状态称为简单状态。</p>
</li>
<li><p>复合状态：又称为组合状态，可以将若干状态组织在一起可以得到一个复合状态，包含在一个复合状态中的状态称为子状态。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132342866.png"></p>
</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132342676.png"></p>
<ul>
<li>状态图适合用于表述<strong>在不同用例之间的对象行为</strong>。</li>
<li>系统设计中可能有多个对象，但并不需要给出每个对象的状态图，实际的做法是<strong>把注意力集中在整体系统或少数关键的对象上，特别是那些状态比较多的对象</strong>。</li>
</ul>
<h5 id="状态图实例分析"><a href="#状态图实例分析" class="headerlink" title="状态图实例分析"></a>状态图实例分析</h5><p>某信用卡系统账户具有使用状态和冻结状态，其中使用状态又包括正常状态和透支状态两种子状态。如果账户余额小于零则进入透支状态，透支状态时既可以存款又可以取款，但是透支金额不能超过5000元；如果余额大于零则进入正常状态，正常状态时既可以存款又可以取款；如果连续透支100天，则进入冻结状态，冻结状态下既不能存款又不能取款，必须要求银行工作人员解冻。用户可以在使用状态或冻结状态下请求注销账户。根据上述要求，绘制账户类的状态图。</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132343914.png"></p>
<h5 id="状态图总结"><a href="#状态图总结" class="headerlink" title="状态图总结"></a>状态图总结</h5><p>状态图使用有穷状态变迁图的方式，刻画系统或元素的离散行为，可以用来描述一个类的实例、子系统甚至整个系统的在其生存周期内，所处状态如何随着外部激励而发生变化。</p>
<h4 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h4><ul>
<li>活动图(Activity Diagram)用来表示系统中各种活动的次序，它的应用非常广泛，<strong>既可用来描述用例的工作流程，也可以用来描述类中某个方法的操作行为</strong>。</li>
<li>活动图依据对象状态的变化来捕获动作（将要执行的工作或活动）与动作的结果。活动图中一个活动结束后将立即进入下一个活动（在状态图中状态的变迁可能需要事件的触发）。</li>
<li>利用文本描述用例的事件流是很有用的，但如果事件流的逻辑复杂且有许多其他事件流，则文本形式可能较难阅读和理解，这时可<strong>使用活动图来描述事件流</strong>。</li>
<li>活动图是<strong>UML中的流程图</strong>，它是事件流的另一种建模方式。活动图用于以图形化的方式描述一个业务过程或者一个用例的活动的顺序流，它也可以用于建模一个操作要执行的动作，以及那些动作的结果。</li>
<li><strong>活动图是一种描述工作流的方式</strong>，它用来描述采取何种动作、做什么（对象状态改变）、何时发生（动作序列）以及在何处发生（泳道）。</li>
</ul>
<p>作用：</p>
<ul>
<li><strong>描述业务流程</strong></li>
<li>描述用例路径</li>
<li>描述方法执行流程（程序流程图）</li>
</ul>
<p>实例：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132348789.png"></p>
<p>组成元素：</p>
<ul>
<li><strong>起始活动</strong>显式地表示活动图工作流程的开始，用实心圆饼来表示，在一个活动图中，只有一个起始活动。</li>
<li><strong>终止活动</strong>表示一个活动图的最后和终结活动，一个活动图中可以有0个或多个终止活动，终止活动用实心圆点外加一个小圆圈来表示。</li>
<li>活动图中的<strong>活动用一个圆角矩形表示</strong>，其内部的文本串用来说明采取的动作。活动是指一组动作，它是实现操作的一个步骤，活动之间的转移用箭头来表示，称为转移或流，转移是由事件的发生所引起的活动的改变，用带有箭头的实线表示。箭头上可能还带有守护条件，发送短句和动作表达式。</li>
<li><strong>守护条件</strong>用来约束转移，守护条件为真时转移才可以开始</li>
<li><strong>用菱形符号来表示判定</strong>，判定符号可以有一个或多个进入转移，两个或更多的带有守护条件的发出转移。</li>
<li><strong>对象流是活动与对象之间的依赖关系</strong>，可以将与活动涉及的对象放在活动图中，用一个依赖将其连接到相应的活动中，对象的这种使用方法构成了对象流。在活动图中，<strong>对象流使用带箭头的虚线表示，对象用矩形表示</strong>，矩形内是该对象的名称，名称下的方括号表示该对象此时的状态。</li>
<li><strong>可以将一个转移分解成两个或更多的转移，从而导致并发的动作。</strong>所有的并行转移在合并之间必须被执行。一条粗黑线表示将转移分解成多个<strong>分支(fork)<strong>，同样用粗黑线来表示分支的</strong>合并(join)<strong>，这种粗黑线称为</strong>同步条</strong>。</li>
<li><strong>泳道</strong>用于划分活动图，有助于更好地理解执行活动的场所。<strong>泳道划分负责活动的对象</strong>，明确地表示哪些活动是由哪些对象进行的，每个活动只能明确地属于一个泳道。</li>
<li>在活动图中，泳道一般<strong>用垂直实线</strong>绘出，垂直线分隔的区域就是泳道。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132354403.png"></li>
</ul>
<p>绘制技巧：</p>
<ul>
<li>使用活动图来<strong>描述用例路径更加直观</strong>。</li>
<li>对面向对象建模而言，用活动图描述业务流程<strong>并不是对每个系统都必不可少的工作</strong>。</li>
<li><strong>不要把描述业务流程的活动图看成可编程的模型</strong>，它与系统的实际构造情况和执行情况有很大的差距。</li>
<li><strong>首先要对主要的业务流建模，然后再标出分支、合并和对象流。</strong></li>
<li><strong>尽量减少交叉线</strong>，如果图形较为复杂，适当使用<strong>颜色和注释</strong>。</li>
</ul>
<h5 id="活动图实例分析"><a href="#活动图实例分析" class="headerlink" title="活动图实例分析"></a>活动图实例分析</h5><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132355559.png"></p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401132355950.png"></p>
<h5 id="活动图总结"><a href="#活动图总结" class="headerlink" title="活动图总结"></a>活动图总结</h5><ul>
<li>活动图是UML用于对系统的动态行为建模的另一种常用工具，描述活动的顺序，展现从一个活动到另一个活动的控制流。</li>
<li><ul>
<li>本质上，活动图是一种流程图。活动图着重表现从一个活动到另一个活动的控制流，是内部处理驱动的流程。</li>
</ul>
</li>
<li>活动图主要用于，业务建模时，用于详述业务用例，描述一项业务的执行过程，设计时描述操作的流程。</li>
<li><ul>
<li>UML的活动图中包含的图形元素有动作状态、活动状态、动作流、分支与合并、分叉与汇合、泳道和对象流等。</li>
</ul>
</li>
<li>活动图与流程图的区别为，活动图描述系统使用的活动、判定点和分支，看起来和流程图没什么两样，并且传统的流程图所能表示的内容。</li>
<li>大多数情况下也可以使用活动图表示，但是两者是有区别的，不能将两个概念混淆。</li>
</ul>
<h2 id="软件质量"><a href="#软件质量" class="headerlink" title="软件质量"></a>软件质量</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><ul>
<li>作为在软件生命周期早期保障软件质量的重要手段之一，软件体系结构评估技术，是软件体系结构研究中的一个重要组成部分。</li>
<li><ul>
<li>用户最关注软件系统的质量，尤其是大规模的复杂软件系统。</li>
</ul>
</li>
<li><ul>
<li>软件体系结构，对于确保最终系统的质量，有重要意义。</li>
</ul>
</li>
<li>对软件的体系结构进行评估，是为了在系统被构建之前<strong>预测质量</strong>，通过分析体系结构对于系统质量的影响，进而提出改进意见。</li>
<li><ul>
<li>因此，软件体系结构评估的目的，是<strong>分析软件体系结构潜在的风险</strong>，并检验设计中提出的质量需求。</li>
</ul>
</li>
<li><ul>
<li>针对体系结构评估，许多研究组织在会议和杂志上提出了众多结构化的评估方法，对于评估的方法的改进和实践工作仍在进行中。</li>
</ul>
</li>
</ul>
<h3 id="质量定义"><a href="#质量定义" class="headerlink" title="质量定义"></a>质量定义</h3><ul>
<li><p>软件质量在IEEE 1061中定义：体现了<strong>软件拥有所期望的属性组合的程度</strong>。</p>
</li>
<li><p>ISO&#x2F;IEC Draft9126-1标准定义了软件质量模型。</p>
</li>
<li><p>依照这个模型，共有六种特征：功能性、可靠性、可用性、有效性、可维护性和可移植性，并且被分成子特征，根据各个软件系统外部的可见特征来定义这些属性。</p>
</li>
<li><p>高质量的软件：具有质量的软件是那些与它们的最初目的相一致的软件</p>
</li>
<li><p>符合<strong>商业目标</strong>和<strong>用户需求</strong></p>
</li>
<li><p><strong>正确的功能</strong>和<strong>优良的属性</strong></p>
</li>
</ul>
<h3 id="质量目标与商业目标"><a href="#质量目标与商业目标" class="headerlink" title="质量目标与商业目标"></a>质量目标与商业目标</h3><ul>
<li><p><strong>商业目标</strong></p>
</li>
<li><p><strong>企业的根本目标是为了获取尽可能多的利润，而不是生产完美无缺的产品。</strong>如果企业销售出去的软件的质量比较差，轻则挨骂，重则被退货甚至被索赔，因此为了提高用户对产品的满意度，企业必须提高产品的质量。</p>
</li>
<li><p><strong>商业目标决定质量目标</strong></p>
</li>
<li><p>但是企业<strong>不可能为了追求完美的质量而不惜一切代价</strong>，当企业为提高质量所付出的代价超过销售收益时，这个产品已经没有商业价值了，还不如不开发。</p>
</li>
<li><p><strong>企业必须权衡质量、效率和成本</strong>，产品质量太低了或者太高了，都不利于企业获取利润。</p>
</li>
<li><p>企业理想的质量目标不是“零缺陷”是恰好让广大用户满意，并且将提高质量所付出的代价控制在预算之内。</p>
</li>
<li><p>质量属性</p>
</li>
<li><ul>
<li>质量属性需求<strong>来源于商业和产品目标</strong>。</li>
</ul>
</li>
<li><ul>
<li>关键的质量属性<strong>必须刻画系统的细节特征</strong>。</li>
</ul>
</li>
<li><ul>
<li><strong>质量属性场景</strong>是用于描述质量属性和表达项目干系人观点的强有力的工具。</li>
</ul>
</li>
<li><p>外部质量对于<strong>用户</strong>而言是可见的</p>
</li>
<li><ul>
<li>正确性、健壮性、可靠性、性能、安全性、易用性、兼容性等。</li>
</ul>
</li>
<li><p>内部质量只有<strong>开发人员</strong>关心，可以帮助开发人员实现外部质量</p>
</li>
<li><ul>
<li>易理解性、可测试性、可维护性、可扩展性、可移植性、可复用性等</li>
</ul>
</li>
</ul>
<h3 id="外部质量"><a href="#外部质量" class="headerlink" title="外部质量"></a>外部质量</h3><h4 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h4><p>正确性：正确性是指<strong>软件按照需求正确执行任务的能力</strong>。</p>
<ul>
<li>功能性是系统完成所期望工作的能力。一项任务的完成，需要系统中许多或大多数构件的相互协作。</li>
<li>功能性可以细化成完备性、正确性。</li>
<li><ul>
<li>完备性：是与软件功能完整、齐全有关的软件属性。如果软件实际完成的功能，少于或不符合研制任务书所规定的明确或隐含的那些功能，则不能说该软件的功能是完备的</li>
</ul>
</li>
<li><ul>
<li>正确性：是与能否得到正确或相符的结果或效果有关的软件属性。软件的正确性，在很大程度上，与软件模块的工程模型（直接影响辅助计算的精度与辅助决策方案的优劣）和软件编制人员的编程水平有关。</li>
</ul>
</li>
</ul>
<h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h4><ul>
<li><p>可靠性是指在<strong>一定的环境下，在给定的时间内，系统不发生故障（可以正常运行）的概率</strong>。</p>
</li>
<li><p>软件可靠性分析通常采用<strong>统计方法【度量指标】</strong>，遗憾的是目前可供第一线开发人员使用的成果很少见，大多数文章限于理论研究。</p>
</li>
<li><p>口语中的可靠性含义宽泛，几乎囊括了正确性、健壮性。</p>
</li>
<li><ul>
<li>只要人们发现系统有毛病，便归结为可靠性差。从专业角度讲，这种说法是确切的。</li>
</ul>
</li>
<li><ul>
<li>时隐时现的错误一般都属于可靠性问题，纠错的代价很高。</li>
</ul>
</li>
<li><p>软件可靠性问题主要是在编程时候埋下的祸害（很难测试出来）</p>
</li>
<li><ul>
<li>应当提倡规范化程序设计，预防可靠性祸害。</li>
</ul>
</li>
<li><p>可靠性是软件无故障执行一段时间的概率。健壮性和有效性，有时可看成是可靠性的一部分。</p>
</li>
<li><ul>
<li>衡量软件可靠性的方法，包括正确执行操作所占的比例，在发现新缺陷之前系统运行的时间长度和缺陷出现的密度。</li>
</ul>
</li>
<li><ul>
<li>根据如果发生故障对系统有多大影响和对于最大的可靠性的费用是否合理，来定量地确定可靠性需求。</li>
</ul>
</li>
<li><ul>
<li><em>如果软件满足了可靠性需求，那么，即使该软件还存在缺陷，也可认为达到其可靠性目标。</em>要求高可靠性的系统也是为高可测试性系统设计的。</li>
</ul>
</li>
<li><p>根据相关的软件测试与评估要求，可靠性可以细化为<strong>成熟性</strong>、稳定性、易恢复性。</p>
</li>
<li><ul>
<li>对于软件的可靠性评价，主要采用定量评价方法。即选择合适的可靠性度量因子（可靠性参数），然后，分析可靠性数据而得到参数具体值，最后进行评价。</li>
</ul>
</li>
</ul>
<p>可靠性参数：</p>
<ol>
<li>可用度</li>
<li>初期故障率</li>
<li>偶然故障率</li>
<li>平均失效前时间</li>
<li>平均失效间隔时间</li>
<li>缺陷密度</li>
<li>平均失效恢复时间</li>
</ol>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><ul>
<li>性能通常是指<strong>软件的“时间-空间”效率，而不仅是指软件的运行速度</strong>。</li>
<li>人们总希望软件的运行速度高，并且占用资源少。性能优化的关键工作是找出限制性能的“瓶颈”。程序员可以通过优化数据结构、算法和代码来提高软件的性能。例如数据库程序的优化。分析算法的复杂度是很好的方法，可以达到“未卜先知”的功效。</li>
<li>性能优化就好像从海绵里挤水一样，你不挤，水就不出来，越用力去挤海绵越干。有些程序员认为现在的计算机不仅速度越来越高，而且内存越来越大，因此软件性能优化的必要性下降了。这种看法是不对的，殊不知随着机器的升级，软件系统也越来越庞大了和复杂了，性能优化仍然大有必要。</li>
</ul>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><ul>
<li>安全性是指<strong>防止系统被非法入侵的能力</strong>，既属于技术问题又属于管理问题。</li>
<li>信息安全是一门比较深奥的学问，其发展是建立在正义与邪恶的斗争之上。这世界似乎不存在绝对安全的系统，连美国军方的系统都频频遭黑客入侵。如今全球黑客泛滥，真是“道高一尺，魔高一丈”啊！开发商和客户愿意为提高安全性而投入的资金是有限的，他们要考虑值不值得。</li>
<li>究竟什么样的安全性是令人满意的呢？一般地，<strong>如果黑客为非法入侵花费的代价（考虑时间、费用、风险等因素）高于得到的好处，那么这样的系统可以认为是安全的。</strong>对于普通软件，并不一点要追求很高的安全性，也不能完全忽视安全性，要先分析黑客行为。</li>
</ul>
<h4 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h4><ul>
<li>易用性是指<strong>用户使用软件的容易程度</strong>。</li>
<li>现代人的生活节奏快，做什么事都想图个方便。所以把易用性作为重要的质量属性对待无可非议。</li>
<li>导致软件易用性差的根本原因 ：</li>
<li><ul>
<li>理工科大学教育存在缺陷：没有开设人机工程学、美学、心理学这些必修课，大部分开发人员不知道如何设计易用的软件产品。</li>
</ul>
</li>
<li><ul>
<li>开发人员犯了“错位”的毛病：他以为只要自己用起来方便，用户也就会满意。软件的易用性要让用户来评价。</li>
</ul>
</li>
<li><ul>
<li>当用户真的感到软件很好用时，一股温暖的感觉油然而生，于是就用“界面友好”、“方便易用”等词来评价软件产品。</li>
</ul>
</li>
<li>“客户第一”，“以用户为中心”……</li>
</ul>
<h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><ul>
<li>兼容性是<strong>指不同产品（或者新老产品）相互交换信息的能力</strong>。例如两个字处理软件的文件格式兼容，那么它们都可以操作对方的文件，这种能力对用户很有好处。兼容性又称为<strong>互操作性</strong>。</li>
<li><strong>兼容性商业规则</strong>：弱者设法与强者兼容，否则无容身之地；强者应当避免被兼容，否则市场将被瓜分。</li>
<li><ul>
<li>WPS一定要与Word兼容，否则活不下去，但是Word绝对不会主动与WPS兼容，除非WPS在中国占有一定优势。</li>
</ul>
</li>
<li><ul>
<li>纵向兼容、横向兼容</li>
</ul>
</li>
</ul>
<h3 id="内部质量"><a href="#内部质量" class="headerlink" title="内部质量"></a>内部质量</h3><ul>
<li>内部质量只有开发人员关心</li>
<li>它们可以帮助开发人员实现外部质量</li>
<li>包括易理解性、可测试性、可维护性、可扩展性、可移植性、可复用性等</li>
</ul>
<h4 id="易理解性"><a href="#易理解性" class="headerlink" title="易理解性"></a>易理解性</h4><ul>
<li>易理解性是<strong>开发人员理解软件产品的能力</strong>，意味着所有的工作成果要易读、易理解，可以<strong>提高团队开发效率，降低维护代价</strong>。</li>
<li>开发人员只有在自己思路清晰的时候才可能写出让别人易读、易理解的程序和文档。可理解的东西通常是简洁的。一个原始问题可能很复杂，但高水平的人就能够把软件系统设计得很简洁。如果软件系统臃肿不堪，它迟早会出问题。所以简洁是人们对工作“精益求精”的结果，而不是潦草应付的结果。</li>
</ul>
<h4 id="可测试性"><a href="#可测试性" class="headerlink" title="可测试性"></a>可测试性</h4><ul>
<li>可测试性指的是<strong>测试软件组件或集成产品时查找缺陷的简易程度</strong>，又称为可验证性。</li>
<li>如果产品中包含复杂的算法和逻辑，或如果具有复杂的功能性的相互关系，那么对于可测试性的设计就很重要。如果经常更改产品，那么可测试性也是很重要的，因为将经常对产品进行回归测试来判断更改是否破坏了现有的功能性。</li>
</ul>
<h4 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h4><ul>
<li>可维护性表明了<strong>在软件中纠正一个缺陷或做一次更改的简易程度</strong>。</li>
<li>可维护性取决于理解软件、更改软件和测试软件的简易程度，可维护性与灵活性密切相关。高可维护性对于那些经历周期性更改的产品或快速开发的产品很重要。你可以根据修复一个问题所花的平均时间和修复正确的百分比来衡量可维护性。</li>
</ul>
<h4 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h4><ul>
<li>可扩展性<strong>反映软件适应“变化”的能力</strong>。</li>
<li>在软件开发过程中，“变化”是司空见惯的事情，如需求、设计的变化，算法的改进，程序的变化等等。</li>
<li>现代软件产品通常采用“增量开发模式”，不断推出新版本，获取增值利润。可扩展性越来越重要。可扩展性是系统设计阶段重点考虑的质量属性。谈到软件的可扩展性，开发人员首先想到的是怎样提高可扩展性，于是努力去设计很好的体系结构来提高可扩展性，却不考虑该不该做这件事。从商业角度考虑，如果某个软件将不断地推出新版本，那么可扩展性很重要。但是如果软件永远都不会有下个版本（一次性买卖），那么根本无需提高可扩展性。</li>
</ul>
<h4 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h4><ul>
<li>可移植性指的是<strong>软件不经修改或稍加修改就可以运行于不同软硬件环境（CPU、OS和编译器）的能力</strong>，主要体现为代码的可移植性。</li>
<li><em>编程语言越低级，用它编写的程序越难移植，反之则越容易。</em>这是因为，不同的硬件体系结构（例如Intel CPU和SPARC CPU）使用不同的指令集和字长，而OS和编译器可以屏蔽这种差异，所以高级语言的可移植性更好。Java程序号称“一次编译，到处运行”，具有100%的可移植性。为了提高Java程序的性能，最新的Java标准允许人们使用一些与平台相关的优化技术，这样优化后的Java程序虽然不能“一次编译，到处运行”，仍然能够 “一次编程，到处编译”。软件设计时应该将“设备相关程序”与“设备无关程序”分开，将“功能模块”与“用户界面”分开。</li>
</ul>
<h4 id="可复用性"><a href="#可复用性" class="headerlink" title="可复用性"></a>可复用性</h4><ul>
<li>可复用性是指<strong>一个软件的组成部分可以在同一个项目的不同地方甚至在不同的项目中重复使用的能力</strong>。</li>
<li>传统的软件复用技术包括代码的复用、算法的复用和数据结构的复用等，但这些复用有时候会破坏系统的可维护性，可以通过设计模式、面向对象的继承和多态等机制提高软件的可复用性。</li>
</ul>
<h3 id="过程质量"><a href="#过程质量" class="headerlink" title="过程质量"></a>过程质量</h3><ul>
<li>如果想保持一如既往的开发高质量的产品，过程必须是<strong>可靠</strong>的</li>
<li>如果想适应无法预计的工具或环境改变，过程必须是<strong>稳健</strong>的</li>
<li>过程的执行必须是<strong>高效</strong>的</li>
<li>如果想适应新的管理方式或组织形式，过程必须是<strong>可扩展</strong>的</li>
<li>如果想跨项目和组织来使用，过程必须是<strong>可重用</strong>的</li>
<li>过程质量与开发活动相关</li>
<li>产品通过过程来进行开发</li>
<li><ul>
<li>如开发效率，时间控制等</li>
</ul>
</li>
<li>过程改进指南</li>
<li><ul>
<li>CMM：<strong>Capability Maturity Model for Software (软件能力成熟度模型)</strong></li>
</ul>
</li>
<li><ul>
<li>CMM由美国卡内基-梅隆大学软件工程研究所（CMU-SEI）研制。</li>
</ul>
</li>
<li><ul>
<li>CMM是用于衡量软件过程能力的事实上的标准，<strong>同时也是目前软件过程改进最好的参考标准</strong>。</li>
</ul>
</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401141745037.png"></p>
<h2 id="软件体系结构评估"><a href="#软件体系结构评估" class="headerlink" title="软件体系结构评估"></a>软件体系结构评估</h2><h3 id="评估的必要性"><a href="#评估的必要性" class="headerlink" title="评估的必要性"></a>评估的必要性</h3><p>软件架构是软件工程早期设计阶段的产物，对软件系统或软件项目的开发，具有深远的影响，主要表现在以下两个方面。</p>
<ul>
<li><strong>不恰当的架构，会给软件系统或软件项目的开发带来灾难。</strong></li>
<li><ul>
<li>如果软件架构不恰当，就无法满足系统的性能要求，则系统的安全性也就无法实现。</li>
</ul>
</li>
<li><ul>
<li>当客户要求提高可用性时，开发小组将会因忙于修改发现错误，而影响开发的进度、预算，这样，会使整个系统或项目的成本大幅提高，甚至会使整个软件系统或软件项目的开发因成本太高而终止。</li>
</ul>
</li>
<li><strong>架构决定着项目的结构。</strong></li>
<li><ul>
<li>如配置控制库、进度与预算、性能指标、开发小组结构、文档组织、测试、维护活动，都是围绕着架构展开的。</li>
</ul>
</li>
<li><ul>
<li>假如在开发过程中发现错误，中途修改架构，会使整个项目的工作陷入混乱。</li>
</ul>
</li>
<li><ul>
<li>鉴于以上架构对项目和系统的影响，需要对软件架构进行评估，这是降低项目和系统成本及避免灾难的有效手段。</li>
</ul>
</li>
</ul>
<p>软件架构评估可以在架构生命周期的任何阶段进行，一般的时机，有早期和后期两<br>种情况。</p>
<ul>
<li>早期：</li>
<li><ul>
<li>通常把早期实施的评估称为发现性评审，目的是找出较难实现的需求并划分其优先级，分析在实施这一评估时已有的“原型架构”。进行发现性评审时，一定要保证：</li>
</ul>
</li>
<li><ul>
<li>在系统尚未最终确定、设计师已经比较清楚，应采用什么方案的情况下实施；</li>
</ul>
</li>
<li><ul>
<li>风险承担者小组中，要有有权做出需求决策的人员；</li>
</ul>
</li>
<li><ul>
<li>评审结果中，要有一组按优先级排列的需求，以备在不易满足所有需求的情况下使用。</li>
</ul>
</li>
<li>后期：</li>
<li><ul>
<li>这种评估是在架构已经完全确定后实施的，适用于开发组织有老系统的情况。</li>
</ul>
</li>
<li><ul>
<li>评估老系统的架构，和新系统的架构所用的方法相同，通过评估，可以使用户明确是否可以通过改进老系统，来满足新的质量及功能需求。</li>
</ul>
</li>
</ul>
<h3 id="基于场景的评估方法"><a href="#基于场景的评估方法" class="headerlink" title="基于场景的评估方法"></a>基于场景的评估方法</h3><ul>
<li>该方法的基本观点是，大多数软件质量属性极为复杂，根本无法用一个简单的尺度来衡量。</li>
<li><ul>
<li>同时，质量属性并不是处于隔离状态，只有在一定的上下文环境中才能做出关于质量属性的有意义的评判。</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>利用场景技术可以<strong>具体化评估的目标</strong>，代替对质量属性（可维护性、可修改性、健壮性、灵活性等）的空洞表述，使对软件体系结构的测试成为可能。</li>
</ul>
</li>
</ul>
</li>
<li>所以，场景对于评估具有非常关键的作用，整个评估过程，就是论证软件体系结构对关键场景的支持程度。</li>
</ul>
<p>基于场景的软件架构分析方法步骤</p>
<ol>
<li><strong>分析问题域，建立功能场景库。</strong><ul>
<li>针对具体项目在应用领域中的定位，展开需求分析，汇总系统预期功能并按对功能进行分类，以确保每项功能都能够得到详细描述，并为每个功能定义相应的场景，建立功能场景库。</li>
</ul>
</li>
<li><strong>通过功能场景库测试评价软件架构对各功能的支持度，并针对支持度差的功能展开架构分析。</strong><ul>
<li>支持度的评价涉及到，架构是否满足功能场景、是否容易扩展该功能等。</li>
<li>一旦发现支持度差的功能，进一步分析是否是由架构设计导致的，从中发现可能的架构设计缺陷和不足。</li>
</ul>
</li>
<li><strong>建立非功能指标参数树。</strong><ul>
<li>选择一组感兴趣的非功能性指标，如可移植性、安全性、性能，并详细定义每一个指标的衡量属性、期望值、相应的场景。</li>
</ul>
</li>
<li><strong>应用指标参数树，对软件架构进行非功能性分析。</strong><ul>
<li>通过比较架构在场景中的实际输出值、期望值，来评价架构对各个指标的各个属性的支持度，并在该过程中，发现软件架构的缺陷，找出风险决策、无风险决策、敏感点、权衡点。</li>
</ul>
</li>
</ol>
<p>不足：</p>
<ol>
<li>评估的效果，对评估师经验的依赖程度较高。</li>
<li>“重量级”的评估技术，成本较高。</li>
<li>没有考虑知识的积累和应用问题，造成资源的浪费。</li>
<li>缺乏实用的评估信息管理工具。</li>
</ol>
<h4 id="SAAM软件架构分析方法"><a href="#SAAM软件架构分析方法" class="headerlink" title="SAAM软件架构分析方法"></a>SAAM软件架构分析方法</h4><ol>
<li><strong>特定目标</strong>：<ul>
<li>是<strong>对描述应用程序属性的文档，验证基本的体系结构假设和原则</strong>。</li>
<li>此外，该分析方法有利于评估体系结构固有的风险。SAAM指导对体系结构的检查，使其主要关注潜在的问题点，如需求冲突，或仅从某一参与者的观点出发的不全面的系统设计。</li>
<li>SAAM不仅能够评估体系结构对于特定系统需求的使用能力，也能被用来比较不同的体系结构。</li>
</ul>
</li>
<li><strong>评估技术</strong>：<ul>
<li>是<strong>场景技术</strong>。场景代表了描述体系结构属性的基础，描述了各种系统必须支持的活动和将要发生的变化。</li>
</ul>
</li>
<li><strong>质量属性</strong>：<ul>
<li>这一方法的基本特点，是<strong>把任何形式的质量属性都具体化为场景</strong>，但<strong>可修改性</strong>是SAAM分析的主要质量属性。</li>
</ul>
</li>
<li><strong>风险承担者</strong>：<ul>
<li>SAAM协调不同参与者所感兴趣的方面，作为后续决策的基础，提供了对体系结构的公共理解。</li>
</ul>
</li>
<li><strong>体系结构描述</strong>：<ul>
<li>SAAM用于体系结构的最后版本，但早于详细设计。体系结构的描述形式应当被所有参与者理解。功能、结构、分配被定义为描述体系结构的三个主要方面。</li>
</ul>
</li>
<li><strong>方法活动</strong>：<ul>
<li>SAAM的主要输入问题是问题描述、需求声明和体系结构描述。</li>
</ul>
</li>
</ol>
<p>一般步骤：</p>
<ol>
<li><strong>场景形成。</strong><ul>
<li>通过集体讨论，风险承担者提出反映自己需求的场景。</li>
<li>在形成场景的过程中，要注意全面捕捉系统的主要用途、系统用户类型、系统将来可能的变更、系统在当前及可预见的未来，必须满足的质量属性等信息。只有这样，形成的场景才能代表与各种风险承担着者相关的任务。</li>
<li>例如，对于某个变更，开发人员关心的，是实现该变更的难度和对性能的影响，而系统管理员则关系此变更对体系结构的可集成性的影响。</li>
</ul>
</li>
<li><strong>描述软件体系结构。</strong><ul>
<li>SAAM定义了功能性、结构、分配三个视角，来描述软件体系结构。功能性指示系统做了些什么，结构由组件和组件间的连接组成，从功能到结构的分配则描述了域上的功能性是如何在软件结构中实现的。场景的形成与软件体系结构的描述通常是相互促进的，并且需要重复的进行。</li>
<li>软件体系结构设计师应该采用参加评估的所有人员都能充分理解的形式，对待评估的体系结构进行适当的描述。</li>
<li>场景的形成和对体系结构的描述，通常是相互促进的。</li>
</ul>
</li>
<li><strong>场景的分类和优先级划分。</strong><ul>
<li>分析过程中，需要确定一个场景是否需要修改该体系结构。不需要修改的场景称为直接场景，需要修改的场景则称为间接场景。另一方面，需要对场景设置优先级，保证在评估的有限时间内考虑最重要的场景。</li>
<li>这一般可以通过演示现有的体系结构在执行此场景的表现来确定。在SAAM评估方法中，称这样的场景为直接场景。</li>
<li>评估人员通过对场景设置优先级，可保证在评估的有限时间内考虑最重要的场景。</li>
<li>这里的重要完全，是由风险承担者及其所关心的问题确定的。</li>
<li>一般来说，基于SAAM的评估方法关心的，是诸如可修改性的质量属性，所以，在划分优先级之前，要对场景进行分类。</li>
</ul>
</li>
<li><strong>间接场景的单独评估。</strong><ul>
<li>主要针对间接场景，列出为支持该场景所需要对体系结构做出的修改，估计出这些修改的代价。对于直接场景，只需弄清体系结构是如何实现这些场景的。</li>
<li>一旦确定了要考虑的一组场景，就要把这些场景与体系结构的描述对应起来。</li>
<li>SAAM评估也使评估人员和风险承担者更清楚地认识，体系结构的组成及各个构件的动态交互情况。</li>
<li>对每一个间接场景，必须列出为支持该场景而需要对体系结构所做的改动，估算出这些变更的代价。</li>
<li>这一步快要结束时，应该给出全部场景的总结性列表。</li>
</ul>
</li>
<li><strong>评估场景交互。</strong><ul>
<li>两个或多个间接场景，要求更改体系结构的同一个组件就称为场景交互。对场景交互的评估，能够暴露设计中的功能分配。</li>
<li>当两个或多个间接场景要求更改体系结构的同一个构件时，我们就称，这些场景在这一组构件上相互作用。</li>
<li>其次，场景的相互作用，能够暴露出体系结构设计文档未能充分说明的结构分解。</li>
</ul>
</li>
<li><strong>形成总体评估。</strong><ul>
<li>按照相对重要性，为每个场景及场景交互设置一个权值，根据权值得出总体评价。</li>
<li>如果要比较多个体系结构，或者针对同一体系结构提出多个不同的方案，可通过权值的确定，来得出总体评价。</li>
<li>同一体系结构，对于有不同目的的组织来说，会得到一个不同的评价结果。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401142042266.png"></li>
</ul>
</li>
</ol>
<h4 id="ATAM体系结构权衡分析方法"><a href="#ATAM体系结构权衡分析方法" class="headerlink" title="ATAM体系结构权衡分析方法"></a>ATAM体系结构权衡分析方法</h4><p>软件体系结构折中分析方法（Architecture Tradeoff Analysis Method，ATAM），是评估软件架构的一种综合全面的方法。</p>
<p>参与人员:</p>
<ol>
<li><strong>评估小组</strong>：<ul>
<li>是评估体系结构项目外部的小组。通常由3到5个人组成。</li>
<li>评估期间，该小组的每个成员，都要扮演大量的特定的角色。评估小组可能是一个常设小组，其中，要定期执行体系结构评估，其成员也可能是为了应对某次评估，从了解体系结构的人中挑选出来的。</li>
<li>他们可能与开发小组为相同的组织工作，也可能是外部的咨询人员。任何情况下，他们都应该是有能力、没有偏见、专职的外部人员。</li>
</ul>
</li>
<li><strong>项目决策者</strong>：<ul>
<li>对开发项目具有发言权，并有权要求进行某些改变。</li>
<li>他们通常包括项目管理人员。如果有承担开费用的可以确定的客户，也应该列入其中。设计师肯定要参与评估，这是由软件体系结构评估的基本准则决定的。</li>
</ul>
</li>
<li><strong>涉众（Stakeholder）</strong>：<ul>
<li>是软件项目的既得利益者，他们完成工作的能力与支持可修改性、安全性、高可靠性等特性的体系结构密切相关。</li>
<li>涉众包括开发人员、测试人员、集成人员、维护人员、性能工程师、用户、正在分析系统交互的系统构建人员等。</li>
<li>评估期间，他们的工作职责是清晰明白的阐述，体系结构应该满足的具体质量属性目标，使所开发的系统能够取得成功。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401142055704.png"></li>
</ul>
</li>
</ol>
<p>结果:</p>
<ol>
<li><strong>简洁的体系结构描述</strong>：<ul>
<li>通常认为，体系结构文档是由对象模型、接口及其签名的列表或其他冗长的列表组成的。但ATAM的要求，就是在一个小时内表述体系结构，这样，就得到了一个简洁而且通常是可理解的体系结构表述。</li>
</ul>
</li>
<li><strong>表述清楚的业务目标</strong>：<ul>
<li>开发小组的某些成员，通常是在ATAM评估上第一次看到表述清楚的业务目标。</li>
</ul>
</li>
<li><strong>用场景集合捕获的质量需求</strong>：<ul>
<li>业务目标导致质量需求，一些重要的质量需求是用场景的形式捕获的。</li>
</ul>
</li>
<li><strong>体系结构决策到质量需求的映射</strong>：<ul>
<li>可以根据体系结构决策所支持或阻碍的质量属性，来解释体系结构决策。对于在ATAM期间分析的每个质量场景，确定那些有助于实现该质量场景的体系结构决策。</li>
</ul>
</li>
<li><strong>所确定的敏感点和权衡点集合</strong>：<ul>
<li>这些是对一个或多个质量属性具有显著影响的体系结构决策。</li>
<li>例如，采用一个备份数据库，很明显是一个体系结构决策，影响了可靠性，是一个关于可靠性的敏感点。然而，保持备份将消耗系统资源，影响系统性能。因此，是可靠性和性能之间的权衡点。该决策是否有风险，取决于在体系结构的质量属性需求的上下文中。</li>
</ul>
</li>
<li><strong>有风险决策和无风险决策</strong>：<ul>
<li>ATAM中有风险决策的定义是，根据所陈述的质量属性需求，可能导致不期望的体系结构决策。无风险决策的定义与此类似，根据分析被认为是安全的体系结构决策。确定的风险，可以形成体系结构风险移植计划的基础。</li>
</ul>
</li>
<li><strong>风险主题的集合</strong>：<ul>
<li>分析完成时，评估小组将分析所发现风险的集合，以寻找确定体系结构甚至体系结构过程和小组中的系统弱点。如果不采取相应的措施，这些风险主题，将影响项目的业务目标。</li>
</ul>
</li>
</ol>
<ul>
<li>评估的结果，用于建立一个最终书面报告。该报告概述ATAM方法，总<br>结评估会议记录，捕获场景及其分析，对得到的结果进行分类。</li>
<li><ul>
<li>评估还会产生一些副结果。通常情况下，为评估准备的体系结构描述，可能比已经存在的任何体系结构都要清晰。</li>
</ul>
</li>
<li><ul>
<li>这个额外准备的文档，经受住了评估的考验，可能会与项目一起保留下来。</li>
</ul>
</li>
<li><ul>
<li>此外，参与人员创建的场景是业务目标和体系结构需求的表示，可以用来指导架构的演变。最后，可以把最终报告中的分析内容，作为对制定某些体系结构决策的依据。</li>
</ul>
</li>
<li>ATAM评估还有一些无形的结果。</li>
<li><ul>
<li>这些结果，包括能够使涉众产生社群感，可以为设计师和涉众提供公开交流的渠道，使体系结构的所有参与者更好地理解体系结构及其优势和弱点。</li>
</ul>
</li>
<li><ul>
<li>尽管这些结果很难度量，但是，重要性不亚于其他结果，而且，这些结果通常是存在时间最长的。</li>
</ul>
</li>
</ul>
<p>步骤:<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401142103893.png"><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401142103153.png"></p>
<h4 id="评估方法比较"><a href="#评估方法比较" class="headerlink" title="评估方法比较"></a>评估方法比较</h4><p>场景的生成方式不同:</p>
<ul>
<li>SAAM方法采用头脑风暴（brainstorming）技术构建场景，要求风险承担者列举出若干场景，并将场景分为直接场景和间接场景两类，分别支持对体系的静态分析和动态分析。</li>
<li><ul>
<li>对间接场景，设计师应说明，需要对体系结构作哪些修改，才能适应间接场景的要求，并估计出这些更改的代价。</li>
</ul>
</li>
<li>ATAM在具体评估中将场景分为三类，要求软件设计师必须清楚地向风险承担者表达，软件结构设计中所使用任何明确的体系结构方法，风险承担者根据确定使用的体系结构方法，采用“刺激-环境-响应”来生成三类场景。<ol>
<li>用例场景（Use Case Scenario）。描述用户的期望与正在运行的系统交互，<br>用于信息的获取。</li>
<li>生长场景（Growth Scenario）。预期的系统变更与质量属性关系。</li>
<li>探索场景（Exploratory Scenario）。</li>
</ol>
</li>
</ul>
<p>风险承担者商业动机表述方式不同：</p>
<ul>
<li>ATAM建立在SAAM的基础上，借助于效用树将风险承担者的商业目标转换成质量属性需求，再转换成代表自己商业目标的场景。</li>
<li>效用树的理论基础，是管理学中的“需要理论”，即通过刺激及其所产生期望响应来描述场景，根据期望的迫切程度确定场景优先级别，在理想情况下，所有场景都以“刺激-环境-响应”的形式表述。</li>
</ul>
<p>软件体系结构的描述方式不同：</p>
<ul>
<li>在评估之前，首席软件设计师需要对软件体系结构作详略适当的讲解，这种信息讲解的表达透彻程度将直接影响体系结构的分析质量。</li>
<li>ATAM方法中软件体系结构的描述，采用Philippe Kruchten的“4+1”视图模型，即从五个不同的视角描述系统的体系结构，四个视图模型，从特定的不同方面描述软件的体系结构，忽略与此无关的实体。</li>
<li>将四个视图有机地联系起来，场景视图不仅可以描述一个特定的视图内的构件关系，而且，可以描述不同视图间的构件关系。在四个视图中，逻辑视图、开发视图主要用来描述系统的静态结构；进程视图、物理视图主要用来描述系统的动态结构。ATAM在实际运用中并非每个系统都必须将五个视图都画出来，而是各有侧重。</li>
</ul>
<h4 id="思考与练习"><a href="#思考与练习" class="headerlink" title="思考与练习"></a>思考与练习</h4><p>某软件公司欲为某电子商务企业开发一个在线交易平台，支持客户完成网上购物活动中的在线交易。在系统开发之初，企业对该平台提出了如下要求：</p>
<ul>
<li>在线交易平台必须在1s内完成客户的交易请求。</li>
<li>该平台必须保证客户个人信息和交易信息的安全。</li>
<li>当发生故障时，该平台的平均故障恢复时间必须小于10s。</li>
<li>由于企业业务发展较快，需要经常为该平台添加新功能或进行硬件升级。添加新功能或进行硬件升级必须要在6小时内完成。<br>针对这些要求，该软件开发公司决定采用基于架构的软件开发方法，以架构为核心进行在线交易平台的设计与实现。<br>请对该在线交易平台的4个要求进行分析，指出每个要求对应何种软件质量属性；并针对每种软件质量属性，各给出2种实现该质量属性的架构设计策略。</li>
</ul>
<ol>
<li><strong>性能（Performance）</strong> - 在1秒内完成客户的交易请求。<ul>
<li><strong>设计策略1：使用缓存技术</strong>。通过缓存常用数据或预先计算的结果，减少数据库的查询次数，提高响应速度。</li>
<li><strong>设计策略2：负载均衡</strong>。通过负载均衡器分配请求到多个服务器，确保在高流量下系统仍然能够快速响应。</li>
</ul>
</li>
<li><strong>安全性（Security）</strong> - 保证客户个人信息和交易信息的安全。<ul>
<li><strong>设计策略1：数据加密</strong>。对敏感数据如个人信息和交易数据进行加密，确保数据在传输和存储过程中的安全。</li>
<li><strong>设计策略2：使用安全协议</strong>。如采用HTTPS协议保证数据传输过程的安全，防止中间人攻击。</li>
</ul>
</li>
<li><strong>可靠性（Reliability）</strong> - 故障恢复时间必须小于10秒。<ul>
<li><strong>设计策略1：冗余部署</strong>。通过部署备用系统或组件，当主系统出现故障时，可以迅速切换到备用系统，减少故障恢复时间。</li>
<li><strong>设计策略2：自动故障检测与恢复</strong>。实现系统的自动监控与故障检测，一旦发现异常，自动启动恢复流程。</li>
</ul>
</li>
<li><strong>可维护性（Maintainability）</strong> - 快速添加新功能或进行硬件升级。<ul>
<li><strong>设计策略1：模块化设计</strong>。采用模块化的架构设计，使得添加或更新某个功能模块不会影响到整个系统的其他部分。</li>
<li><strong>设计策略2：自动化部署和测试</strong>。使用自动化工具来管理部署和测试过程，使新功能的集成和硬件升级过程更加高效和可靠。</li>
</ul>
</li>
</ol>
<h2 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h2><p>模式是在<strong>特定环境</strong>下人们解决某类<strong>重复出现问题</strong>的一套成功或有效的<strong>解决方案</strong>。<br>A pattern is a successful or efficient solution to a recurring problem within a context.<br>每个模式都描述了一个<strong>在我们的环境中不断出现的问题</strong>，然后描述了该问题的<strong>解决方案的核心</strong>，通过这种方式，人们可以无数次地<strong>重用那些已有的解决方案</strong>，无须再重复相同的工作。</p>
<p>软件模式：<strong>在一定条件下的软件开发问题及其解法</strong></p>
<ul>
<li>问题描述</li>
<li>前提条件（环境或约束条件）</li>
<li>解法</li>
<li>效果<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401142148984.png"></li>
</ul>
<p>大三律(Rule of Three)：只有经过<strong>3个以上不同类型（或不同领域）的系统</strong>的校验，一个解决方案才能从候选模式升格为模式</p>
<p>设计模式(Design Pattern)：设计模式是在<strong>特定环境下</strong>为解决<strong>某一通用软件设计问题</strong>提供的<strong>一套定制的解决方案</strong>，该方案描述了对象和类之间的相互作用。</p>
<ul>
<li>一套被<strong>反复使用的、多数人知晓的、经过分类编目的、代码设计经验</strong>的总结</li>
<li>是一种用于对软件系统中不断重现的设计问题的<strong>解决方案</strong>进行<strong>文档化</strong>的技术</li>
<li>是一种<strong>共享专家设计经验</strong>的技术</li>
<li>目的：<strong>为了可重用代码、让代码更容易被他人理解、提高代码可靠性</strong></li>
</ul>
<p>设计模式一般包含模式名称、问题、目的、解决方案、效果、实例代码和相关设计模式等基本要素，4个关键要素如下：</p>
<ul>
<li>模式名称 (Pattern Name) </li>
<li>问题 (Problem) </li>
<li>解决方案 (Solution) </li>
<li>效果 (Consequences)</li>
</ul>
<p>根据目的（模式是用来做什么的）可分为创建型(Creational)，结构型(Structural)和行为型(Behavioral)三类：</p>
<ul>
<li><strong>创建型模式</strong>主要用于<strong>创建对象</strong></li>
<li><strong>结构型模式</strong>主要用于<strong>处理类或对象的组合</strong></li>
<li><strong>行为型模式</strong>主要用于<strong>描述类或对象如何交互和怎样分配职责</strong></li>
</ul>
<p>根据范围，即模式主要是处理类之间的关系还是处理对象之间的关系，可分为类模式和对象模式两种：</p>
<ul>
<li><strong>类模式处理类和子类之间的关系</strong>，这些关系通过继承建立，在编译时刻就被确定下来，是一种静态关系</li>
<li><strong>对象模式处理对象间的关系</strong>，这些关系在运行时变化，更具动态性<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401142153002.png"></li>
</ul>
<p>设计模式的优点：</p>
<ul>
<li><strong>融合了众多专家的经验</strong>，并以一种标准的形式供广大开发人员所用</li>
<li>提供了一套<strong>通用的设计词汇和一种通用的语言</strong>，以方便开发人员之间进行沟通和交流，使得设计方案更加通俗易懂</li>
<li>让人们可以更加简单方便地<strong>复用成功的设计和体系结构</strong></li>
<li>使得设计方案<strong>更加灵活，且易于修改</strong></li>
<li>将提高软件系统的<strong>开发效率和软件质量</strong>，且在一定程度上节约设计成本</li>
<li>有助于初学者更深入地<strong>理解面向对象思想</strong>，方便阅读和学习现有类库与其他系统中的源代码，还可以提高软件的设计水平和代码质量</li>
</ul>
<h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><h3 id="原则概述"><a href="#原则概述" class="headerlink" title="原则概述"></a>原则概述</h3><ul>
<li><p><strong>可维护性(Maintainability)：指软件能够被理解、改正、适应及扩展的难易程度</strong></p>
</li>
<li><p><strong>可复用性(Reusability)：指软件能够被重复使用的难易程度</strong></p>
</li>
<li><p>面向对象设计的目标之一在于<strong>支持可维护性复用</strong>，一方面需要实现设计方案或者源代码的复用，另一方面要确保系统能够易于扩展和修改，具有良好的可维护性</p>
</li>
<li><p>面向对象设计原则为<strong>支持可维护性复用而诞生</strong></p>
</li>
<li><p><strong>指导性原则，非强制性原则</strong></p>
</li>
<li><p>每一个设计模式都符合一个或多个面向对象设计原则，面向对象设计原则是用于<strong>评价一个设计模式的使用效果的重要指标之一</strong></p>
</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401142203755.png"></p>
<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>单一职责原则定义：</p>
<ul>
<li>单一职责原则是一个对象应该<strong>只包含单一的职责</strong>，并且该职责被完整地封装在一个类中。</li>
<li><ul>
<li>最简单的面向对象设计原则，用于<strong>控制类的粒度大小</strong></li>
</ul>
</li>
<li><ul>
<li>就一个类而言，应该<strong>仅有一个引起它变化的原因</strong></li>
</ul>
</li>
<li>原则分析</li>
<li><ul>
<li>一个类（大到模块，小到方法）<strong>承担的职责越多</strong>，它<strong>被复用的可能性就越小</strong></li>
</ul>
</li>
<li><ul>
<li><strong>当一个职责变化时</strong>，可能<strong>会影响其他职责的运作</strong></li>
</ul>
</li>
<li><ul>
<li>将这些职责进行分离，<strong>将不同的职责封装在不同的类中</strong></li>
</ul>
</li>
<li><ul>
<li>将不同的变化原因封装在不同的类中</li>
</ul>
</li>
<li><ul>
<li>单一职责原则是<strong>实现高内聚、低耦合的指导方针</strong></li>
</ul>
</li>
</ul>
<h4 id="单一职责原则实例"><a href="#单一职责原则实例" class="headerlink" title="单一职责原则实例"></a>单一职责原则实例</h4><p>某软件公司开发人员针对CRM（Customer Relationship Management，客户关系管理）系统中的客户信息图表统计模块提出了如图所示的初始设计方案。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401142209612.png"><br>在图中，getConnection()方法用于连接数据库，findCustomers()用于查询所有的客户信息，createChart()用于创建图表，displayChart()用于显示图表。<br>现使用单一职责原则对其进行重构。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401142210340.png"></p>
<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>开闭原则定义 </p>
<ul>
<li>开闭原则：软件实体应当<strong>对扩展开放，对修改关闭</strong>。</li>
<li><ul>
<li>开闭原则是<strong>面向对象的可复用设计的第一块基石</strong>，是最重要的面向对象设计原则</li>
</ul>
</li>
<li><ul>
<li>在开闭原则的定义中，软件实体可以是<strong>一个软件模块、一个由多个类组成的局部结构或一个独立的类</strong></li>
</ul>
</li>
<li><ul>
<li>开闭原则是指<strong>软件实体应尽量在不修改原有代码的情况下进行扩展</strong></li>
</ul>
</li>
<li>原则分析</li>
<li><ul>
<li><strong>抽象化</strong>是开闭原则的关键</li>
</ul>
</li>
<li><ul>
<li>相对稳定的<strong>抽象层</strong> + 灵活的<strong>具体层</strong></li>
</ul>
</li>
<li><ul>
<li>**对可变性封装原则(Principle of Encapsulation of Variation, EVP)**：找到系统的可变因素并将其封装起来</li>
</ul>
</li>
</ul>
<h3 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h3><p>里氏代换原则：所有引用<strong>基类</strong>的地方必须能透明地使用其<strong>子类</strong>的对象。<br>原则分析：</p>
<ul>
<li>在软件中<strong>将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常</strong>，反过来则不成立。如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象</li>
<li>在程序中<strong>尽量使用基类类型来对对象进行定义</strong>，而在运行时再确定其子类类型</li>
</ul>
<h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><p>依赖倒转原则：高层模块不应该依赖低层模块，它们都应该依赖抽象。<strong>抽象不应该依赖于细节，细节应该依赖于抽象。</strong></p>
<ul>
<li>要<strong>针对接口编程，不要针对实现编程</strong></li>
<li>在程序代码中传递参数时或在关联关系中，<strong>尽量引用层次高的抽象层类</strong>，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等</li>
<li><strong>在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中</strong></li>
</ul>
<p>原则分析：<br>针对抽象层编程，将具体类的对象通过**依赖注入(Dependency Injection, DI)**的方式注入到其他对象</p>
<ul>
<li>构造注入</li>
<li>设值注入（Setter注入）</li>
<li>接口注入</li>
</ul>
<h4 id="OCP【开闭】-x2F-LSP【里氏代换】-x2F-DIP【依赖倒转】综合实例"><a href="#OCP【开闭】-x2F-LSP【里氏代换】-x2F-DIP【依赖倒转】综合实例" class="headerlink" title="OCP【开闭】&#x2F;LSP【里氏代换】&#x2F;DIP【依赖倒转】综合实例"></a>OCP【开闭】&#x2F;LSP【里氏代换】&#x2F;DIP【依赖倒转】综合实例</h4><p>某软件公司开发人员在开发CRM系统时发现：该系统经常需要将存储在TXT或Excel文件中的客户信息转存到数据库中，因此需要进行数据格式转换。在客户数据操作类CustomerDAO中将调用数据格式转换类的方法来实现格式转换，初始设计方案结构如图2-3所示：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401142219245.png"><br>图2-3 初始设计方案结构图<br>在编码实现图2-3所示结构时，该软件公司开发人员发现该设计方案存在一个非常严重的问题，由于每次转换数据时数据来源不一定相同，因此需要经常更换数据转换类，例如有时候需要将TXTDataConvertor改为ExcelDataConvertor，此时需要修改CustomerDAO的源代码，而且在引入并使用新的数据转换类时也不得不修改CustomerDAO的源代码，系统扩展性较差，违反了开闭原则，现需要对该方案进行重构。</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401142219979.png"></p>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>接口隔离原则：客户端<strong>不应该依赖那些它不需要的接口</strong>。</p>
<p>原则分析 </p>
<ul>
<li>当一个接口太大时，需要将它<strong>分割成一些更细小的接口</strong></li>
<li>使用该接口的客户端<strong>仅需知道与之相关的方法</strong>即可</li>
<li>每一个接口应该<strong>承担一种相对独立的角色</strong>，不干不该干的事，该干的事都要干</li>
<li>“接口”定义(1)：<strong>一个类型所提供的所有方法特征的集合</strong>。一个接口代表一个角色，每个角色都有它特定的一个接口，“<strong>角色隔离原则</strong>”</li>
<li>“接口”定义(2)：<strong>狭义的特定语言的接口</strong>。接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口，每个接口中只包含一个客户端所需的方法，“<strong>定制服务</strong>”</li>
</ul>
<h4 id="接口隔离原则示例"><a href="#接口隔离原则示例" class="headerlink" title="接口隔离原则示例"></a>接口隔离原则示例</h4><p>某软件公司开发人员针对CRM系统的客户数据显示模块设计了如图2-5所示CustomerDataDisplay接口，其中方法readData()用于从文件中读取数据，方法transformToXML()用于将数据转换成XML格式，方法createChart()用于创建图表，方法displayChart()用于显示图表，方法createReport()用于创建文字报表，方法displayReport()用于显示文字报表。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401142224227.png"><br>图2-5 初始设计方案结构图<br>在实际使用过程中开发人员发现该接口很不灵活，例如：如果一个具体的数据显示类无须进行数据转换（源文件本身就是XML格式），但由于实现了该接口，不得不实现其中声明的transformToXML()方法（至少需要提供一个空实现）；如果需要创建和显示图表，除了需要实现与图表相关的方法外，还需要实现创建和显示文字报表的方法，否则程序在编译时将报错。<br>现使用接口隔离原则对其进行重构。</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401142225680.png"></p>
<h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p>合成复用原则：优先使用<strong>对象组合，而不是继承</strong>来达到<strong>复用</strong>的目的。</p>
<ul>
<li>合成复用原则又称为组合&#x2F;聚合复用原则(Composition&#x2F; Aggregate Reuse Principle, CARP)</li>
</ul>
<p>原则分析：</p>
<ul>
<li>合成复用原则就是在一个新的对象里通过<strong>关联关系（包括组合关系和聚合关系）</strong>来使用一些已有的对象，使之成为新对象的一部分</li>
<li>新对象<strong>通过委派调用已有对象的方法</strong>达到复用功能的目的</li>
<li>复用时<strong>要尽量使用组合&#x2F;聚合关系（关联关系），少用继承</strong></li>
<li><strong>继承复用</strong>：实现简单，易于扩展。破坏系统的封装性；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；只能在有限的环境中使用。（“<strong>白箱</strong>”复用 ）</li>
<li><strong>组合&#x2F;聚合复用</strong>：耦合度相对较低，有选择性地调用成员对象的操作；可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。（“<strong>黑箱</strong>”复用 ）</li>
</ul>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>某软件公司开发人员在初期的CRM系统设计中，考虑到客户数量不多，系统采用Access作为数据库，与数据库操作有关的类，例如CustomerDAO类等都需要连接数据库，连接数据库的方法getConnection()封装在DBUtil类中，由于需要重用DBUtil类的getConnection()方法，设计人员将CustomerDAO作为DBUtil类的子类，初始设计方案结构如图2-7所示。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401142229082.png"><br>图2-7 初始设计方案结构图<br>随着客户数量的增加，系统决定升级为Oracle数据库，因此需要增加一个新的OracleDBUtil类来连接Oracle数据库，由于在初始设计方案中CustomerDAO和DBUtil之间是继承关系，因此在更换数据库连接方式时需要修改CustomerDAO类的源代码，将CustomerDAO作为OracleDBUtil的子类，这将违背开闭原则。当然也可以直接修改DBUtil类的源代码，这同样也违背了开闭原则。<br>现使用合成复用原则对其进行重构。</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401142229855.png"></p>
<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p>迪米特法则：每一个软件单位对其他的单位都只有<strong>最少的知识</strong>，而且局限于那些与本单位密切相关的软件单位。</p>
<ul>
<li>迪米特法则又称为最少知识原则(Least Knowledge Principle, LKP)</li>
<li>迪米特法则要求<strong>一个软件实体应当尽可能少地与其他实体发生相互作用</strong></li>
<li>应用迪米特法则可<strong>降低系统的耦合度</strong>，使类与类之间保持松散的耦合关系</li>
</ul>
<p>分析：</p>
<ul>
<li>迪米特法则要求在设计系统时，应该<strong>尽量减少对象之间的交互</strong></li>
<li>如果两个对象之间不必彼此直接通信，那么这两个对象就<strong>不应该发生任何直接的相互作用</strong></li>
<li>如果其中一个对象需要调用另一个对象的方法，可以<strong>通过“第三者”转发</strong>这个调用</li>
<li>通过<strong>引入一个合理的“第三者”来降低现有对象之间的耦合度</strong></li>
</ul>
<h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><p>某软件公司所开发CRM系统包含很多业务操作窗口，在这些窗口中，某些界面控件之间存在复杂的交互关系，一个控件事件的触发将导致多个其他界面控件产生响应。例如，当一个按钮(Button)被单击时，对应的列表框(List)、组合框(ComboBox)、文本框(TextBox)、文本标签(Label)等都将发生改变，在初始设计方案中，界面控件之间的交互关系可以简化为如图2-9所示的结构。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401142233699.png"><br>图2-9 初始设计方案结构图<br>在图2-9中，由于界面控件之间的交互关系复杂，导致在该窗口中增加新的界面控件时需要修改与之交互的其他控件的源代码，系统扩展性较差，也不便于增加和删除控件。<br>现使用迪米特法则对其进行重构。</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401142233232.png"></p>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><ul>
<li><strong>创建型模式(Creational Pattern)关注对象的创建过程</strong></li>
<li>创建型模式<strong>对类的实例化过程进行了抽象</strong>，能够<strong>将软件模块中对象的创建和对象的使用分离</strong>，对用户<strong>隐藏了类的实例的创建细节</strong></li>
<li>创建型模式<strong>描述如何将对象的创建和使用分离</strong>，让用户在使用对象时无须关心对象的创建细节，从而降低系统的耦合度，让设计方案更易于修改和扩展</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401142238889.png"></p>
<h3 id="简单工厂模式概述"><a href="#简单工厂模式概述" class="headerlink" title="简单工厂模式概述"></a>简单工厂模式概述</h3><p>简单工厂模式基本实现流程</p>
<ul>
<li><strong>具体产品类</strong>：将需要创建的各种不同产品对象的相关代码封装到具体产品类中</li>
<li><strong>抽象产品类</strong>：将具体产品类公共的代码进行抽象和提取后封装在一个抽象产品类中</li>
<li><strong>工厂类</strong>：提供一个工厂类用于创建各种产品，在工厂类中提供一个创建产品的工厂方法，该方法可以根据所传入参数的不同创建不同的具体产品对象</li>
<li><strong>客户端</strong>：只需调用工厂类的工厂方法并传入相应的参数即可得到一个产品对象</li>
</ul>
<p>简单工厂模式 (Simple Factory Pattern)：定义一个工厂类，它可以<strong>根据参数的不同返回不同类的实例</strong>，被创建的实例通常都<strong>具有共同的父类</strong>。</p>
<ul>
<li>在简单工厂模式中用于创建实例的方法通常是静<strong>态(static)方法</strong>，因此又被称为<strong>静态工厂方法</strong>(Static Factory Method)模式</li>
<li>要点：如果需要什么，<strong>只需要传入一个正确的参数，就可以获取所需要的对象</strong>，而<strong>无须知道其创建细节</strong></li>
</ul>
<h3 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h3><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401142240550.png"><br>抽象产品类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="comment">//所有产品类的公共业务方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodSame</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//公共方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//声明抽象业务方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">methodDiff</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体产品类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteProduct</span> <span class="keyword">extends</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="comment">//实现业务方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodDiff</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//业务方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工厂类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="comment">//静态工厂方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title function_">getProduct</span><span class="params">(String arg)</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (arg.equalsIgnoreCase(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> <span class="title class_">ConcreteProductA</span>();</span><br><span class="line">            <span class="comment">//初始化设置product</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arg.equalsIgnoreCase(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> <span class="title class_">ConcreteProductB</span>();</span><br><span class="line">            <span class="comment">//初始化设置product</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        Product product; </span><br><span class="line">        product = Factory.getProduct(<span class="string">&quot;A&quot;</span>); <span class="comment">//通过工厂类创建产品对象</span></span><br><span class="line">        product.methodSame();</span><br><span class="line">        product.methodDiff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>某软件公司要基于Java语言开发一套图表库，该图表库可以为应用系统提供多种不同外观的图表，例如柱状图(HistogramChart)、饼状图(PieChart)、折线图(LineChart)等。该软件公司图表库设计人员希望为应用系统开发人员提供一套灵活易用的图表库，通过设置不同的参数即可得到不同类型的图表，而且可以较为方便地对图表库进行扩展，以便能够在将来增加一些新类型的图表。<br>现使用简单工厂模式来设计该图表库。</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401142244595.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.xml.parsers.*;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.*;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XMLUtil</span> &#123;</span><br><span class="line">    <span class="comment">//该方法用于从XML配置文件中提取图表类型，并返回类型名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getChartType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建文档对象</span></span><br><span class="line">            <span class="type">DocumentBuilderFactory</span> <span class="variable">dFactory</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line">            <span class="type">DocumentBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> dFactory.newDocumentBuilder();</span><br><span class="line">            Document doc;							</span><br><span class="line">            doc = builder.parse(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src//designpatterns//simplefactory//config.xml&quot;</span>)); </span><br><span class="line">		</span><br><span class="line">            <span class="comment">//获取包含图表类型的文本结点</span></span><br><span class="line">            <span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> doc.getElementsByTagName(<span class="string">&quot;chartType&quot;</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">classNode</span> <span class="operator">=</span> nl.item(<span class="number">0</span>).getFirstChild();</span><br><span class="line">            <span class="type">String</span> <span class="variable">chartType</span> <span class="operator">=</span> classNode.getNodeValue().trim();</span><br><span class="line">            <span class="keyword">return</span> chartType;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建对象与使用对象"><a href="#创建对象与使用对象" class="headerlink" title="创建对象与使用对象"></a>创建对象与使用对象</h3><p>Java语言创建对象的几种方式</p>
<ul>
<li>使用<strong>new关键字</strong>直接创建对象</li>
<li>通过<strong>反射机制</strong>创建对象</li>
<li>通过<strong>克隆方法</strong>创建对象</li>
<li>通过<strong>工厂类</strong>创建对象</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401142249447.png"><br>引入工厂类UserDAOFactory</p>
<ul>
<li>如果UserDAO的某个子类的构造函数发生改变或者需要添加或移除不同的子类，<strong>只要维护UserDAOFactory的代码，不会影响到LoginAction</strong></li>
<li>如果UserDAO的接口发生改变，例如添加、移除方法或改变方法名，<strong>只需要修改LoginAction，不会给UserDAOFactory带来任何影响</strong></li>
</ul>
<blockquote>
<p>两个类A和B之间的关系应该<strong>仅仅是A创建B或者是A使用B，而不能两种关系都有</strong>。将对象的创建和使用分离，使得系统更加符合单一职责原则，有利于对功能的复用和系统的维护。</p>
</blockquote>
<p>将对象的创建与使用分离的其他好处</p>
<ul>
<li><strong>防止用来实例化一个类的数据和代码在多个类中到处都是</strong>，可以将有关创建的知识搬移到一个工厂类中，<strong>解决代码重复、创建蔓延的问题</strong></li>
<li>构造函数的名字都与类名相同，从构造函数和参数列表中大家很难了解不同构造函数所构造的产品的差异-&gt;将对象的创建过程封装在工厂类中，可以<strong>提供一系列名字完全不同的工厂方法，每一个工厂方法对应一个构造函数</strong>，客户端可以以一种更加可读、易懂的方式来创建对象</li>
</ul>
<p>何时不需要工厂？</p>
<ul>
<li><strong>无须为系统中的每一个类都配备一个工厂类</strong></li>
<li>如果一个类很简单，而且<strong>不存在太多变化，其构造过程也很简单</strong>，此时就无须为其提供工厂类，直接在使用之前实例化即可</li>
<li>否则会导致工厂泛滥，增加系统的复杂度</li>
<li>例如：<strong>java.lang.String</strong></li>
</ul>
<h3 id="简单工厂模式的简化"><a href="#简单工厂模式的简化" class="headerlink" title="简单工厂模式的简化"></a>简单工厂模式的简化</h3><p>将抽象产品类和工厂类合并，将静态工厂方法移至抽象产品类中</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401142253553.png"></p>
<h3 id="优缺点与适用环境"><a href="#优缺点与适用环境" class="headerlink" title="优缺点与适用环境"></a>优缺点与适用环境</h3><p>模式优点</p>
<ul>
<li>实现了<strong>对象创建和使用的分离</strong></li>
<li>客户端<strong>无须知道所创建的具体产品类的类名</strong>，只需要知道具体产品类所对应的参数即可</li>
<li>通过引入配置文件，<strong>可以在不修改任何客户端代码的情况下更换和增加新的具体产品类</strong>，在一定程度上提高了系统的灵活性</li>
</ul>
<p>模式缺点</p>
<ul>
<li><strong>工厂类</strong>集中了所有产品的创建逻辑，<strong>职责过重</strong>，一旦不能正常工作，整个系统都要受到影响</li>
<li><strong>增加系统中类的个数</strong>（引入了新的工厂类），增加了系统的复杂度和理解难度</li>
<li><strong>系统扩展困难</strong>，一旦添加新产品不得不修改工厂逻辑</li>
<li>由于使用了静态工厂方法，造成<strong>工厂角色无法形成基于继承的等级结构</strong>，工厂类不能得到很好地扩展</li>
</ul>
<p>适用环境</p>
<ul>
<li>工厂类<strong>负责创建的对象比较少</strong>，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂</li>
<li><strong>客户端只知道传入工厂类的参数，对于如何创建对象并不关心</strong></li>
</ul>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul>
<li>使用<strong>简单工厂模式</strong>设计的按钮工厂<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401142256391.png"></li>
<li>使用<strong>工厂方法模式</strong>改进后的按钮工厂<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401142256886.png"></li>
<li>分析：</li>
<li><ul>
<li>工厂方法模式不再提供一个按钮工厂类来统一负责所有产品的创建，而是将具体按钮的创建过程交给专门的工厂子类去完成</li>
</ul>
</li>
<li><ul>
<li>如果出现新的按钮类型，只需要为这种新类型的按钮定义一个具体的工厂类就可以创建该新按钮的实例</li>
</ul>
</li>
</ul>
<p>工厂方法模式：定义一个用于创建对象的接口，但是<strong>让子类决定将哪一个类实例化</strong>。工厂方法模式让一个类的实例化<strong>延迟到其子类</strong>。</p>
<ul>
<li>简称为<strong>工厂模式(Factory Pattern)</strong></li>
<li>又可称作<strong>虚拟构造器模式(Virtual Constructor Pattern)<strong>或</strong>多态工厂模式(Polymorphic Factory Pattern)</strong></li>
<li><strong>工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象</strong></li>
<li>目的是<strong>将产品类的实例化操作延迟到工厂子类中完成</strong>，即<strong>通过工厂子类来确定究竟应该实例化哪一个具体产品类</strong></li>
</ul>
<h3 id="结构与实现-1"><a href="#结构与实现-1" class="headerlink" title="结构与实现"></a>结构与实现</h3><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401142259449.png"></p>
<p>工厂方法模式包含以下4个角色：</p>
<ul>
<li>Product（抽象产品）</li>
<li>ConcreteProduct（具体产品）</li>
<li>Factory（抽象工厂）</li>
<li>ConcreteFactory（具体工厂）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory</span> <span class="keyword">implements</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端片段</span></span><br><span class="line">……</span><br><span class="line">Factory factory;</span><br><span class="line">factory = <span class="keyword">new</span> <span class="title class_">ConcreteFactory</span>(); <span class="comment">//可通过配置文件和反射机制实现</span></span><br><span class="line">Product product;</span><br><span class="line">product = factory.factoryMethod();</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>某系统运行日志记录器(Logger)可以通过多种途径保存系统的运行日志，例如通过文件记录或数据库记录，用户可以通过修改配置文件灵活地更换日志记录方式。在设计各类日志记录器时，开发人员发现需要对日志记录器进行一些初始化工作，初始化参数的设置过程较为复杂，而且某些参数的设置有严格的先后次序，否则可能会发生记录失败。<br>为了更好地封装记录器的初始化过程并保证多种记录器切换的灵活性，现使用工厂方法模式设计该系统。</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401142310869.png"></p>
<p>在未使用配置文件和反射机制之前，<strong>更换具体工厂类需修改客户端源代码，但无须修改类库代码</strong></p>
<h3 id="反射机制与配置文件"><a href="#反射机制与配置文件" class="headerlink" title="反射机制与配置文件"></a>反射机制与配置文件</h3><p>Java反射机制(Java Reflection)</p>
<ul>
<li>Java反射(Java Reflection)是指在<strong>程序运行时获取已知名称的类或已有对象的相关信息的一种机制</strong>，包括类的方法、属性、父类等信息，还包括<strong>实例的创建和实例类型的判断</strong>等</li>
<li>Class类的实例表示正在运行的Java应用程序中的类和接口，其<strong>forName(String className)方法</strong>可以返回与带有给定字符串名的类或接口相关联的Class对象，<strong>再通过Class对象的newInstance()方法创建此对象所表示的类的一个新实例</strong>，即通过一个类名字符串得到类的实例</li>
</ul>
<p>java反射机制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过类名生成实例对象并将其返回</span></span><br><span class="line">Class c=Class.forName(“java.lang.String<span class="string">&quot;);</span></span><br><span class="line"><span class="string">Object obj=c.newInstance();</span></span><br><span class="line"><span class="string">return obj;</span></span><br></pre></td></tr></table></figure>

<p>配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;!— config.xml --&gt;</span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">className</span>&gt;</span>designpatterns.factorymethod.FileLoggerFactory<span class="tag">&lt;/<span class="name">className</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> designpatterns.factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">//XMLUtil.java</span></span><br><span class="line"><span class="keyword">import</span> javax.xml.parsers.*;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.*;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XMLUtil</span> &#123;</span><br><span class="line">    <span class="comment">//该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建DOM文档对象</span></span><br><span class="line">            <span class="type">DocumentBuilderFactory</span> <span class="variable">dFactory</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line">            <span class="type">DocumentBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> dFactory.newDocumentBuilder();</span><br><span class="line">            Document doc;							</span><br><span class="line">            doc = builder.parse(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src//designpatterns//factorymethod//config.xml&quot;</span>)); </span><br><span class="line">		</span><br><span class="line">            <span class="comment">//获取包含类名的文本结点</span></span><br><span class="line">            <span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> doc.getElementsByTagName(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">            Node classNode=nl.item(<span class="number">0</span>).getFirstChild();</span><br><span class="line">            String cName=classNode.getNodeValue();</span><br><span class="line">          </span><br><span class="line">            <span class="comment">//通过类名生成实例对象并将其返回</span></span><br><span class="line">            Class c=Class.forName(cName);</span><br><span class="line">            Object obj=c.newInstance();</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> designpatterns.factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    LoggerFactory factory;</span><br><span class="line">    Logger logger;</span><br><span class="line">    factory = (LoggerFactory)XMLUtil.getBean(); <span class="comment">//getBean()的返回类型为Object，需要进行强制类型转换</span></span><br><span class="line">    logger = factory.createLogger();</span><br><span class="line">    logger.writeLog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加新产品的步骤</p>
<ol>
<li>增加一个新的<strong>具体产品类</strong>作为抽象产品类的子类</li>
<li>增加一个新的<strong>具体工厂类</strong>作为抽象工厂类的子类，该工厂用于创建新增的具体产品对象</li>
<li>修改<strong>配置文件</strong>，用新的具体工厂类的类名字符串替换原有工厂类类名字符串</li>
<li>编译新增具体产品类和具体工厂类，运行客户端代码，即可完成新产品的增加和使用</li>
</ol>
<h3 id="工厂方法的重载"><a href="#工厂方法的重载" class="headerlink" title="工厂方法的重载"></a>工厂方法的重载</h3><p>结构图：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401142316804.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">(String args)</span>;</span><br><span class="line">    <span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">(Object obj)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseLoggerFactory</span> <span class="keyword">implements</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">()</span> &#123;</span><br><span class="line">	  <span class="comment">//使用默认方式连接数据库，代码省略</span></span><br><span class="line">	  <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatabaseLogger</span>(); </span><br><span class="line">	  <span class="comment">//初始化数据库日志记录器，代码省略</span></span><br><span class="line">	  <span class="keyword">return</span> logger;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">(String args)</span> &#123;</span><br><span class="line">	  <span class="comment">//使用参数args作为连接字符串来连接数据库，代码省略</span></span><br><span class="line">	  <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatabaseLogger</span>(); </span><br><span class="line">	  <span class="comment">//初始化数据库日志记录器，代码省略</span></span><br><span class="line">	  <span class="keyword">return</span> logger;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">  <span class="keyword">public</span> Logger <span class="title function_">createLogger</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">	  <span class="comment">//使用封装在参数obj中的连接字符串来连接数据库，代码省略</span></span><br><span class="line">	  <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatabaseLogger</span>(); </span><br><span class="line">	  <span class="comment">//使用封装在参数obj中的数据来初始化数据库日志记录器，代码省略</span></span><br><span class="line">	  <span class="keyword">return</span> logger;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他具体工厂类代码省略</span></span><br></pre></td></tr></table></figure>

<h3 id="工厂方法的隐藏"><a href="#工厂方法的隐藏" class="headerlink" title="工厂方法的隐藏"></a>工厂方法的隐藏</h3><p>目的：为了进一步简化客户端的使用<br>实现：在工厂类中直接调用产品类的业务方法，客户端无须调用工厂方法创建产品对象，<strong>直接使用工厂对象即可调用所创建的产品对象中的业务方法</strong></p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401142323506.png"></p>
<p>抽象工厂类LoggerFactory示意代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将接口改为抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line">  <span class="comment">//在工厂类中直接调用日志记录器类的业务方法writeLog()</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeLog</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="built_in">this</span>.createLogger();</span><br><span class="line">    logger.writeLog();</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> Logger <span class="title function_">createLogger</span><span class="params">()</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    LoggerFactory factory;</span><br><span class="line">    factory = (LoggerFactory)XMLUtil.getBean();</span><br><span class="line">    factory.writeLog(); <span class="comment">//直接使用工厂对象来调用产品对象的业务方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模式优缺点与适用环境"><a href="#模式优缺点与适用环境" class="headerlink" title="模式优缺点与适用环境"></a>模式优缺点与适用环境</h3><p>模式优点</p>
<ul>
<li>工厂方法用来创建客户所需要的产品，同时还<strong>向客户隐藏了哪种具体产品类将被实例化这一细节</strong></li>
<li>能够<strong>让工厂自主确定创建何种产品对象</strong>，而如何创建这个对象的细节则完全封装在具体工厂内部</li>
<li>在系统中加入新产品时，<strong>完全符合开闭原则</strong></li>
</ul>
<p>模式缺点：</p>
<ul>
<li>系统中<strong>类的个数将成对增加</strong>，在一定程度上增加了系统的复杂度，会给系统带来一些额外的开销</li>
<li><strong>增加了系统的抽象性和理解难度</strong></li>
</ul>
<p>适用环境：</p>
<ul>
<li><strong>客户端不知道它所需要的对象的类</strong>（客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体产品对象由具体工厂类创建）</li>
<li><strong>抽象工厂类通过其子类来指定创建哪个对象</strong></li>
</ul>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h3 id="产品等级结构与产品族"><a href="#产品等级结构与产品族" class="headerlink" title="产品等级结构与产品族"></a>产品等级结构与产品族</h3><ul>
<li>工厂方法模式</li>
<li><ul>
<li>每个具体工厂<strong>只有一个或者一组重载的工厂方法，只能生产一种产品</strong>，可能会导致系统中存在大量的工厂类，势必会增加系统的开销</li>
</ul>
</li>
<li>抽象工厂模式</li>
<li><ul>
<li>一个工厂<strong>可以生产一系列产品（一族产品）</strong>，极大减少了工厂类的数量</li>
</ul>
</li>
</ul>
<p>概念</p>
<ul>
<li><strong>产品等级结构</strong>：产品等级结构即产品的<strong>继承结构</strong></li>
<li><strong>产品族</strong>：产品族是指由<strong>同一个工厂生产的，位于不同产品等级结构中的一组产品</strong></li>
</ul>
<p>模式动机</p>
<ul>
<li>当系统所提供的工厂生产的具体产品并不是一个简单的对象，而是<strong>多个位于不同产品等级结构、属于不同类型的具体产品时就可以使用抽象工厂模式</strong></li>
<li>抽象工厂模式是<strong>所有形式的工厂模式中最为抽象和最具一般性的一种形式</strong></li>
</ul>
<p>抽象工厂模式：提供一个<strong>创建一系列相关或相互依赖对象的接口</strong>，而无须指定它们具体的类。</p>
<ul>
<li><strong>对象创建型</strong>模式</li>
<li>又称为**工具(Kit)**模式</li>
<li>抽象工厂模式中的具体工厂不只是创建一种产品，它<strong>负责创建一族产品</strong></li>
<li><strong>当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、更有效率</strong></li>
</ul>
<h3 id="结构与实现-2"><a href="#结构与实现-2" class="headerlink" title="结构与实现"></a>结构与实现</h3><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401152328775.png"></p>
<p>抽象工厂模式的结构</p>
<ul>
<li>AbstractFactory（抽象工厂）</li>
<li>ConcreteFactory（具体工厂）</li>
<li>AbstractProduct（抽象产品）</li>
<li>ConcreteProduct（具体产品）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> AbstractProductA <span class="title function_">createProductA</span><span class="params">()</span>; <span class="comment">//工厂方法一</span></span><br><span class="line">    <span class="keyword">public</span> AbstractProductB <span class="title function_">createProductB</span><span class="params">()</span>; <span class="comment">//工厂方法二</span></span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="comment">//工厂方法一</span></span><br><span class="line">    <span class="keyword">public</span> AbstractProductA <span class="title function_">createProductA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductA1</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//工厂方法二</span></span><br><span class="line">    <span class="keyword">public</span> AbstractProductB <span class="title function_">createProductB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductB1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><p>某软件公司要开发一套界面皮肤库，可以对基于Java的桌面软件进行界面美化。用户在使用时可以通过菜单来选择皮肤，不同的皮肤将提供视觉效果不同的按钮、文本框、组合框等界面元素，例如春天(Spring)风格的皮肤将提供浅绿色的按钮、绿色边框的文本框和绿色边框的组合框，而夏天(Summer)风格的皮肤则提供浅蓝色的按钮、蓝色边框的文本框和蓝色边框的组合框，其结构示意图如下图所示：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401151632551.png"><br>该皮肤库需要具备良好的灵活性和可扩展性，用户可以自由选择不同的皮肤，开发人员可以在不修改既有代码的基础上增加新的皮肤。<br>现使用抽象工厂模式来设计该界面皮肤库。</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401151633689.png"></p>
<p>更换皮肤，只需修改配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">className</span>&gt;</span>designpatterns.abstractfactory.SpringSkinFactory<span class="tag">&lt;/<span class="name">className</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>存在一个非常严重的问题：如果在设计之初因为考虑不全面，忘记为某种类型的界面组件(以单选按钮 RadioButton 为例)提供不同皮肤下的风格化显示，那么在往系统中增加单选按钮时将发现非常麻烦，<strong>无法在满足开闭原则的前提下增加单选按钮</strong>，原因是抽象工厂SkinFactory 中根本没有提供创建单选按钮的方法，如果需要增加单选按钮，首先需要修改抽象工厂接口 SkinFactory，在其中新增声明创建单选按钮的方法，然后逐个修改具体工厂类，增加相应方法以实现在不同的皮肤库中创建单选按钮，此外还需要修改客户端，否则单选按钮无法应用于现有系统。</p>
<h3 id="开闭原则的倾斜性"><a href="#开闭原则的倾斜性" class="headerlink" title="开闭原则的倾斜性"></a>开闭原则的倾斜性</h3><ul>
<li>增加产品族</li>
<li><ul>
<li><strong>对于增加新的产品族</strong>，抽象工厂模式很好地<strong>支持了开闭原则</strong>，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改</li>
</ul>
</li>
<li>增加新的产品等级结构</li>
<li><ul>
<li><strong>对于增加新的产品等级结构</strong>，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，<strong>违背了开闭原则</strong></li>
</ul>
</li>
<li><ul>
<li>正因为抽象工厂模式存在开闭原则的倾斜性，它以一种倾斜的方式来满足开闭原则，为增加新产品族提供方便，但不能为增加新产品结构提供这样的方便，因此<em>要求设计人员在设计之初就能够考虑全面</em>，不会在设计完成之后再向系统中增加新的产品等级结构，也不会删除已有的产品等级结构，否则将会导致系统出现较大的修改，为后续维护工作带来诸多麻烦。</li>
</ul>
</li>
</ul>
<h3 id="优缺点与适用环境-1"><a href="#优缺点与适用环境-1" class="headerlink" title="优缺点与适用环境"></a>优缺点与适用环境</h3><p>模式优点</p>
<ul>
<li><strong>隔离了具体类的生成</strong>，使得客户端并不需要知道什么被创建</li>
<li>当一个产品族中的多个对象被设计成一起工作时，它<strong>能够保证客户端始终只使用同一个产品族中的对象</strong></li>
<li><strong>增加新的产品族很方便</strong>，无须修改已有系统，<strong>符合开闭原则</strong></li>
</ul>
<p>模式缺点</p>
<ul>
<li><strong>增加新的产品等级结构麻烦</strong>，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，<strong>违背了开闭原则</strong></li>
</ul>
<p>模式适用环境</p>
<ul>
<li>一个系统<strong>不应当依赖于产品类实例如何被创建、组合和表达的细节</strong></li>
<li>系统中有多于一个的产品族，但<strong>每次只使用其中某一产品族</strong></li>
<li><strong>属于同一个产品族的产品将在一起使用</strong>，这一约束必须在系统的设计中体现出来</li>
<li><strong>产品等级结构稳定</strong>，在设计完成之后不会向系统中增加新的产品等级结构或者删除已有的产品等级结构</li>
</ul>
<h2 id="建造者模式——自学"><a href="#建造者模式——自学" class="headerlink" title="建造者模式——自学"></a>建造者模式——自学</h2><p>建造者模式：将一个<strong>复杂对象的构建与它的表示分离</strong>，使得同样的构建过程可以创建不同的表示。</p>
<ul>
<li>将客户端与包含多个部件的复杂对象的创建过程分离，<strong>客户端无须知道复杂对象的内部组成部分与装配方式</strong>，只需要知道所需建造者的类型即可</li>
<li><strong>关注如何逐步创建一个复杂的对象</strong>，不同的建造者定义了不同的创建过程</li>
</ul>
<p>结构：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401151656695.png"></p>
<p>建造者模式的结构：</p>
<ul>
<li>Builder（抽象建造者）</li>
<li>ConcreteBuilder（具体建造者）</li>
<li>Product（产品）</li>
<li>Director（指挥者）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 复杂对象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String partA; <span class="comment">//定义部件，部件可以是任意类型，包括值类型和引用类型</span></span><br><span class="line">	<span class="keyword">private</span> String partB;</span><br><span class="line">	<span class="keyword">private</span> String partC;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//partA的Getter方法和Setter方法省略</span></span><br><span class="line">	<span class="comment">//partB的Getter方法和Setter方法省略</span></span><br><span class="line">	<span class="comment">//partC的Getter方法和Setter方法省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象建造者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="comment">//创建产品对象</span></span><br><span class="line">   <span class="keyword">protected</span> Product product=<span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildPartA</span><span class="params">()</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildPartB</span><span class="params">()</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildPartC</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//返回产品对象</span></span><br><span class="line">   <span class="keyword">public</span> Product <span class="title function_">getResult</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> product;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体建造者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteBuilder1</span> <span class="keyword">extends</span> <span class="title class_">Builder</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildPartA</span><span class="params">()</span> &#123;</span><br><span class="line">      product.setPartA(<span class="string">&quot;A1&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildPartB</span><span class="params">()</span> &#123;</span><br><span class="line">      product.setPartB(<span class="string">&quot;B1&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildPartC</span><span class="params">()</span> &#123;</span><br><span class="line">      product.setPartC(<span class="string">&quot;C1&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指挥者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> Builder builder;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Director</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.builder=builder;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBuilder</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.builder=builer;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//产品构建与组装方法</span></span><br><span class="line">   <span class="keyword">public</span> Product <span class="title function_">construct</span><span class="params">()</span> &#123;</span><br><span class="line">      builder.buildPartA();</span><br><span class="line">      builder.buildPartB();</span><br><span class="line">      builder.buildPartC();</span><br><span class="line">      <span class="keyword">return</span> builder.getResult();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户类片段</span></span><br><span class="line">……</span><br><span class="line"><span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteBuilder1</span>(); <span class="comment">//可通过配置文件实现</span></span><br><span class="line"><span class="type">Director</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>(builder);</span><br><span class="line"><span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> director.construct();</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><p>某游戏软件公司决定开发一款基于角色扮演的多人在线网络游戏，玩家可以在游戏中扮演虚拟世界中的一个特定角色，角色根据不同的游戏情节和统计数据（例如力量、魔法、技能等）具有不同的能力，角色也会随着不断升级而拥有更加强大的能力。<br>作为该游戏的一个重要组成部分，需要对游戏角色进行设计，而且随着该游戏的升级将不断增加新的角色。通过分析发现，游戏角色是一个复杂对象，它包含性别、面容等多个组成部分，不同类型的游戏角色，其性别、面容、服装、发型等外部特性都有所差异，例如“天使”拥有美丽的面容和披肩的长发，并身穿一袭白裙；而“恶魔”极其丑陋，留着光头并穿一件刺眼的黑衣。<br>无论是何种造型的游戏角色，它的创建步骤都大同小异，都需要逐步创建其组成部分，再将各组成部分装配成一个完整的游戏角色。现使用建造者模式来实现游戏角色的创建。</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401151701424.png"></p>
<p>结果及分析</p>
<ul>
<li>如果需要更换具体角色建造者，只需要修改<strong>配置文件</strong></li>
<li>当需要增加新的具体角色建造者时，只需将新增具体角色建造者作为抽象角色建造者的子类，然后修改配置文件即可，原有代码无须修改，<strong>完全符合开闭原则</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">className</span>&gt;</span>designpatterns.builder.AngelBuilder<span class="tag">&lt;/<span class="name">className</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="深入讨论"><a href="#深入讨论" class="headerlink" title="深入讨论"></a>深入讨论</h3><p>省略Director</p>
<ul>
<li>将Director和抽象建造者Builder合并</li>
<li>将construct()方法中的参数去掉，直接在construct()方法中调用buildPartX()方法</li>
</ul>
<p>钩子方法的引入<br>钩子方法(Hook Method)：返回类型通常为boolean类型，方法名一般为isXXX()</p>
<h3 id="优缺点与适用环境-2"><a href="#优缺点与适用环境-2" class="headerlink" title="优缺点与适用环境"></a>优缺点与适用环境</h3><p>模式优点</p>
<ul>
<li>客户端不必知道产品内部组成的细节，<strong>将产品本身与产品的创建过程解耦</strong>，使得<strong>相同的创建过程可以创建不同的产品对象</strong></li>
<li>每一个具体建造者都相对独立，与其他的具体建造者无关，因此可以<strong>很方便地替换具体建造者或增加新的具体建造者</strong>，扩展方便，<strong>符合开闭原则</strong></li>
<li>可以<strong>更加精细地控制产品的创建过程</strong></li>
</ul>
<p>模式缺点</p>
<ul>
<li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，<strong>如果产品之间的差异性很大，不适合使用建造者模式</strong>，因此其使用范围受到一定的限制</li>
<li>如果<strong>产品的内部变化复杂</strong>，可能会<strong>需要定义很多具体建造者类</strong>来实现这种变化，导致系统变得很庞大，增加了系统的理解难度和运行成本</li>
</ul>
<p>模式适用环境</p>
<ul>
<li><strong>需要生成的产品对象有复杂的内部结构</strong>，这些产品对象通常包含多个成员变量</li>
<li><strong>需要生成的产品对象的属性相互依赖</strong>，需要指定其生成顺序</li>
<li><strong>对象的创建过程独立于创建该对象的类</strong>。在建造者模式中通过引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类和客户类中</li>
<li><strong>隔离复杂对象的创建和使用</strong>，并使得相同的创建过程可以创建不同的产品</li>
</ul>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式：使用原型实例指定待创建对象的类型，并且<strong>通过复制这个原型来创建新的对象</strong>。</p>
<ul>
<li>工作原理：将一个原型对象传给要发动创建的对象（即客户端对象），这个要发动创建的对象<strong>通过请求原型对象复制自己来实现创建过程</strong></li>
<li>创建新对象（也称为克隆对象）的<strong>工厂就是原型类自身</strong>，<strong>工厂方法</strong>由负责复制原型对象的<strong>克隆方法</strong>来实现</li>
<li>通过克隆方法所创建的对象是<strong>全新的对象</strong>，它们在内存中拥有新的地址，每一个克隆对象都是<strong>独立的</strong></li>
<li>通过不同的方式对克隆对象进行修改以后，可以<strong>得到一系列相似但不完全相同的对象</strong></li>
<li>由于在软件系统中经常会遇到需要创建多个相同或者相似对象的情况，因此原型模式在软件开发中具有较高的使用频率</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401151716713.png"></p>
<h3 id="结构与实现-3"><a href="#结构与实现-3" class="headerlink" title="结构与实现"></a>结构与实现</h3><p>原型模式的结构</p>
<ul>
<li><p>Prototype（抽象原型类）</p>
</li>
<li><p>ConcretePrototype（具体原型类）</p>
</li>
<li><p>Client（客户类）</p>
</li>
<li><p>浅克隆(Shallow Clone)：当原型对象被复制时，<strong>只复制它本身和其中包含的值类型的成员变量，而引用类型的成员变量并没有复制</strong><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401151718693.png"></p>
</li>
<li><p>深克隆(Deep Clone)：除了对象本身被复制外，<strong>对象所包含的所有成员变量也将被复制</strong><br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401151719852.png"></p>
</li>
</ul>
<p>通用的克隆实现方法是在具体原型类的克隆方法中实例化一个与自身类型相同的对象并将其返回，同时将相关的参数传入新创建的对象中，保证它们的成员变量相同。示意代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> Prototype <span class="title function_">clone</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> <span class="keyword">extends</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String attr;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAttr</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.attr = attr;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getAttr</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.attr;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 克隆方法</span></span><br><span class="line">   <span class="keyword">public</span> Prototype <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">Prototype</span> <span class="variable">prototype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>();  <span class="comment">// 创建新对象</span></span><br><span class="line">      prototype.setAttr(<span class="built_in">this</span>.attr);</span><br><span class="line">      <span class="keyword">return</span> prototype;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在客户端类中只需要创建一个<code>ConcretePrototype</code>对象作为原型对象，然后调用其<code>clone()</code>方法即可得到对应的克隆对象，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="type">ConcretePrototype</span> <span class="variable">prototype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>();</span><br><span class="line">prototype.setAttr(<span class="string">&quot;Sunny&quot;</span>);</span><br><span class="line"><span class="type">ConcretePrototype</span> <span class="variable">copy</span> <span class="operator">=</span> (ConcretePrototype)prototype.clone();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在原型模式的通用实现方法中，可通过手工编写clone()方法来实现浅克隆和深克隆。对于引用类型的对象，可以在clone()方法中通过赋值的方式来实现复制，这是一种浅克降实现方案；如果在clone()方法中通过创建一个全新的成员对象来实现复制，则是一种深克隆实现方案。</p>
<p>在 Java 语言中，所有的 Java 类均继承自 java.lang.Object 类，Object 类提供了一个 clone() 方法，可以将一个 Java 对象复制一份。因此在 Java 中可以直接使用 Object 提供的 clone() 方法来实现对象的浅克隆。<br>需要注意的是能够实现克隆的 Java 类必须实现一个标识接口 Cloneable ，表示这个 Java 类支持被复制。如果一个类没有实现这个接口但是调用了 lone() 方法， Java 编译器将抛出一个 CloneNotSupportedException 异常。如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">public</span> Prototype <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         object = <span class="built_in">super</span>.clone();  <span class="comment">// 浅克隆</span></span><br><span class="line">      &#125; <span class="keyword">catch</span>(CloneNotSupportedException exception) &#123;</span><br><span class="line">         System.err.println(<span class="string">&quot;Not support cloneable&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> (Prototype) object;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 语言中的 clone()方法满足以下几点:</p>
<ol>
<li>对任何对象 x ，都有 x.clone()!&#x3D;x ，即克隆对象与原型对象不是同一个对象</li>
<li>对任何对象 x ，都有 x.clone().getClass()&#x3D;&#x3D;x.getClass() ，即克隆对象与原型对象的类型一样。</li>
<li>如果对象 x 的 equals() 方法定义恰当，那么 x.clone().equals(x)应该成立<br>为了获取对象的一个克隆，可以直接利用 Object 类的 clone()方法，具体步骤如下:</li>
<li>在派生类中覆盖基类的 clone() 方法，并声明为 public。</li>
<li>在派生类的 clone() 方法中调用 super.clone()。</li>
<li>派生类需实现 Cloneable 接口。<br>此时，Object 类相当于抽象原型类，所有实现了 Cloneable 接口的类相当于具体原型类</li>
</ol>
<h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><p>在使用某OA系统时，有些岗位的员工发现他们每周的工作都大同小异，因此在填写工作周报时很多内容都是重复的，为了提高工作周报的创建效率，大家迫切希望有一种机制能够快速创建相同或者相似的周报，包括创建周报的附件。<br>试使用原型模式对该OA系统中的工作周报创建模块进行改进。</p>
<p><strong>浅克隆</strong>：周报不同，附件相同<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401151735685.png"></p>
<p>为了能够在复制周报的同时也能够复制附件对象，需要采用深克隆机制。在 Java 语言中可以通过<strong>序列化(Serialization)<strong>等方式来实现深克隆。</strong>序列化就是将对象写到流的过程，写到流中的对象是原有对象的一个复制，而原对象仍然存在于内存中。</strong>通过序列化实现的复制不仅可以复制对象本身，而且可以<strong>复制其引用的成员对象</strong>，因此通过序列化将对象写到个流中，再从流里将其读出来，可以实现深克隆。需要注意的是能够实现序列化的对象<strong>其类必须实现 Serializable 接口</strong>，否则无法实现序列化操作。<br>下面使用深克隆技术来实现工作周报和附件对象的复制，由于要将附件对象和工作周报对象都写人流中，因此两个类均需要实现 Serializable 接口。</p>
<p><strong>深克隆</strong>：周报附件均不同<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401151736911.png"></p>
<h3 id="原型管理器"><a href="#原型管理器" class="headerlink" title="原型管理器"></a>原型管理器</h3><p><strong>原型管理器(Prototype Manager)<strong>将多个原型对象存储在一个</strong>集合</strong>中供客户端使用，它是一个<strong>专门负责克隆对象的工厂</strong>，其中<strong>定义了一个集合用于存储原型对象</strong>，如果需要某个原型对象的一个克隆，可以通过复制集合中对应的原型对象来获得。</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401151741010.png"></p>
<p>在实际开发中可以将 PrototypeManager 设计为单例类，确保系统中有且仅有一个 PrototypeManager 对象，这样既有利于节省系统资源，还可以更好地对原型管理器对象进行控制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrototypeManager</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">Hashtable</span> <span class="variable">prototypeTable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>(); <span class="comment">//使用Hashtable存储原型对象</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">PrototypeManager</span><span class="params">()</span>&#123;</span><br><span class="line">      prototypeTable.put(<span class="string">&quot;A&quot;</span>, <span class="keyword">new</span> <span class="title class_">ConcretePrototypeA</span>());</span><br><span class="line">      prototypeTable.put(<span class="string">&quot;B&quot;</span>, <span class="keyword">new</span> <span class="title class_">ConcretePrototypeB</span>());</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String key, Prototype prototype)</span>&#123;</span><br><span class="line">      prototypeTable.put(key, prototype);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Prototype <span class="title function_">get</span><span class="params">(String key)</span>&#123;</span><br><span class="line">      <span class="type">Prototype</span> <span class="variable">clone</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      clone = ((Prototype) prototypeTable.get(key)).clone(); <span class="comment">//通过克隆方法创建新对象</span></span><br><span class="line">      <span class="keyword">return</span> clone;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优缺点与适用环境-3"><a href="#优缺点与适用环境-3" class="headerlink" title="优缺点与适用环境"></a>优缺点与适用环境</h3><p>模式优点</p>
<ul>
<li><strong>简化对象的创建过程</strong>，通过复制一个已有实例可以<strong>提高新实例的创建效率</strong></li>
<li><strong>扩展性较好</strong></li>
<li>提供了<strong>简化的创建结构</strong>，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品</li>
<li>可以使用深克隆的方式<strong>保存对象的状态</strong>，以便在需要的时候使用，可辅助实现撤销操作</li>
</ul>
<p>模式缺点</p>
<ul>
<li><strong>需要为每一个类配备一个克隆方法</strong>，而且该克隆方法位于一个类的内部，当<strong>对已有的类进行改造时，需要修改源代码，违背了开闭原则</strong></li>
<li>在<strong>实现深克隆时需要编写较为复杂的代码</strong>，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦</li>
</ul>
<p>模式适用环境</p>
<ul>
<li><strong>创建新对象成本较大</strong>，新对象可以通过复制已有对象来获得，如果是相似对象，则可以对其成员变量稍作修改</li>
<li>系统要保存对象的状态，而<strong>对象的状态变化很小</strong></li>
<li>需要避免使用分层次的工厂类来创建分层次的对象</li>
<li><strong>Ctrl + C -&gt; Ctrl + V</strong></li>
</ul>
<h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401151749592.png"></p>
<p>A D C</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>如何保证一个类只有一个实例并且这个实例易于被访问？</p>
<ul>
<li><strong>全局变量</strong>：可以确保对象随时都可以被访问，但<strong>不能防止创建多个对象</strong></li>
<li><strong>让类自身负责创建和保存它的唯一实例</strong>，并保证不能创建其他实例，它还提供一个访问该实例的方法</li>
</ul>
<p>单例模式：确保一个类<strong>只有一个实例</strong>，并提供一个<strong>全局访问点</strong>来访问这个唯一实例。</p>
<ul>
<li>某个类<strong>只能有一个实例</strong></li>
<li>必须<strong>自行创建这个实例</strong></li>
<li>必须<strong>自行向整个系统提供这个实例</strong></li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401151901644.png"></p>
<ul>
<li>对于 Singleton(单例)，在单例类的内部创建它的唯一实例，并通过静态方法 getInstance() 让客户端可以使用它的唯一实例</li>
<li>为了防止在外部对单例类实例化,**将其构造函数的可见性设为 private **;</li>
<li>在单例类内部定义了一个 Singleton 类型的静态对象作为供外部共享访问的唯一实例。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;  <span class="comment">// 静态私有变量</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Singleton &#123;&#125;  <span class="comment">// 私有构造函数，无法通过 new 来实例化</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 静态公有方法，返回唯一实例</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">         instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><p>某软件公司承接了一个服务器负载均衡(Load Balance)软件的开发工作，该软件运行在一台负载均衡服务器上，可以将并发访问和数据流量分发到服务器集群中的多台设备上进行并发处理，提高了系统的整体处理能力，缩短了响应时间。由于集群中的服务器需要动态删减，且客户端请求需要统一分发，因此需要确保负载均衡器的唯一性，只能有一个负载均衡器来负责服务器的管理和请求的分发，否则将会带来服务器状态的不一致以及请求分配冲突等问题。如何确保负载均衡器的唯一性是该软件成功的关键，试使用单例模式设计服务器负载均衡器。</p>
<p>在图中将负载均衡器 LoadBalancer 设计为单例类，其中包含一个存储服务器信息的集合 serverList，每次在 serverList 中随机选择一台服务器来响应客户端的请求。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401151906982.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LoadBalancer：负载均衡类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoadBalancer</span> &#123;</span><br><span class="line">   <span class="comment">// 私有静态成员变量，存储唯一实例</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">LoadBalancer</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="comment">// 服务器集合</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">List</span> <span class="variable">serverList</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 私有构造函数</span></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">LoadBalancer</span><span class="params">()</span> &#123;</span><br><span class="line">      serverList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 公有静态成员方法，返回唯一实例</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> LoadBalancer <span class="title function_">getLoadBalancer</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">         instance = <span class="keyword">new</span> <span class="title class_">LoadBalancer</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 增加服务器</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addServer</span><span class="params">(String server)</span> &#123;</span><br><span class="line">      ServerList.add(server);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 删除服务器</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteServer</span><span class="params">(String server)</span> &#123;</span><br><span class="line">      serverList.remove(server);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用 Random 类随机获取服务器</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getServer</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">      <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> random.nextInt(serverList.size());</span><br><span class="line">      <span class="keyword">return</span> (String)serverList.get(i);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Client：客户端测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">      <span class="comment">// 创建4个 LoadBalancer 对象</span></span><br><span class="line">      LoadBalancer balancer1, balancer2, balancer3, balancer4;</span><br><span class="line">      balancer1 = LoadBalancer.getLoadBalancer();</span><br><span class="line">      balancer2 = LoadBalancer.getLoadBalancer();</span><br><span class="line">      balancer3 = LoadBalancer.getLoadBalancer();</span><br><span class="line">      balancer4 = LoadBalancer.getLoadBalancer();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 判断服务器均衡负载器是否相同</span></span><br><span class="line">      <span class="keyword">if</span> (balancer1 == balancer2 &amp;&amp; balancer2 == balancer3 &amp;&amp; balancer3 == balancer4) &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;服务器均衡负载器具有唯一性！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 增加服务器</span></span><br><span class="line">      balancer1.addServer(<span class="string">&quot;Server 1&quot;</span>);</span><br><span class="line">      balancer1.addServer(<span class="string">&quot;Server 2&quot;</span>);</span><br><span class="line">      balancer1.addServer(<span class="string">&quot;Server 3&quot;</span>);</span><br><span class="line">      balancer1.addServer(<span class="string">&quot;Server 4&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 模拟客户端请求的分发</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">         <span class="type">String</span> <span class="variable">server</span> <span class="operator">=</span> balancer1.getServer();</span><br><span class="line">         System.out.println(<span class="string">&quot;分发请求至服务器：&quot;</span> + server);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="饿汉式单例与懒汉式单例"><a href="#饿汉式单例与懒汉式单例" class="headerlink" title="饿汉式单例与懒汉式单例"></a>饿汉式单例与懒汉式单例</h3><p>饿汉式单例类(Eager Singleton)：<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401151918445.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EagerSingleton</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">EagerSingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EagerSingleton</span>();</span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">EagerSingleton</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> EagerSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当类被加载时，静态变量<code>instance</code>会被初始化，此时类的私有构造函数会被调用，单例类的唯一实例将被创建。</p>
<p>懒汉式单例类(Lazy Singleton)：构造函数也是私有的，但被加载时不会将自己实例化，而在第一次调用<code>getInstance()</code>方法时实例化，在类自行加载时并不自行实例化，称为**延迟加载(Lazy Load)**技术，即需要时再加载实例。<br><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401151922920.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span>() &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">LazySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 双重检查锁定</span></span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 锁定代码段，防止多个线程同时访问</span></span><br><span class="line">         <span class="keyword">synchronized</span> (LazySingleton.class) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>饿汉式单例类：无须考虑多个线程同时访问的问题；调用速度和反应时间优于懒汉式单例；资源利用效率不及懒汉式单例；系统加载时间可能会比较长</p>
</li>
<li><p>懒汉式单例类：实现了延迟加载；必须处理好多个线程同时访问的问题；需通过双重检查锁定等机制进行控制，将导致系统性能受到一定影响</p>
</li>
<li><p>使用静态内部类</p>
</li>
<li><p>使用枚举类</p>
</li>
</ul>
<h3 id="优缺点与适用环境-4"><a href="#优缺点与适用环境-4" class="headerlink" title="优缺点与适用环境"></a>优缺点与适用环境</h3><p>模式优点</p>
<ul>
<li>提供了<strong>对唯一实例的受控访问</strong></li>
<li>可以<strong>节约系统资源，提高系统的性能</strong></li>
<li>允许可变数目的实例（<strong>多例类</strong>）</li>
</ul>
<p>模式缺点</p>
<ul>
<li><strong>扩展困难</strong>（缺少抽象层）</li>
<li>单例类的<strong>职责过重</strong></li>
<li>由于自动垃圾回收机制，可能会导致共享的单例对象的<strong>状态丢失</strong></li>
</ul>
<p>适用环境</p>
<ul>
<li>系统<strong>只需要一个实例对象</strong>，或者因为资源消耗太大而<strong>只允许创建一个对象</strong></li>
<li>客户调用类的单个实例<strong>只允许使用一个公共访问点</strong>，除了该公共访问点，不能通过其他途径访问该实例</li>
</ul>
<h3 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h3><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401151933170.png"></p>
<p>B B B</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="结构型模式概述"><a href="#结构型模式概述" class="headerlink" title="结构型模式概述"></a>结构型模式概述</h3><ul>
<li><p><strong>结构型模式(Structural Pattern)关注如何将现有类或对象组织在一起形成更加强大的结构</strong></p>
</li>
<li><p>不同的结构型模式<strong>从不同的角度组合类或对象</strong>，它们在尽可能满足各种面向对象设计原则的同时为类或对象的组合提供一系列巧妙的解决方案</p>
</li>
<li><p>类结构型模式</p>
</li>
<li><ul>
<li><strong>关心类的组合</strong>，由多个类组合成一个更大的系统，在类结构型模式中一般只存在<strong>继承关系和实现关系</strong></li>
</ul>
</li>
<li><p>对象结构型模式</p>
</li>
<li><ul>
<li><strong>关心类与对象的组合</strong>，通过<strong>关联关系，</strong>在一个类中定义另一个类的实例对象，然后通过该对象调用相应的方法</li>
</ul>
</li>
<li><p>合成复用原则</p>
</li>
<li><ul>
<li><strong>大部分结构型模式是对象结构型模式</strong></li>
</ul>
</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401161304650.png"></p>
<h3 id="适配器模式概述"><a href="#适配器模式概述" class="headerlink" title="适配器模式概述"></a>适配器模式概述</h3><p>适配器模式：将一个类的接口转换成客户希望的另一个接口。适配器模式<strong>让那些接口不兼容的类可以一起工作</strong>。</p>
<ul>
<li>别名为<strong>包装器(Wrapper)模式</strong></li>
<li>定义中所提及的接口是指广义的接口，它<strong>可以表示一个方法或者方法的集合</strong></li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401151937330.png"></p>
<ul>
<li>Target(目标抽象类)：定义客户所需的接口，可以是一个抽象类或接口，也可以是具体类</li>
<li>Adapter(适配器类)：可以调用另一个接口，作为一个转换器，对 Adaptee 和 Target 进行适配</li>
<li>Adaptee(适配者类)：被适配的角色，定义了一个已经存在的接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类适配器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">extends</span> <span class="title class_">Adaptee</span> <span class="keyword">implements</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>.specificRequest();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象适配器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">extends</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">   <span class="comment">// 维持一个对适配者对象的引用</span></span><br><span class="line">   <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Adapter</span><span class="params">(Adaptee adaptee)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.adaptee = adaptee;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">      adaptee.specificRequest();  <span class="comment">// 转发调用</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h3><p>某公司欲开发一款儿童玩具汽车，为了更好地吸引小朋友的注意力，该玩具汽车在移动过程中伴随着灯光闪烁和声音提示。在该公司以往的产品中已经实现了控制灯光闪烁（例如警灯闪烁）和声音提示（例如警笛音效）的程序，为了重用先前的代码并且使得汽车控制软件具有更好的灵活性和扩展性，现使用适配器模式设计该玩具汽车控制软件。</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401151943334.png"></p>
<h3 id="缺省适配器"><a href="#缺省适配器" class="headerlink" title="缺省适配器"></a>缺省适配器</h3><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401151945055.png"></p>
<ul>
<li>ServiceInterface(适配者接口)</li>
<li>AbstractServiceClass(缺省适配器类)：使用空方法的形式实现了在 ServiceInterface 接口中声明的方法。通常将它定义为抽象类，因为对它进行实例化没有任何意义。</li>
<li>ConcreteServiceClass(具体业务类)：缺省适配器类的子类，在没有引入适配器前它需要实现适配者接口，再有了缺省适配器之后可以直接继承该适配器类</li>
</ul>
<p>缺省适配器类典型代码片段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractServiceClass</span> <span class="keyword">implements</span> <span class="title class_">ServiceInterface</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serviceMethod</span><span class="params">()</span> &#123;&#125;  <span class="comment">// 空方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双向适配器"><a href="#双向适配器" class="headerlink" title="双向适配器"></a>双向适配器</h3><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401151949514.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">implements</span> <span class="title class_">Target</span>, Adaptee &#123; </span><br><span class="line">   <span class="keyword">private</span> Target target;</span><br><span class="line">   <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Adapter</span><span class="params">(Target target)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.target = target;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Adapter</span><span class="params">(Adaptee adaptee)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.adaptee = adaptee;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">      adaptee.specificRequest();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">specificRequest</span><span class="params">()</span> &#123;</span><br><span class="line">      target.request();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优缺点与适配环境"><a href="#优缺点与适配环境" class="headerlink" title="优缺点与适配环境"></a>优缺点与适配环境</h3><p>模式优点</p>
<ul>
<li>将<strong>目标类和适配者类解耦</strong>，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构</li>
<li><strong>增加了类的透明性和复用性</strong>，提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用</li>
<li><strong>灵活性和扩展性非常好</strong></li>
<li>类适配器模式：置换一些适配者的方法很方便</li>
<li>对象适配器模式：可以把多个不同的适配者适配到同一个目标，还可以适配一个适配者的子类</li>
</ul>
<p>模式缺点</p>
<ul>
<li>类适配器模式：<ol>
<li>一次最多只能适配一个适配者类，不能同时适配多个适配者；</li>
<li>适配者类不能为最终类；</li>
<li>目标抽象类只能为接口，不能为类</li>
</ol>
</li>
<li>对象适配器模式：在适配器中置换适配者类的某些方法比较麻烦</li>
</ul>
<h3 id="习题-2"><a href="#习题-2" class="headerlink" title="习题"></a>习题</h3><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401151953018.png"></p>
<p>B C（Java不支持多继承）A A  </p>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>桥接模式：将<strong>抽象部分</strong>与它的<strong>实现部分解耦</strong>，使得两者都能够独立变化。</p>
<ul>
<li><strong>对象结构型</strong>模式</li>
<li>又被称为**柄体(Handle and Body)<strong>模式或</strong>接口(Interface)**模式</li>
<li>用<strong>抽象关联</strong>取代了传统的多层继承</li>
<li>将类之间的静态继承关系转换为<strong>动态的对象组合关系</strong></li>
</ul>
<h3 id="结构与实现-4"><a href="#结构与实现-4" class="headerlink" title="结构与实现"></a>结构与实现</h3><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401152012875.png"></p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401152013703.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现类接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Implementor</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationImpl</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteImplementor</span> <span class="keyword">implements</span> <span class="title class_">Implementor</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationImpl</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 具体业务方法的实现</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Abstraction</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span> Implementor impl;  <span class="comment">// 定义实现类接口对象</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setImpl</span><span class="params">(Implementor impl)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.impl = impl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>;  <span class="comment">// 声明抽象业务方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩充抽象类（细化抽象类）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title class_">Abstraction</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// 业务代码</span></span><br><span class="line">      impl.operationImpl();  <span class="comment">// 调用实现类的方法</span></span><br><span class="line">      <span class="comment">// 业务代码</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例-9"><a href="#实例-9" class="headerlink" title="实例"></a>实例</h3><p>某软件公司要开发一个跨平台图像浏览系统，要求该系统能够显示BMP、JPG、GIF、PNG等多种格式的文件，并且能够在Windows、Linux、UNIX等多个操作系统上运行。系统首先将各种格式的文件解析为像素矩阵(Matrix)，然后将像素矩阵显示在屏幕上，在不同的操作系统中可以调用不同的绘制函数来绘制像素矩阵。另外，系统需具有较好的扩展性，以便在将来支持新的文件格式和操作系统。试使用桥接模式设计该跨平台图像浏览系统。</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401152021307.png"></p>
<h3 id="桥接模式与适配器模式的联用"><a href="#桥接模式与适配器模式的联用" class="headerlink" title="桥接模式与适配器模式的联用"></a>桥接模式与适配器模式的联用</h3><ul>
<li>桥接模式：用于系统的初步设计，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化</li>
<li>适配器模式：当发现系统与已有类无法协同工作时</li>
</ul>
<h3 id="优缺点与适用环境-5"><a href="#优缺点与适用环境-5" class="headerlink" title="优缺点与适用环境"></a>优缺点与适用环境</h3><p>模式优点</p>
<ul>
<li><strong>分离抽象接口及其实现部分</strong></li>
<li>可以取代多层继承方案，<strong>极大地减少了子类的个数</strong></li>
<li><strong>提高了系统的可扩展性</strong>，在两个变化维度中任意扩展一个维度，不需要修改原有系统，符合开闭原则</li>
</ul>
<p>模式缺点</p>
<ul>
<li>会<strong>增加系统的理解与设计难度</strong>，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程</li>
<li><strong>正确识别出系统中两个独立变化的维度并不是一件容易的事情</strong></li>
</ul>
<p>模式适用环境</p>
<ul>
<li>需要在抽象化和具体化之间增加更多的灵活性，<strong>避免在两个层次之间建立静态的继承关系</strong></li>
<li>抽象部分和实现部分可以以继承的方式<strong>独立扩展而互不影响</strong></li>
<li>一个类<strong>存在两个（或多个）独立变化的维度</strong>，且这两个（或多个）维度都需要独立地进行扩展</li>
<li><strong>不希望使用继承</strong>或<strong>因为多层继承导致系统类的个数急剧增加</strong>的系统</li>
</ul>
<h3 id="习题-3"><a href="#习题-3" class="headerlink" title="习题"></a>习题</h3><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401152027591.png"></p>
<ol>
<li>B D</li>
<li>C</li>
<li>C</li>
</ol>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>组合模式：组合多个对象形成<strong>树形结构</strong>以表示<strong>具有部分-整体关系的层次结构</strong>。组合模式让客户端可以<strong>统一</strong>对待单个对象和组合对象。</p>
<ul>
<li>又称为“部分-整体”(Part-Whole)模式</li>
<li>将对象组织到<strong>树形结构中</strong>，可以用来描述整体与部分的关系</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401152039016.png"></p>
<ul>
<li>Component（抽象构件）：可以是接口或抽象类，为叶子构件和容器构件对象声明接口</li>
<li>Leaf（叶子构件）</li>
<li>Composite（容器构件）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象构件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component c)</span>; <span class="comment">//增加成员</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component c)</span>; <span class="comment">//删除成员</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span>; <span class="comment">//获取成员</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>;  <span class="comment">//业务方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 叶子构件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leaf</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component c)</span> &#123; </span><br><span class="line">      <span class="comment">//异常处理或错误提示</span></span><br><span class="line">   &#125;	</span><br><span class="line">	</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component c)</span> &#123; </span><br><span class="line">      <span class="comment">//异常处理或错误提示</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span> &#123; </span><br><span class="line">      <span class="comment">//异常处理或错误提示</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//叶子构件具体业务方法的实现</span></span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容器构件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Composite</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> ArrayList&lt;Component&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Component&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component c)</span> &#123;</span><br><span class="line">      list.add(c);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component c)</span> &#123;</span><br><span class="line">      list.remove(c);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (Component)list.get(i);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//容器构件具体业务方法的实现，将递归调用成员构件的业务方法</span></span><br><span class="line">      <span class="keyword">for</span>(Object obj:list) &#123;</span><br><span class="line">         ((Component)obj).operation();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例-10"><a href="#实例-10" class="headerlink" title="实例"></a>实例</h3><p>某软件公司欲开发一个杀毒(Antivirus)软件，该软件既可以对某个文件夹(Folder)杀毒，也可以对某个指定的文件(File)进行杀毒。该杀毒软件还可以根据各类文件的特点，为不同类型的文件提供不同的杀毒方式，例如图像文件(ImageFile)和文本文件(TextFile)的杀毒方式就有所差异。现使用组合模式来设计该杀毒软件的整体框架。</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401152043036.png"></p>
<p>结果及分析</p>
<ul>
<li>如果需要更换操作节点，例如只对文件夹“文本文件”进行杀毒，客户端代码<strong>只需修改一行</strong>即可，例如将代码<code>folder1.killVirus()</code>改为<code>folder3.killVirus()</code></li>
<li>在具体实现时，可以<strong>创建图形化界面让用户来选择所需操作的根节点</strong>，无须修改源代码，符合开闭原则</li>
</ul>
<h3 id="透明安全-amp-安全组合模式"><a href="#透明安全-amp-安全组合模式" class="headerlink" title="透明安全&amp;安全组合模式"></a>透明安全&amp;安全组合模式</h3><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401152046573.png"></p>
<p>安全组合模式</p>
<ul>
<li>抽象构件Component中<strong>没有声明任何用于管理成员对象的方法，而是在Composite类中声明并实现这些方法</strong></li>
<li><strong>对于叶子对象，客户端不可能调用到这些方法</strong></li>
<li>缺点是<strong>不够透明，客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件</strong></li>
</ul>
<h3 id="优缺点与适用环境-6"><a href="#优缺点与适用环境-6" class="headerlink" title="优缺点与适用环境"></a>优缺点与适用环境</h3><p>模式优点</p>
<ul>
<li>可以清楚地<strong>定义分层次的复杂对象</strong>，表示对象的全部或部分层次，<strong>让客户端忽略了层次的差异</strong>，方便对整个层次结构进行控制</li>
<li>客户端可以<strong>一致地使用一个组合结构或其中单个对象</strong>，不必关心处理的是单个对象还是整个组合结构，<strong>简化了客户端代码</strong></li>
<li><strong>增加新的容器构件和叶子构件都很方便，符合开闭原则</strong></li>
<li>为<strong>树形结构的面向对象实现</strong>提供了一种灵活的解决方案</li>
</ul>
<p>模式缺点</p>
<ul>
<li>在增加新构件时<strong>很难对容器中的构件类型进行限制</strong></li>
</ul>
<p>模式适用环境</p>
<ul>
<li>在<strong>具有整体和部分的层次结构</strong>中，希望通过一种方式忽略整体与部分的差异，<strong>客户端可以一致地对待它们</strong></li>
<li>在一个使用<strong>面向对象语言开发的系统</strong>中需要处理一个<strong>树形结构</strong></li>
<li>在一个系统中能够<strong>分离出叶子对象和容器对象</strong>，而且它们的类型不固定，<strong>需要增加一些新的类型</strong></li>
</ul>
<h3 id="习题-4"><a href="#习题-4" class="headerlink" title="习题"></a>习题</h3><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401152047491.png"></p>
<ol>
<li>B</li>
<li>B</li>
<li>C</li>
</ol>
<h2 id="装饰模式——自学"><a href="#装饰模式——自学" class="headerlink" title="装饰模式——自学"></a>装饰模式——自学</h2><ul>
<li>可以<strong>在不改变一个对象本身功能的基础上给对象增加额外的新行为</strong></li>
<li>是一种<strong>用于替代继承的技术</strong>，它通过一种无须定义子类的方式给<strong>对象动态增加职责</strong>，使用对象之间的<strong>关联关系</strong>取代类之间的<strong>继承关系</strong></li>
<li>引入了<strong>装饰类</strong>，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩展原有类的功能</li>
</ul>
<p>装饰模式：<strong>动态地</strong>给一个对象增加一些额外的职责。就扩展功能而言，装饰模式提供了一种<strong>比使用子类更加灵活的替代方案</strong>。</p>
<ul>
<li>以对客户透明的方式<strong>动态地给一个对象附加上更多的责任</strong></li>
<li>可以在<strong>不需要创建更多子类</strong>的情况下，让对象的功能得以扩展</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401152054190.png"></p>
<p>装饰模式的结构</p>
<ul>
<li>Component（抽象构件）</li>
<li>ConcreteComponent（具体构件）</li>
<li>Decorator（抽象装饰类）</li>
<li>ConcreteDecorator（具体装饰类）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象构建类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体构件类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteComponent</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//实现基本功能    </span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象装饰类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> Component component; <span class="comment">//维持一个对抽象构件对象的引用</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//注入一个抽象构件类型的对象</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Decorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.component=component;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">      component.operation();  <span class="comment">//调用原有业务方法</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体装饰类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">ConcreteDecorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(component); </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>.operation(); <span class="comment">//调用原有业务方法</span></span><br><span class="line">      addedBehavior(); <span class="comment">//调用新增业务方法</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//新增业务方法</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addedBehavior</span><span class="params">()</span> &#123;	</span><br><span class="line">      <span class="comment">// ……</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例-11"><a href="#实例-11" class="headerlink" title="实例"></a>实例</h3><p>某软件公司基于面向对象技术开发了一套图形界面构件库——VisualComponent，该构件库提供了大量基本构件，如窗体、文本框、列表框等，由于在使用该构件库时，用户经常要求定制一些特殊的显示效果，如带滚动条的窗体、带黑色边框的文本框、既带滚动条又带黑色边框的列表框等等，因此经常需要对该构件库进行扩展以增强其功能。<br>现使用装饰模式来设计该图形界面构件库。</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401152057948.png"></p>
<h3 id="透明-x2F-半透明装饰模式"><a href="#透明-x2F-半透明装饰模式" class="headerlink" title="透明&#x2F;半透明装饰模式"></a>透明&#x2F;半透明装饰模式</h3><p>透明装饰模式</p>
<ul>
<li>透明(Transparent)装饰模式：要求<strong>客户端完全针对抽象编程</strong>，装饰模式的透明性要求<strong>客户端程序不应该将对象声明为具体构件类型或具体装饰类型，而应该全部声明为抽象构件类型</strong></li>
<li>对于客户端而言，<strong>具体构件对象和具体装饰对象没有任何区别</strong></li>
<li>可以<strong>让客户端透明地使用装饰之前的对象和装饰之后的对象</strong>，无须关心它们的区别</li>
<li>可以<strong>对一个已装饰过的对象进行多次装饰</strong>，得到更为复杂、功能更为强大的对象</li>
<li><strong>无法在客户端单独调用新增方法addedBehavior()</strong></li>
</ul>
<p>半透明装饰模式</p>
<ul>
<li>半透明(Semi-transparent)装饰模式：<strong>用具体装饰类型来定义装饰之后的对象，而具体构件使用抽象构件类型来定义</strong></li>
<li>对于客户端而言，<strong>具体构件类型无须关心，是透明的</strong>；但是<strong>具体装饰类型必须指定，这是不透明的</strong></li>
<li>可以给系统带来更多的灵活性，设计相对简单，使用起来也非常方便</li>
<li>客户端使用具体装饰类型来定义装饰后的对象，因此<strong>可以单独调用addedBehavior()方法</strong></li>
<li>最大的缺点在于<strong>不能实现对同一个对象的多次装饰</strong>，而且<strong>客户端需要有区别地对待装饰之前的对象和装饰之后的对象</strong></li>
</ul>
<h3 id="优缺点与适用环境-7"><a href="#优缺点与适用环境-7" class="headerlink" title="优缺点与适用环境"></a>优缺点与适用环境</h3><p>模式优点</p>
<ul>
<li>对于扩展一个对象的功能，<strong>装饰模式比继承更加灵活，不会导致类的个数急剧增加</strong></li>
<li>可以<strong>通过一种动态的方式来扩展一个对象的功能</strong>，通过配置文件可以在运行时选择不同的具体装饰类，从而实现不同的行为</li>
<li>可以对一个对象进行<strong>多次装饰</strong></li>
<li>具体构件类与具体装饰类可以独立变化，用户<strong>可以根据需要增加新的具体构件类和具体装饰类</strong>，且原有类库代码无须改变，<strong>符合开闭原则</strong></li>
</ul>
<p>模式缺点</p>
<ul>
<li>使用装饰模式进行系统设计时<strong>将产生很多小对象</strong>，大量小对象的产生势必会占用更多的系统资源，在一定程度上<strong>影响程序的性能</strong></li>
<li><strong>比继承更加易于出错，排错也更困难</strong>，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐</li>
</ul>
<p>模式适用环境</p>
<ul>
<li>在不影响其他对象的情况下，<strong>以动态、透明的方式给单个对象添加职责</strong></li>
<li>当<strong>不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时</strong>可以使用装饰模式</li>
</ul>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>半透明装饰模式能否实现对同一个对象的多次装饰？为什么？</p>
<p>是可以的。半透明装饰模式允许对同一个对象应用多个装饰器，每个装饰器可以添加不同的职责或行为。装饰器本身在结构上通常是一个类，它包含了对原始对象的引用，并且提供了额外的行为。你可以将一个装饰器包装在另一个装饰器之上，每个装饰器都可以在不改变对象接口的前提下，为对象添加新的功能。<br>但是，由于半透明装饰模式中装饰器可能会引入新的方法，如果你多次装饰一个对象，可能会导致最终的对象类型变得复杂，客户端需要了解所有装饰器提供的额外方法才能充分利用。这也意味着客户端和具体的装饰器类之间的耦合度增加，这违背了面向对象设计原则中推荐的“对扩展开放，对修改封闭”的原则。<br>总结来说，半透明装饰模式能够实现对同一个对象的多次装饰，每次装饰可以增加新的行为或职责，但这种方式可能会增加系统的复杂性和耦合度。</p>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>分析</p>
<ul>
<li>一个客户类需要和<strong>多个业务类</strong>交互，而这些需要交互的业务类经常会作为一个整体出现</li>
<li>引入一个新的<strong>外观类(Facade)<strong>来负责和</strong>多个业务类【子系统(Subsystem)】</strong>进行交互，而客户类只需与外观类交互</li>
<li>为复杂子系统提供一个简单的访问入口：为多个业务类的调用<strong>提供了一个统一的入口，简化了类与类之间的交互</strong></li>
</ul>
<p>外观模式：为子系统中的一组接口提供一个<strong>统一的入口</strong>。外观模式定义了<strong>一个高层接口</strong>，这个接口使得这一子系统更加容易使用。</p>
<ul>
<li>又称为门面模式</li>
<li>是迪米特法则的一种具体实现</li>
<li>通过<strong>引入一个新的外观角色</strong>来<strong>降低原有系统的复杂度</strong>，同时降低客户类与子系统的耦合度</li>
<li>所指的子系统是一个广义的概念，它可以是一个类、一个功能模块、系统的一个组成部分或者一个完整的系统</li>
</ul>
<h3 id="结构与实现-5"><a href="#结构与实现-5" class="headerlink" title="结构与实现"></a>结构与实现</h3><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401152119552.png"></p>
<ul>
<li>Facade(外观角色)</li>
<li>SubSystem(子系统角色)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子系统类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystemA</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//业务实现代码</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystemB</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//业务实现代码</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystemC</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodC</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//业务实现代码</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外观类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Facade</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">SubSystemA</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubSystemA</span>();</span><br><span class="line">   <span class="keyword">private</span> <span class="type">SubSystemB</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubSystemB</span>();</span><br><span class="line">   <span class="keyword">private</span> <span class="type">SubSystemC</span> <span class="variable">obj3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubSystemC</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">      obj1.method();</span><br><span class="line">      obj2.method();</span><br><span class="line">      obj3.method();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">      <span class="type">Facade</span> <span class="variable">facade</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Facade</span>();</span><br><span class="line">      facade.method();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例-12"><a href="#实例-12" class="headerlink" title="实例"></a>实例</h3><p>某软件公司要开发一个可应用于多个软件的文件加密模块，该模块可以对文件中的数据进行加密并将加密之后的数据存储在一个新文件中，具体的流程包括3个部分，分别是读取源文件、加密、保存加密之后的文件，其中，读取文件和保存文件使用流来实现，加密操作通过求模运算实现。这3个操作相对独立，为了实现代码的独立重用，让设计更符合单一职责原则，这3个操作的业务代码封装在3个不同的类中。<br>现使用外观模式设计该文件加密模块。</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401152122160.png"></p>
<h3 id="抽象外观类"><a href="#抽象外观类" class="headerlink" title="抽象外观类"></a>抽象外观类</h3><p>动机：</p>
<ul>
<li>在标准的外观模式的结构图中，如果需要增加、删除或更换与外观类交互的子系统类，<strong>必须修改外观类或客户端的源代码</strong>，这将<strong>违背开闭原则</strong></li>
<li>可以通过引入<strong>抽象外观类</strong>对系统进行改进，在一定程度上解决该问题。在引人抽象外观类之后,客户端可以针对抽象外观类进行编程</li>
<li><ul>
<li>对于新的业务需求,不需要修改原有外观类,而对应增加一个新的具体外观类,由新的具体外观类来关联新的子系统对象</li>
</ul>
</li>
<li><ul>
<li>同时通过修改配置文件来达到不修改任何源代码并更换外观类的目的。</li>
</ul>
</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401152123760.png"></p>
<h3 id="外观模式与单例模式联用"><a href="#外观模式与单例模式联用" class="headerlink" title="外观模式与单例模式联用"></a>外观模式与单例模式联用</h3><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401152123315.png"></p>
<h3 id="优缺点与适用环境-8"><a href="#优缺点与适用环境-8" class="headerlink" title="优缺点与适用环境"></a>优缺点与适用环境</h3><p>模式优点</p>
<ul>
<li>它<strong>对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易</strong></li>
<li>它<strong>实现了子系统与客户端之间的松耦合关系</strong>，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可</li>
<li><strong>一个子系统的修改对其他子系统没有任何影响</strong>，而且<strong>子系统的内部变化也不会影响到外观对象</strong></li>
</ul>
<p>模式缺点</p>
<ul>
<li><strong>不能很好地限制客户端直接使用子系统类</strong>，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性</li>
<li>如果<strong>设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则</strong></li>
</ul>
<p>模式适用环境</p>
<ul>
<li>要为访问<strong>一系列复杂的子系统提供一个简单入口</strong></li>
<li><strong>客户端程序与多个子系统之间存在很大的依赖性</strong></li>
<li>在层次化结构中，可以<strong>使用外观模式的定义系统中每一层的入口</strong>，层与层之间不直接产生联系，而是通过外观类建立联系，<strong>降低层之间的耦合度</strong></li>
</ul>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p>代理模式：给某一个对象提供<strong>一个代理或占位符</strong>，并由代理对象来控制对原对象的访问。</p>
<ul>
<li>引入一个新的<strong>代理对象</strong></li>
<li>代理对象<strong>在客户端对象和目标对象之间起到中介的作用</strong></li>
<li><strong>去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务</strong></li>
</ul>
<h3 id="结构与实现-6"><a href="#结构与实现-6" class="headerlink" title="结构与实现"></a>结构与实现</h3><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401152127350.png"></p>
<ul>
<li>Subject（抽象主题角色）：声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题</li>
<li>Proxy（代理主题角色）：包含了对真实主题的引用，从而可以在任何时候操作真实对象</li>
<li>RealSubject（真实主题角色）：定义了代理角色所代表的真实对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象主题类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真实主题类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RealSubject</span> <span class="keyword">extends</span> <span class="title class_">Subject</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//业务方法具体实现代码</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">extends</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">   <span class="comment">//维持一个对真实主题对象的引用 </span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">RealSubject</span> <span class="variable">realSubject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealSubject</span>();  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preRequest</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// ……</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">      preRequest();</span><br><span class="line">      realSubject.request();  <span class="comment">//调用真实主题对象的方法</span></span><br><span class="line">      postRequest();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postRequest</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// ……</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>几种常见的代理模式</p>
<ul>
<li>远程代理(Remote Proxy)：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以在同一台主机中，也可以在另一台主机中，远程代理又称为大使(Ambassador)</li>
<li>虚拟代理(Virtual Proxy)：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建</li>
<li>保护代理(Protect Proxy)：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限</li>
<li>缓冲代理(Cache Proxy)：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果</li>
<li>智能引用代理(Smart Reference Proxy)：当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等</li>
</ul>
<h3 id="实例-13"><a href="#实例-13" class="headerlink" title="实例"></a>实例</h3><p>某软件公司承接了某信息咨询公司的收费商务信息查询系统的开发任务，该系统的基本需求如下：</p>
<ol>
<li>在进行商务信息查询之前用户需要通过身份验证，只有合法用户才能够使用该查询系统；</li>
<li>在进行商务信息查询时系统需要记录查询日志，以便根据查询次数收取查询费用。<br>该软件公司开发人员已完成了商务信息查询模块的开发任务，现希望能够以一种松耦合的方式向原有系统增加身份验证和日志记录功能，客户端代码可以无区别地对待原始的商务信息查询模块和增加新功能之后的商务信息查询模块，而且可能在将来还要在该信息查询模块中增加一些新的功能。<br>现使用代理模式设计并实现该收费商务信息查询系统。</li>
</ol>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401152143192.png"></p>
<p>结果及分析</p>
<ul>
<li><strong>保护代理</strong>和<strong>智能引用代理</strong></li>
<li>在代理类ProxySearcher中实现对真实主题类的<strong>权限控制</strong>和<strong>引用计数</strong></li>
</ul>
<h3 id="代理方法"><a href="#代理方法" class="headerlink" title="代理方法"></a>代理方法</h3><h4 id="远程代理"><a href="#远程代理" class="headerlink" title="远程代理"></a>远程代理</h4><p>动机</p>
<ul>
<li><strong>客户端程序可以访问在远程主机上的对象</strong>，远程主机可能具有更好的计算性能与处理速度，可以快速地响应并处理客户端的请求</li>
<li>可以<strong>将网络的细节隐藏起来</strong>，使得客户端不必考虑网络的存在</li>
<li>客户端完全可以认为被代理的远程业务对象是在本地而不是在远程，而<strong>远程代理对象承担了大部分的网络通信工作，并负责对远程业务方法的调用</strong></li>
</ul>
<h4 id="虚拟代理"><a href="#虚拟代理" class="headerlink" title="虚拟代理"></a>虚拟代理</h4><p>动机</p>
<ul>
<li>对于一些<strong>占用系统资源较多或者加载时间较长的对象</strong>，可以给这些对象提供一个虚拟代理</li>
<li>在真实对象创建成功之前<strong>虚拟代理扮演真实对象的替身</strong>，而当真实对象创建之后，<strong>虚拟代理将用户的请求转发给真实对象</strong></li>
<li>使用一个“虚假”的代理对象来代表真实对象，通过代理对象来间接引用真实对象，可以<strong>在一定程度上提高系统的性能</strong></li>
</ul>
<h4 id="Java-动态代理"><a href="#Java-动态代理" class="headerlink" title="Java 动态代理"></a>Java 动态代理</h4><ul>
<li>动态代理(Dynamic Proxy)可以让系统在运行时根据实际需要来<strong>动态创建代理类，让同一个代理类能够代理多个不同的真实主题类而且可以代理不同的方法</strong></li>
<li>Java语言提供了对动态代理的支持，Java语言实现动态代理时需要用到位于<strong>java.lang.reflect</strong>包中的一些类</li>
</ul>
<h3 id="优缺点与适用环境-9"><a href="#优缺点与适用环境-9" class="headerlink" title="优缺点与适用环境"></a>优缺点与适用环境</h3><ul>
<li>模式优点</li>
<li><ul>
<li>能够<strong>协调调用者和被调用者</strong>，在一定程度上<strong>降低了系统的耦合度</strong></li>
</ul>
</li>
<li><ul>
<li>客户端可以针对抽象主题角色进行编程，<strong>增加和更换代理类无须修改源代码，符合开闭原则</strong>，系统具有较好的灵活性和可扩展性</li>
</ul>
</li>
<li>模式优点——逐个分析</li>
<li><ul>
<li>远程代理：可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，<strong>提高了系统的整体运行效率</strong></li>
</ul>
</li>
<li><ul>
<li>虚拟代理：通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以<strong>在一定程度上节省系统的运行开销</strong></li>
</ul>
</li>
<li><ul>
<li>缓冲代理：为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，<strong>优化系统性能，缩短执行时间</strong></li>
</ul>
</li>
<li><ul>
<li>保护代理：可以<strong>控制对一个对象的访问权限</strong>，为不同用户提供不同级别的使用权限</li>
</ul>
</li>
</ul>
<p>模式缺点</p>
<ul>
<li>由于在客户端和真实主题之间增加了代理对象，因此<strong>有些类型的代理模式可能会造成请求的处理速度变慢</strong>（例如保护代理）</li>
<li>实现代理模式需要额外的工作，而且<strong>有些代理模式的实现过程较为复杂</strong>（例如远程代理）</li>
</ul>
<p>模式适用环境</p>
<ul>
<li>当客户端对象需要访问远程主机中的对象时可以使用<strong>远程代理</strong></li>
<li>当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用<strong>虚拟代理</strong></li>
<li>当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用<strong>缓冲代理</strong></li>
<li>当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时可以使用<strong>保护代理</strong></li>
<li>当需要为一个对象的访问（引用）提供一些额外的操作时可以使用<strong>智能引用代理</strong></li>
</ul>
<h3 id="习题-5"><a href="#习题-5" class="headerlink" title="习题"></a>习题</h3><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401152148347.png"></p>
<ol>
<li>A</li>
<li>B</li>
<li>D</li>
</ol>
<h2 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h2><h3 id="行为型模式概述"><a href="#行为型模式概述" class="headerlink" title="行为型模式概述"></a>行为型模式概述</h3><ul>
<li><p>在软件系统运行时对象并不是孤立存在的,它们可以通过相互通信协作完成某些功能，一个对象在运行时也将影响到其他对象的运行。</p>
</li>
<li><p><strong>行为型模式(Behavioral Pattern)关注系统中对象之间的交互</strong>，研究系统在运行时<strong>对象之间的相互通信与协作</strong>，进一步<strong>明确对象的职责</strong></p>
</li>
<li><p>行为型模式：<strong>不仅仅关注类和对象本身</strong>，还<strong>重点关注它们之间的相互作用和职责划分</strong></p>
</li>
<li><p>类行为型模式</p>
</li>
<li><ul>
<li>使用<strong>继承关系</strong>在几个类之间分配行为，主要<strong>通过多态等方式来分配父类与子类的职责</strong></li>
</ul>
</li>
<li><p>对象行为型模式</p>
</li>
<li><ul>
<li>使用对象的<strong>关联关系</strong>来分配行为，主要<strong>通过对象关联等方式来分配两个或多个类的职责</strong></li>
</ul>
</li>
</ul>
<h3 id="职责链模式概述"><a href="#职责链模式概述" class="headerlink" title="职责链模式概述"></a>职责链模式概述</h3><p>职责链模式：<strong>避免</strong>将一个请求的发送者与接收者<strong>耦合</strong>在一起，<strong>让多个对象都有机会处理请求</strong>。将接收请求的对象连接成一条链，并且沿着这条链传递请求，直到有一个对象能够处理它为止。</p>
<ul>
<li>将<strong>请求的处理者组织成一条链</strong>，并让<strong>请求沿着链传递</strong>，由链上的处理者对请求进行相应的处理</li>
<li><strong>客户端无须关心请求的处理细节以及请求的传递</strong>，只需将请求发送到链上，<strong>将请求的发送者和请求的处理者解耦</strong></li>
</ul>
<h3 id="结构与实现-7"><a href="#结构与实现-7" class="headerlink" title="结构与实现"></a>结构与实现</h3><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401152152702.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象处理者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">   <span class="comment">//维持对下家的引用</span></span><br><span class="line">   <span class="keyword">protected</span> Handler successor;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSuccessor</span><span class="params">(Handler successor)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.successor=successor;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(String request)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(String request)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (请求满足条件) &#123;</span><br><span class="line">      <span class="comment">//处理请求</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.successor.handleRequest(request); <span class="comment">//转发请求</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line">……</span><br><span class="line">Handler handler1, handler2, handler3;</span><br><span class="line">handler1 = <span class="keyword">new</span> <span class="title class_">ConcreteHandlerA</span>();</span><br><span class="line">handler2 = <span class="keyword">new</span> <span class="title class_">ConcreteHandlerB</span>();</span><br><span class="line">handler3 = <span class="keyword">new</span> <span class="title class_">ConcreteHandlerC</span>();</span><br><span class="line"><span class="comment">//创建职责链</span></span><br><span class="line">handler1.setSuccessor(handler2);</span><br><span class="line">handler2.setSuccessor(handler3);</span><br><span class="line"><span class="comment">//发送请求，请求对象通常为自定义类型</span></span><br><span class="line">handler1.handleRequest(<span class="string">&quot;请求对象&quot;</span>); …</span><br></pre></td></tr></table></figure>

<h3 id="实例-14"><a href="#实例-14" class="headerlink" title="实例"></a>实例</h3><p>某企业的SCM(Supply Chain Management，供应链管理)系统中包含一个采购审批子系统。该企业的采购审批是分级进行的，即根据采购金额的不同由不同层次的主管人员来审批，主任可以审批5万元以下（不包括5万元）的采购单，副董事长可以审批5万元至10万元（不包括10万元）的采购单，董事长可以审批10万元至50万元（不包括50万元）的采购单，50万元及以上的采购单就需要开董事会讨论决定。<br>现使用职责链模式设计并实现该系统。</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401152158747.png"></p>
<h3 id="纯与不纯的职责链模式"><a href="#纯与不纯的职责链模式" class="headerlink" title="纯与不纯的职责链模式"></a>纯与不纯的职责链模式</h3><p>纯的职责链模式</p>
<ul>
<li>一个具体处理者对象只能在两个行为中选择一个：<strong>要么承担全部责任，要么将责任推给下家</strong></li>
<li><strong>不允许出现某一个具体处理者对象在承担了一部分或全部责任后又将责任向下传递</strong>的情况</li>
<li><strong>一个请求必须被某一个处理者对象所接收，不能出现某个请求未被任何一个处理者对象处理</strong>的情况</li>
</ul>
<p>不纯的职责链模式</p>
<ul>
<li><strong>允许某个请求被一个具体处理者部分处理后向下传递</strong>，或者<strong>一个具体处理者处理完某请求后其后继处理者可以继续处理该请求</strong></li>
<li>一个请求<strong>可以最终不被任何处理者对象所接收并处理</strong></li>
</ul>
<h3 id="优缺点与适用场景"><a href="#优缺点与适用场景" class="headerlink" title="优缺点与适用场景"></a>优缺点与适用场景</h3><p>模式优点</p>
<ul>
<li>使得一个对象无须知道是其他哪一个对象处理其请求，<strong>降低了系统的耦合度</strong></li>
<li>可<strong>简化对象之间的相互连接</strong></li>
<li>给对象<strong>职责的分配带来更多的灵活性</strong></li>
<li><strong>增加一个新的具体请求处理者时无须修改原有系统的代码</strong>，只需要在客户端重新建链即可</li>
</ul>
<p>模式缺点</p>
<ul>
<li><strong>不能保证请求一定会被处理</strong></li>
<li>对于比较长的职责链，<strong>系统性能将受到一定影响，在进行代码调试时不太方便</strong></li>
<li>如果建链不当，可能会造成<strong>循环调用，将导致系统陷入死循环</strong></li>
</ul>
<p>模式适用环境</p>
<ul>
<li><strong>有多个对象可以处理同一个请求</strong>，具体哪个对象处理该请求待运行时刻再确定</li>
<li>在不明确指定接收者的情况下，<strong>向多个对象中的一个提交一个请求</strong></li>
<li><strong>可动态指定一组对象处理请求</strong></li>
</ul>
<h3 id="习题-6"><a href="#习题-6" class="headerlink" title="习题"></a>习题</h3><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401152201531.png"></p>
<ol>
<li>B</li>
<li>A</li>
</ol>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p>动机</p>
<ul>
<li>将请求发送者和接收者<strong>完全解耦</strong></li>
<li>发送者与接收者之间<strong>没有直接引用关系</strong></li>
<li>发送请求的对象<strong>只需要知道如何发送请求，而不必知道如何完成请求</strong></li>
</ul>
<p>命令模式：<strong>将一个请求封装为一个对象</strong>，从而让你可以用不同的请求<strong>对客户进行参数化</strong>，<strong>对请求排队或者记录请求日志</strong>，以及<strong>支持可撤销的操作</strong>。</p>
<ul>
<li>别名为动作(Action)模式或事务(Transaction)模式</li>
<li>“用不同的请求对客户进行参数化”</li>
<li>“对请求排队”</li>
<li>“记录请求日志”</li>
<li>“支持可撤销操作”</li>
</ul>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401152224695.png"></p>
<ul>
<li>命令模式的本质是<strong>对请求进行封装</strong></li>
<li><strong>一个请求对应于一个命令</strong>，将发出命令的责任和执行命令的责任分开</li>
<li>命令模式<strong>允许请求的一方和接收的一方独立开来</strong>，使得<strong>请求的一方不必知道接收请求的一方的接口</strong>，更不必知道<strong>请求如何被接收、操作是否被执行、何时被执行，以及是怎么被执行的</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象命令类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用者（请求发送者类）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> Command command;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 构造注入</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Invoker</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.command = command;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设值注入</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommand</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.command = command;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 业务方法，用于调用命令类的execute()方法</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">      command.execute();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体命令类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteCommand</span> <span class="keyword">extends</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> Receiver receiver; <span class="comment">//维持一个对请求接收者对象的引用</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">      receiver.action(); <span class="comment">//调用请求接收者的业务处理方法action()</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求接收者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Receiver</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//具体操作</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例-15"><a href="#实例-15" class="headerlink" title="实例"></a>实例</h3><p>为了用户使用方便，某系统提供了一系列功能键，用户可以自定义功能键的功能，例如功能键FunctionButton可以用于退出系统（由SystemExitClass类来实现），也可以用于显示帮助文档（ 由DisplayHelpClass类来实现）。<br>用户可以通过修改配置文件来改变功能键的用途，现使用命令模式来设计该系统，使得功能键类与功能类之间解耦，可为同一个功能键设置不同的功能。</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401152232779.png"></p>
<p>结果及分析</p>
<ul>
<li>如果需要更换具体命令类，无须修改源代码，<strong>只需修改配置文件，完全符合开闭原则</strong></li>
<li>每一个<strong>具体命令类</strong>对应一个<strong>请求的处理者（接收者）</strong>，通过向请求发送者注入不同的具体命令对象可以使相同的发送者对应不同的接收者，从而实现“<strong>将一个请求封装为一个对象，用不同的请求对客户进行参数化</strong>”，<strong>客户端只需要将具体命令对象作为参数注入请求发送者，无须直接操作请求的接收者</strong></li>
</ul>
<h3 id="记录请求日志"><a href="#记录请求日志" class="headerlink" title="记录请求日志"></a>记录请求日志</h3><ul>
<li>将请求的历史记录保存下来，通常以日志文件(Log File)的形式永久存储在计算机中</li>
<li><ul>
<li>为系统提供一种恢复机制</li>
</ul>
</li>
<li><ul>
<li>可以用于实现批处理</li>
</ul>
</li>
<li><ul>
<li>防止因为断电或者系统重启等原因造成请求丢失，而且可以避免重新发送全部请求时造成某些命令的重复执行</li>
</ul>
</li>
<li>将发送请求的命令对象通过序列化写到日志文件中</li>
<li>命令类必须实现接口Serializable</li>
</ul>
<h3 id="宏命令"><a href="#宏命令" class="headerlink" title="宏命令"></a>宏命令</h3><ul>
<li>宏命令(Macro Command)又称为**组合命令(Composite Command)**，它是组合模式和命令模式联用的产物</li>
<li>宏命令是一个具体命令类，它<strong>拥有一个集合</strong>，在该集合中包含了对其他命令对象的引用</li>
<li>当调用宏命令的execute()方法时，<strong>将递归调用它所包含的每个成员命令的execute()方法</strong>。一个宏命令的成员可以是简单命令，还可以继续是宏命令</li>
<li>执行一个宏命令将触发多个具体命令的执行，从而<strong>实现对命令的批处理</strong></li>
</ul>
<h3 id="优缺点与适用环境-10"><a href="#优缺点与适用环境-10" class="headerlink" title="优缺点与适用环境"></a>优缺点与适用环境</h3><p>模式优点</p>
<ul>
<li><strong>降低系统的耦合度</strong></li>
<li>新的命令可以很容易地加入到系统中，<strong>符合开闭原则</strong></li>
<li>可以比较容易地设计一个<strong>命令队列或宏命令（组合命令）</strong></li>
<li>为请求的**撤销(Undo)和恢复(Redo)**操作提供了一种设计和实现方案</li>
</ul>
<p>模式缺点</p>
<ul>
<li>使用命令模式<strong>可能会导致某些系统有过多的具体命令类</strong>（针对每一个对请求接收者的调用操作都需要设计一个具体命令类）</li>
</ul>
<p>模式适用环境</p>
<ul>
<li>系统需要<strong>将请求调用者和请求接收者解耦</strong>，使得调用者和接收者不直接交互</li>
<li>系统需要<strong>在不同的时间指定请求、将请求排队和执行请求</strong></li>
<li>系统需要<strong>支持命令的撤销(Undo)操作和恢复(Redo)操作</strong></li>
<li>系统需要<strong>将一组操作组合在一起形成宏命令</strong></li>
</ul>
<h3 id="习题-7"><a href="#习题-7" class="headerlink" title="习题"></a>习题</h3><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401152237050.png"></p>
<ol>
<li>D</li>
<li>C</li>
</ol>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h3 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h3><ul>
<li>软件系统：<strong>一个对象的状态或行为的变化将导致其他对象的状态或行为也发生改变</strong>，它们之间将产生<strong>联动</strong></li>
<li>观察者模式：</li>
<li><ul>
<li>定义了对象之间一种<strong>一对多</strong>的依赖关系，让一个对象的改变能够影响其他对象</li>
</ul>
</li>
<li><ul>
<li>发生改变的对象称为<strong>观察目标</strong>，被通知的对象称为<strong>观察者</strong></li>
</ul>
</li>
<li><ul>
<li><strong>一个观察目标可以对应多个观察者</strong></li>
</ul>
</li>
</ul>
<p>观察者模式：定义对象之间的一种<strong>一对多依赖关系</strong>，使得每当<strong>一个对象状态发生改变</strong>时，其相关依赖对象<strong>都得到通知并被自动更新</strong>。</p>
<ul>
<li>发布-订阅(Publish&#x2F;Subscribe)模式</li>
<li>模型-视图(Model&#x2F;View)模式</li>
<li>源-监听器(Source&#x2F;Listener)模式</li>
<li>从属者(Dependents)模式</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401152244972.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象目标类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">   <span class="comment">//定义一个观察者集合用于存储所有观察者对象</span></span><br><span class="line">   <span class="keyword">protected</span> ArrayList observers&lt;Observer&gt; = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//注册方法，用于向观察者集合中增加一个观察者</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">      observers.add(observer);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//注销方法，用于在观察者集合中删除一个观察者</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">      observers.remove(observer);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//声明抽象通知方法</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体目标类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">   <span class="comment">//实现通知方法</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//遍历观察者集合，调用每一个观察者的响应方法</span></span><br><span class="line">      <span class="keyword">for</span>(Object obs:observers) &#123;</span><br><span class="line">         ((Observer)obs).update();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象观察者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">   <span class="comment">//声明响应方法</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体观察者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">   <span class="comment">//实现响应方法</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//具体响应代码</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码片段</span></span><br><span class="line">……</span><br><span class="line"><span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteSubject</span>();</span><br><span class="line"><span class="type">Observer</span> <span class="variable">observer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteObserver</span>();</span><br><span class="line">subject.attach(observer); <span class="comment">//注册观察者</span></span><br><span class="line">subject.notify();<span class="comment">//调用在其观察者集合中注册的观察者对象update()方法</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<ul>
<li>有时候<strong>在具体观察者类ConcreteObserver中需要使用到具体目标类ConcreteSubject中的状态（属性）</strong>，会存在<strong>关联或依赖关系</strong></li>
<li><strong>如果在具体层之间具有关联关系</strong>，系统的扩展性将受到一定的影响，<strong>增加新的具体目标类有时候需要修改原有观察者的代码</strong>，在一定程度上违背了开闭原则</li>
</ul>
<h3 id="实例-16"><a href="#实例-16" class="headerlink" title="实例"></a>实例</h3><p>在某多人联机对战游戏中，多个玩家可以加入同一战队组成联盟，当战队中的某一成员受到敌人攻击时将给所有其他盟友发送通知，盟友收到通知后将做出响应。<br>现使用观察者模式设计并实现该过程，以实现战队成员之间的联动。</p>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401152248007.png"></p>
<h3 id="观察者模式与Java事件处理"><a href="#观察者模式与Java事件处理" class="headerlink" title="观察者模式与Java事件处理"></a>观察者模式与Java事件处理</h3><ul>
<li>事件源对象充当观察目标角色</li>
<li>事件监听器充当抽象观察者角色</li>
<li>事件处理对象充当具体观察者角色</li>
</ul>
<h3 id="观察者模式与MVC"><a href="#观察者模式与MVC" class="headerlink" title="观察者模式与MVC"></a>观察者模式与MVC</h3><p>MVC(Model-View-Controller)架构</p>
<ul>
<li>模型(Model)，视图(View)和控制器(Controller)</li>
<li>模型可对应于观察者模式中的观察目标，而视图对应于观察者，控制器可充当两者之间的中介者</li>
<li>当模型层的数据发生改变时，视图层将自动改变其显示内容</li>
</ul>
<h3 id="优缺点与适用环境-11"><a href="#优缺点与适用环境-11" class="headerlink" title="优缺点与适用环境"></a>优缺点与适用环境</h3><p>模式优点</p>
<ul>
<li>可以<strong>实现表示层和数据逻辑层的分离</strong></li>
<li>在观察目标和观察者之间<strong>建立一个抽象的耦合</strong></li>
<li>支持<strong>广播通信，简化了一对多系统设计的难度</strong></li>
<li><strong>符合开闭原则</strong>，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便</li>
</ul>
<p>模式缺点</p>
<ul>
<li>将所有的观察者都通知到会<strong>花费很多时间</strong></li>
<li>如果存在<strong>循环依赖</strong>时可能导致<strong>系统崩溃</strong></li>
<li><strong>没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的</strong>，而只是知道观察目标发生了变化</li>
</ul>
<p>模式适用环境</p>
<ul>
<li>一个抽象模型有两个方面，其中<strong>一个方面依赖于另一个方面</strong>，将这两个方面封装在独立的对象中使它们<strong>可以各自独立地改变和复用</strong></li>
<li><strong>一个对象的改变将导致一个或多个其他对象发生改变，且并不知道具体有多少对象将发生改变，也不知道这些对象是谁</strong></li>
<li>需要在系统中创建一个<strong>触发链</strong></li>
</ul>
<h3 id="习题-8"><a href="#习题-8" class="headerlink" title="习题"></a>习题</h3><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401152252026.png"></p>
<ol>
<li>D</li>
<li>A</li>
<li>C</li>
</ol>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h3><ul>
<li>实现某个目标的途径不止一条，可根据实际情况选择一条合适的途径</li>
<li>软件开发：</li>
<li><ul>
<li>多种算法，例如排序、查找、打折等</li>
</ul>
</li>
<li><ul>
<li>使用**硬编码(Hard Coding)**实现将导致系统违背开闭原则，扩展性差，且维护困难</li>
</ul>
</li>
<li><ul>
<li>可以定义一些独立的类来封装不同的算法，<strong>每一个类封装一种具体的算法-&gt;策略类</strong></li>
</ul>
</li>
</ul>
<p>策略模式：定义<strong>一系列算法，将每一个算法封装起来</strong>，并让它们可以相互替换。策略模式让算法可以独立于使用它的客户变化。</p>
<ul>
<li>又称为政策(Policy)模式</li>
<li>每一个封装算法的类称之为策略(Strategy)类</li>
<li>策略模式提供了一种<strong>可插入式(Pluggable)算法</strong>的实现方案</li>
</ul>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401152256301.png"></p>
<h3 id="结构与实现-8"><a href="#结构与实现-8" class="headerlink" title="结构与实现"></a>结构与实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象策略类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">()</span>; <span class="comment">//声明抽象算法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> <span class="keyword">extends</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">   <span class="comment">//算法的具体实现</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//算法A</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 环境类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> Strategy strategy; <span class="comment">//维持一个对抽象策略类的引用</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//注入策略对象</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStrategy</span><span class="params">(Strategy strategy)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.strategy= strategy;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//调用策略类中的算法</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">()</span> &#123;</span><br><span class="line">      strategy.algorithm();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line">……</span><br><span class="line"><span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line">Strategy strategy;</span><br><span class="line">strategy = <span class="keyword">new</span> <span class="title class_">ConcreteStrategyA</span>(); <span class="comment">//可在运行时指定类型，通过配置</span></span><br><span class="line">文件和反射机制实现</span><br><span class="line">context.setStrategy(strategy);</span><br><span class="line">context.algorithm();</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<h3 id="实例-17"><a href="#实例-17" class="headerlink" title="实例"></a>实例</h3><p>某软件公司为某电影院开发了一套影院售票系统，在该系统中需要为<br>不同类型的用户提供不同的电影票打折方式，具体打折方案如下：</p>
<ol>
<li>学生凭学生证可享受票价8折优惠。</li>
<li>年龄在10周岁及以下的儿童可享受每张票减免10元的优惠（原始票价需大于等于20元）。</li>
<li>影院VIP用户除享受票价半价优惠外还可进行积分，积分累计到一定额度可换取电影院赠送的奖品。<br>该系统在将来可能还要根据需要引入新的打折方式。现使用策略模式<br>设计该影院售票系统的打折方案。</li>
</ol>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401152300679.png"></p>
<p>结果及分析</p>
<ul>
<li>如果需要更换具体策略类，无须修改源代码，只需修改配置文件即可，完全<strong>符合开闭原则</strong></li>
<li>如果需要增加新的打折方式，原有代码均无须修改，只要增加一个新的折扣类作为抽象折扣类的子类，实现在抽象折扣类中声明的打折方法，然后修改配置文件，将原有具体折扣类的类名改为新增折扣类的类名即可，完全符合开闭原则。</li>
</ul>
<h3 id="优缺点与适用环境-12"><a href="#优缺点与适用环境-12" class="headerlink" title="优缺点与适用环境"></a>优缺点与适用环境</h3><p>模式优点</p>
<ul>
<li>提供了<strong>对开闭原则的完美支持</strong>，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为</li>
<li>提供了<strong>管理相关的算法族的办法</strong></li>
<li>提供了一种<strong>可以替换继承关系的办法</strong></li>
<li>可以<strong>避免多重条件选择语句</strong></li>
<li>提供了一种<strong>算法的复用机制</strong>，不同的环境类可以方便地复用策略类</li>
</ul>
<p>模式缺点</p>
<ul>
<li>客户端<strong>必须知道所有的策略类</strong>，并自行决定使用哪一个策略类</li>
<li>将造成系统<strong>产生很多具体策略类</strong></li>
<li><strong>无法同时在客户端使用多个策略类</strong></li>
</ul>
<p>模式适用环境</p>
<ul>
<li>一个系统需要<strong>动态地在几种算法中选择一种</strong></li>
<li><strong>避免使用难以维护的多重条件选择语句</strong></li>
<li>不希望客户端知道复杂的、与算法相关的数据结构，<strong>提高算法的保密性与安全性</strong></li>
</ul>
<h3 id="习题-9"><a href="#习题-9" class="headerlink" title="习题"></a>习题</h3><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401152302808.png"></p>
<ol>
<li>B</li>
<li>B</li>
<li>A</li>
</ol>
<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><h3 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h3><p>模板方法模式：定义一个操作中<strong>算法的框架</strong>，而将<strong>一些步骤延迟到子类中</strong>。模板方法模式使得子类不改变一个算法的结构即可<strong>重定义</strong>该算法的<strong>某些特定步骤</strong>。</p>
<ul>
<li>是一种<strong>基于继承的代码复用技术（类行为型模式）</strong></li>
<li>最简单的行为型设计模式：只存在父类与子类之间的继承关系。</li>
<li>通过使用模板方法模式可以将一些<strong>复杂流程</strong>的实现步骤封装在一系列<strong>基本方法</strong>中</li>
<li>在抽象父类中提供一个称之为<strong>模板方法</strong>的方法来<strong>定义这些基本方法的执行次序</strong>，而通过其子类来覆盖某些步骤，从而使得<strong>相同的算法框架</strong>可以有<strong>不同的执行结果</strong></li>
</ul>
<h3 id="结构与实现-9"><a href="#结构与实现-9" class="headerlink" title="结构与实现"></a>结构与实现</h3><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401152307093.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">   <span class="comment">//模板方法</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">      primitiveOperation1();</span><br><span class="line">      primitiveOperation2();</span><br><span class="line">      primitiveOperation3();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//基本方法—具体方法</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">primitiveOperation1</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//实现代码</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//基本方法—抽象方法</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">primitiveOperation2</span><span class="params">()</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//基本方法—钩子方法</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">primitiveOperation3</span><span class="params">()</span></span><br><span class="line">   &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">primitiveOperation2</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//实现代码</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">primitiveOperation3</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//实现代码</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例-18"><a href="#实例-18" class="headerlink" title="实例"></a>实例</h3><p>某软件公司要为某银行的业务支撑系统开发一个利息计算模块，利息的计算流程如下：</p>
<ol>
<li>系统根据账号和密码验证用户信息，如果用户信息错误，则系统显示出错提示。</li>
<li>如果用户信息正确，则根据用户类型的不同使用不同的利息计算公式计算利息（如活期账户和定期账户具有不同的利息计算公式）。</li>
<li>系统显示利息。<br>现使用模板方法模式设计该利息计算模块。</li>
</ol>
<p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401152310026.png"></p>
<h3 id="优缺点与适用环境-13"><a href="#优缺点与适用环境-13" class="headerlink" title="优缺点与适用环境"></a>优缺点与适用环境</h3><p>模式优点</p>
<ul>
<li>在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，<strong>在子类实现详细的处理算法时并不会改变算法中步骤的执行次序</strong></li>
<li>提取了类库中的公共行为，<strong>将公共行为放在父类中</strong>，而通过其子类来实现不同的行为</li>
<li>可实现一种<strong>反向控制结构</strong>，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行</li>
<li>更换和增加新的子类很方便，<strong>符合单一职责原则和开闭原则</strong></li>
</ul>
<p>模式缺点</p>
<ul>
<li>需要为每一个基本方法的不同实现提供一个子类，<strong>如果父类中可变的基本方法太多，将会导致类的个数增加</strong>，系统会更加庞大，设计也更加抽象（可结合桥接模式）</li>
</ul>
<p>模式适用环境</p>
<ul>
<li><strong>一次性实现一个算法的不变部分</strong>，并将<strong>可变的行为留给子类来实现</strong></li>
<li>各子类中<strong>公共的行为</strong>应被提取出来，并集中到一个<strong>公共父类</strong>中，以<strong>避免代码重复</strong></li>
<li>需要<strong>通过子类来决定父类算法中某个步骤是否执行</strong>，实现<strong>子类对父类的反向控制</strong></li>
</ul>
<h3 id="习题-10"><a href="#习题-10" class="headerlink" title="习题"></a>习题</h3><p><img data-src="https://blog-1319684755.cos.ap-guangzhou.myqcloud.com/blog-images/202401152313297.png"></p>
<ol>
<li>C </li>
<li>D</li>
</ol>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>university</tag>
        <tag>software-architecture</tag>
      </tags>
  </entry>
</search>
